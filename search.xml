<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记 2020 11 17</title>
    <url>/2020/11/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-17/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-17"><a href="#学习笔记-2020-11-17" class="headerlink" title="学习笔记 2020-11-17"></a>学习笔记 2020-11-17</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><h5 id="用户界面事件"><a href="#用户界面事件" class="headerlink" title="用户界面事件"></a>用户界面事件</h5><ul>
<li>DOMActivate</li>
<li>load</li>
<li>unload</li>
<li>abort</li>
<li>error</li>
<li>select</li>
<li>resize</li>
<li>scroll</li>
</ul>
<ol>
<li><p>load 事件</p>
<p>一般来说，在 window 上发生的事件，都可以通过给 <code>&lt;body&gt;</code> 元素上对应的属性赋值来指定。</p>
</li>
<li><p>unload 事件</p>
</li>
<li><p>resize 事件</p>
</li>
<li><p>scroll 事件</p>
<p>scroll 事件发生在 window 上。在混杂模式下，可以通过 body 元素检测 scrollLeft 和 scrollTop 属性的变化。在标准模式下，这些变化在除早期版的 Safari 之外的所有浏览器上都发生在 html 元素上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.scrollTop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h5><ul>
<li>blur</li>
<li>DOMFocusIn</li>
<li>DOMFocusOut</li>
<li>focus</li>
<li>focusin</li>
<li>focusout</li>
</ul>
<h5 id="鼠标和滚轮事件"><a href="#鼠标和滚轮事件" class="headerlink" title="鼠标和滚轮事件"></a>鼠标和滚轮事件</h5><ul>
<li>click，响应鼠标主键和键盘回车键。</li>
<li>dbclick</li>
<li>mousedown</li>
<li>mouseenter，鼠标光标从元素外部移到元素内部。不冒泡。</li>
<li>mouseleave，鼠标光标从元素内部移到元素外部。不冒泡。</li>
<li>mousemove，鼠标光标在元素上移动。</li>
<li>mouseout，鼠标光标从一个元素移到另一个元素。</li>
<li>mouseover，鼠标光标从元素外部移到元素内部。</li>
<li>mouseup</li>
<li>mousewheel，鼠标滚轮事件。</li>
</ul>
<p>触发顺序：</p>
<ol>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>dbclick</li>
</ol>
<p>click 和 dbclick 依赖其他事件触发。</p>
<ol>
<li><p>客户端坐标</p>
<ul>
<li>event.clientX</li>
<li>event.clientY</li>
</ul>
<p>鼠标光标在视口中的坐标。</p>
</li>
<li><p>页面坐标</p>
<ul>
<li>event.pageX</li>
<li>event.pageY</li>
</ul>
<p>鼠标光标在页面上的坐标。</p>
</li>
<li><p>屏幕坐标</p>
<ul>
<li>event.screenX</li>
<li>event.screenY</li>
</ul>
<p>鼠标光标在整个屏幕上的坐标。</p>
</li>
<li><p>修饰键</p>
<ul>
<li>event.shiftKey</li>
<li>event.ctrlKey</li>
<li>event.altKey</li>
<li>event.metaKey</li>
</ul>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="函数对象，NFE"><a href="#函数对象，NFE" class="headerlink" title="函数对象，NFE"></a>函数对象，NFE</h3><ol>
<li><p>属性，name</p>
<p>函数名</p>
</li>
<li><p>属性，length</p>
<p>函数形参个数，rest 参数不参与计数。</p>
</li>
<li><p>自定义属性</p>
</li>
<li><p>命名函数表达式</p>
</li>
</ol>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>为 counter 添加 set 和 decrease 方法</p>
<p>修改 <code>makeCounter()</code> 代码，使得 counter 可以进行减一和设置值的操作：</p>
<ul>
<li><code>counter()</code> 应该返回下一个数字（与之前的逻辑相同）。</li>
<li><code>counter.set(value)</code> 应该将 <code>count</code> 设置为 <code>value</code>。</li>
<li><code>counter.decrease(value)</code> 应该把 <code>count</code> 减 1。</li>
</ul>
<p>查看沙箱中的代码获取完整使用示例。</p>
<p>P.S. 你可以使用闭包或者函数属性来保持当前的计数，或者两种都写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter.count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  counter.count = <span class="number">0</span>;</span><br><span class="line">  counter.set = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  counter.decrease = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任意数量的括号求和</p>
<p>写一个函数 <code>sum</code>，它有这样的功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>) == <span class="number">3</span>; <span class="comment">// 1 + 2</span></span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) == <span class="number">6</span>; <span class="comment">// 1 + 2 + 3</span></span><br><span class="line">sum(<span class="number">5</span>)(<span class="number">-1</span>)(<span class="number">2</span>) == <span class="number">6</span></span><br><span class="line">sum(<span class="number">6</span>)(<span class="number">-1</span>)(<span class="number">-2</span>)(<span class="number">-3</span>) == <span class="number">0</span></span><br><span class="line">sum(<span class="number">0</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) == <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>P.S. 提示：你可能需要创建自定义对象来为你的函数提供基本类型转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    num += n;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">  f.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 16</title>
    <url>/2020/11/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-16/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-16"><a href="#学习笔记-2020-11-16" class="headerlink" title="学习笔记 2020-11-16"></a>学习笔记 2020-11-16</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><h5 id="DOM2-事件处理程序"><a href="#DOM2-事件处理程序" class="headerlink" title="DOM2 事件处理程序"></a>DOM2 事件处理程序</h5><h5 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h5><ol>
<li>attachEvent()</li>
<li>detachEvent()</li>
</ol>
<p>IE 中的事件处理程序作用域是在全局。多个事件监听触发顺序是逆序。</p>
<h5 id="跨浏览器事件处理程序"><a href="#跨浏览器事件处理程序" class="headerlink" title="跨浏览器事件处理程序"></a>跨浏览器事件处理程序</h5><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><h5 id="DOM-事件对象"><a href="#DOM-事件对象" class="headerlink" title="DOM 事件对象"></a>DOM 事件对象</h5><p>所有事件对象的公共属性和方法：</p>
<ul>
<li>bubbles</li>
<li>cancelable</li>
<li>currentTarget</li>
<li>defaultPrevented</li>
<li>detail</li>
<li>eventPhase</li>
<li>preventDefault()</li>
<li>stopImmediatePropagation()</li>
<li>stopPropagation()</li>
<li>target</li>
<li>trusted</li>
<li>type</li>
<li>View</li>
</ul>
<p>事件处理程序内部，this 对象始终等于 currentTarget 的值。</p>
<h5 id="IE-事件对象"><a href="#IE-事件对象" class="headerlink" title="IE 事件对象"></a>IE 事件对象</h5><ol>
<li><p>DOM0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> e = <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>attachEvent()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// event === window.event</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>IE 事件对象的公共属性和方法：</p>
<ul>
<li>cancelBubble</li>
<li>returnValue</li>
<li>srcElement</li>
<li>type</li>
</ul>
<h5 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 15</title>
    <url>/2020/11/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-15/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-15"><a href="#学习笔记-2020-11-15" class="headerlink" title="学习笔记 2020-11-15"></a>学习笔记 2020-11-15</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h3><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><h5 id="操作范围"><a href="#操作范围" class="headerlink" title="操作范围"></a>操作范围</h5><ul>
<li>deleteContents()</li>
<li>extractContents()</li>
<li>cloneContents()</li>
</ul>
<h5 id="范围插入"><a href="#范围插入" class="headerlink" title="范围插入"></a>范围插入</h5><ul>
<li>insertNode()</li>
<li>surroundContents()</li>
</ul>
<h5 id="范围折叠"><a href="#范围折叠" class="headerlink" title="范围折叠"></a>范围折叠</h5><ul>
<li>collapse()</li>
<li>collapsed</li>
</ul>
<h5 id="范围比较"><a href="#范围比较" class="headerlink" title="范围比较"></a>范围比较</h5><ul>
<li>compareBoundaryPoints()</li>
</ul>
<h5 id="复制范围"><a href="#复制范围" class="headerlink" title="复制范围"></a>复制范围</h5><ul>
<li>cloneRange()</li>
</ul>
<h5 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h5><ul>
<li>detach()</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><h5 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h5><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><h5 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h5><p>可以在 HTML 元素上定义事件属性，这个函数有一个特殊的局部变量 event。函数中 this 值相当于事件的目标元素，其作用域链被扩展了，在这个函数中，document 和元素自身的成员都可以被当成局部变量来访问。这是通过 with 实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此可以直接在函数中访问自己的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出"Click Me" --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="DOM0-事件处理程序"><a href="#DOM0-事件处理程序" class="headerlink" title="DOM0 事件处理程序"></a>DOM0 事件处理程序</h5>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 14</title>
    <url>/2020/11/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-14/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-14"><a href="#学习笔记-2020-11-14" class="headerlink" title="学习笔记 2020-11-14"></a>学习笔记 2020-11-14</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h3><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="元素尺寸"><a href="#元素尺寸" class="headerlink" title="元素尺寸"></a>元素尺寸</h5><ol>
<li><p>滚动尺寸</p>
<p>滚动尺寸提供了元素内容滚动距离的信息。有些元素，比如 <code>&lt;html&gt;</code> 无须任何代码就可以自动滚动，而其他元素需要使用 CSS 的 overflow 属性令其滚动。滚动尺寸相关属性有 4 个：</p>
<ul>
<li>scrollHeight，没有滚动条出现时，元素内容的总高度。</li>
<li>scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li>scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li>scrollWidth，没有滚动条出现时，元素内容的总宽度。</li>
</ul>
<p><img src="/2020/11/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-14/image-20201114085706671.png" alt="image-20201114085706671"></p>
<p>scrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。</p>
<p>scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，scrollWidth 和 scrollHeight 表示文档内容的宽高，clientWidth 和 clientHeight 等于视口宽高。</p>
</li>
<li><p>确定元素尺寸</p>
<p>浏览器在每个元素上都暴露了 getBoundingClientRect() 方法，返回一个 DOMRect 对象，包含 6 个属性： left、top、right、bottom、height 和 width 。这些属性给出了元素在页面中相对于视口的位置。</p>
</li>
</ol>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— NodeIterator 和 TreeWalker ——从某个起点开始执行对 DOM 结构的深度优先遍历。</p>
<h5 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h5><p>NodeIterator 可以通过 document.createNodeIterator() 方法创建其实例。接收 4 个参数：</p>
<ul>
<li>root，作为遍历根节点的节点。</li>
<li>whatToShow，数值代码，表示应该访问哪些节点。</li>
<li>filter，NodeFilter 对象或函数，表示是否接收或跳过特定节点。</li>
<li>entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永不扩展。</li>
</ul>
<p>whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在 NodeFilter 类型中定义的。</p>
<ul>
<li>NodeFilter.SHOW_ALL，所有节点。</li>
<li>NodeFilter.SHOW_ELEMENT，元素节点。</li>
<li>NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。</li>
<li>NodeFilter.SHOW_TEXT，文本节点。</li>
<li>NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_COMMENT，注释节点。</li>
<li>NodeFilter.SHOW_DOCUMENT，文档节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的。</li>
</ul>
<p>除了第一个，其余的可以组合使用，按位或来组合多个选项。</p>
<p>filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数。NodeFilter 对象只有一个方法 acceptNode() ，如果给定节点应该访问就返回 NodeFilter.FILTER_ACCEPT，否则返回 NodeFilter.FILTER_SKIP。因为 NodeFilter 是一个抽象类型，所以不可能创建它的实例。只要创建一个包含 acceptNode() 的对象，然后把它传给createNodeIterator() 就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只接收 p 元素的节点过滤器对象</span></span><br><span class="line"><span class="keyword">let</span> filter = &#123;</span><br><span class="line">  acceptNode(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">'p'</span></span><br><span class="line">      ? NodeFilter.FILTER_ACCEPT</span><br><span class="line">      : NodeFilter.FILTER_SKIP;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或是以下形式</span></span><br><span class="line"><span class="keyword">let</span> filter = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">'p'</span></span><br><span class="line">    ? NodeFilter.FILTER_ACCEPT</span><br><span class="line">    : NodeFilter.FILTER_SKIP;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="built_in">document</span>.createNodeIterator(</span><br><span class="line">  root,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT,</span><br><span class="line">  filter,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>NodeIterator 的两个主要方法是：</p>
<ul>
<li>nextNode()，在 DOM 子树中以深度优先方式进前一步。</li>
<li>previousNode()，后退一步。</li>
</ul>
<h5 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h5><p>TreeWalker 比 NodeIterator 多了以下方法：</p>
<ul>
<li>parentNode()</li>
<li>firstChild()</li>
<li>lastChild()</li>
<li>nextSibling()</li>
<li>previousSibling()</li>
</ul>
<p>调用 document.createTreeWalker() 创建 TreeWalker 对象。接收类似的参数。</p>
<p>不同的是，filter 除了可以返回原本的两种值，还可以返回 NodeFilter.FILTER_REJECT。</p>
<p>在这个对象中，NodeFilter.FILTER_SKIP 表示跳过节点，访问子树的下一个节点，而 NodeFilter.FILTER_REJECT 表示跳过该节点以及该节点的整个子树。</p>
<p>TreeWalker 类型也有一个名为 currentNode 的属性，表示遍历过程中上一次返回的节点。</p>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>DOM2 Traversal and Range 模块定义了范围接口。</p>
<h5 id="DOM-范围"><a href="#DOM-范围" class="headerlink" title="DOM 范围"></a>DOM 范围</h5><p>使用 document.createRange() 方法创建 DOM 范围对象。新建的范围对象与创建它的文档关联的，不能在其他文档中使用。</p>
<p>每个范围都是 Range 类型的实例，拥有相应的属性和方法。</p>
<ul>
<li>startContainer，范围起点所在的节点 ( 选区中第一个子节点的父节点 )</li>
<li>startOffset，范围起点在 startContainer 中的偏移量。</li>
<li>endContainer，范围终点所在的节点 ( 选区中最后一个子节点的父节点 )</li>
<li>endOffset，范围起点在 startContainer 中的偏移量。</li>
<li>commonAncestorContainer，文档中以 startContainer 和 endContainer 为后代的最深的节点。</li>
</ul>
<p>这些属性会在范围被放到文档中特定位置时获得相应的值。</p>
<h5 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h5><p>使用 selectNode() 或 selectNodeContents() 方法范围选择文档中某个部分。接收一个节点作为参数。selectNode() 方法选择整个节点，包括其后代节点，而 selectNodeContents() 只选择节点的后代。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">  range2 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">  p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">range1.selectNode(p1);</span><br><span class="line">range2.selectNodeContents(p1);</span><br><span class="line"><span class="built_in">console</span>.log(range1);</span><br><span class="line"><span class="built_in">console</span>.log(range2);</span><br><span class="line"><span class="comment">// Range: &#123;</span></span><br><span class="line"><span class="comment">//   collapsed: false</span></span><br><span class="line"><span class="comment">//   commonAncestorContainer: body</span></span><br><span class="line"><span class="comment">//   endContainer: body</span></span><br><span class="line"><span class="comment">//   endOffset: 2</span></span><br><span class="line"><span class="comment">//   startContainer: body</span></span><br><span class="line"><span class="comment">//   startOffset: 1</span></span><br><span class="line"><span class="comment">//   __proto__: Range</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Range: &#123;</span></span><br><span class="line"><span class="comment">//   collapsed: false</span></span><br><span class="line"><span class="comment">//   commonAncestorContainer: p#p1</span></span><br><span class="line"><span class="comment">//   endContainer: p#p1</span></span><br><span class="line"><span class="comment">//   endOffset: 2</span></span><br><span class="line"><span class="comment">//   startContainer: p#p1</span></span><br><span class="line"><span class="comment">//   startOffset: 0</span></span><br><span class="line"><span class="comment">//   __proto__: Range</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>还可以在范围上调用方法：</p>
<ul>
<li><p>setStartBefore(<em>refNode</em>)，把范围的起点设置到 <em>refNode</em> 之前，从而让 <em>refNode</em> 成为选</p>
<p>区的第一个子节点。startContainer 属性被设置为 refNode.parentNode，而 startOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引。</p>
</li>
<li><p>setStartAfter(<em>refNode</em>)，把范围的起点设置到 <em>refNode</em> 之后，从而将 <em>refNode</em> 排除在选</p>
<p>区之外，让其下一个同胞节点成为选区的第一个子节点。startContainer 属性被设置为</p>
<p>refNode.parentNode，startOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合</p>
<p>中的索引加 1。</p>
</li>
<li><p>setEndBefore(<em>refNode</em>)，把范围的终点设置到 <em>refNode</em> 之前，从而将 <em>refNode</em> 排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。endContainer 属性被设置为 refNode. parentNode，endOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引。</p>
</li>
<li><p>setEndAfter(<em>refNode</em>)，把范围的终点设置到 <em>refNode</em> 之后，从而让 <em>refNode</em> 成为选区的</p>
<p>最后一个子节点。endContainer 属性被设置为 refNode.parentNode，endOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引加 1。</p>
</li>
</ul>
<h5 id="复杂选择"><a href="#复杂选择" class="headerlink" title="复杂选择"></a>复杂选择</h5><p>使用 setStart() 和 setEnd() 方法，接收两个参数：参照节点和偏移量。对 setStart() 来说，参照节点会成为 startContainer，而偏移量会赋值给 startOffset。 对 setEnd() 而言，参照节点会成为 endContainer，而偏移量会赋值给 endOffset。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>函数会选择最新的内容码？</p>
<p>函数 sayHi 使用外部变量。当函数运行时，将使用哪个值？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"John"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hi, "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name = <span class="string">"Pete"</span>;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// 会显示什么："John" 还是 "Pete"？</span></span><br></pre></td></tr></table></figure>

<p>这种情况在浏览器和服务器端开发中都很常见。一个函数可能被计划在创建之后一段时间后才执行，例如在用户行为或网络请求之后。</p>
<p>因此，问题是：它会接收最新的修改吗？</p>
<p>会。</p>
</li>
<li><p>哪些变量可用呢？</p>
<p>下面的 <code>makeWorker</code> 函数创建了另一个函数并返回该函数。可以在其他地方调用这个新函数。</p>
<p>它是否可以从它被创建的位置或调用位置（或两者）访问外部变量？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeWorker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Pete"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"John"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a function</span></span><br><span class="line"><span class="keyword">let</span> work = makeWorker();</span><br><span class="line"></span><br><span class="line"><span class="comment">// call it</span></span><br><span class="line">work(); <span class="comment">// 会显示什么？</span></span><br></pre></td></tr></table></figure>

<p>会显示哪个值？“Pete” 还是 “John”？</p>
<p>“Pete”。</p>
</li>
<li><p>Counter 是独立的吗？</p>
<p>在这儿我们用相同的 <code>makeCounter</code> 函数创建了两个计数器（counters）：<code>counter</code> 和 <code>counter2</code>。</p>
<p>它们是独立的吗？第二个 counter 会显示什么？<code>0,1</code> 或 <code>2,3</code> 还是其他？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line"><span class="keyword">let</span> counter2 = makeCounter();</span><br><span class="line"></span><br><span class="line">alert( counter() ); <span class="comment">// 0</span></span><br><span class="line">alert( counter() ); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">alert( counter2() ); <span class="comment">// ?</span></span><br><span class="line">alert( counter2() ); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>独立的，第二个会显示 0 1 。</p>
</li>
<li><p>Counter 对象</p>
<p>这里通过构造函数创建了一个 counter 对象。</p>
<p>它能正常工作吗？它会显示什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.up = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.down = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> --count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">alert( counter.up() ); <span class="comment">// ?</span></span><br><span class="line">alert( counter.up() ); <span class="comment">// ?</span></span><br><span class="line">alert( counter.down() ); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>能。1 2 1。</p>
</li>
<li><p>if 内的函数</p>
<p>看看下面这个代码。最后一行代码的执行结果是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> phrase = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="string">"John"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;phrase&#125;</span>, <span class="subst">$&#123;user&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>

<p>报错。</p>
</li>
<li><p>闭包 sum</p>
<p>编写一个像 <code>sum(a)(b) = a+b</code> 这样工作的 <code>sum</code> 函数。</p>
<p>是的，就是这种通过双括号的方式（并不是错误）。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line">sum(<span class="number">5</span>)(<span class="number">-1</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量可见吗</p>
<p>下面这段代码的结果会是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>P.S. 这个任务有一个陷阱。解决方案并不明显。</p>
<p>报错。因为函数内部包含 x 。虽然还未定义，但已经不会去外部寻找 x 。</p>
</li>
<li><p>通过函数筛选</p>
<p>我们有一个内建的数组方法 <code>arr.filter(f)</code>。它通过函数 <code>f</code> 过滤元素。如果它返回 <code>true</code>，那么该元素会被返回到结果数组中。</p>
<p>制造一系列“即用型”过滤器：</p>
<ul>
<li><code>inBetween(a, b)</code> —— 在 <code>a</code> 和 <code>b</code> 之间或与它们相等（包括）。</li>
<li><code>inArray([...])</code> —— 包含在给定的数组中。</li>
</ul>
<p>用法如下所示：</p>
<ul>
<li><code>arr.filter(inBetween(3,6))</code> —— 只挑选范围在 3 到 6 的值。</li>
<li><code>arr.filter(inArray([1,2,3]))</code> —— 只挑选与 <code>[1,2,3]</code> 中的元素匹配的元素。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* .. inBetween 和 inArray 的代码 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">alert( arr.filter(inBetween(<span class="number">3</span>, <span class="number">6</span>)) ); <span class="comment">// 3,4,5,6</span></span><br><span class="line"></span><br><span class="line">alert( arr.filter(inArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>])) ); <span class="comment">// 1,2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inBetween</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt;= a &amp;&amp; item &lt;= b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) !== <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按字段排序</p>
<p>我们有一组要排序的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">surname</span>: <span class="string">"Johnson"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Pete"</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">surname</span>: <span class="string">"Peterson"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ann"</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">surname</span>: <span class="string">"Hathaway"</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>通常的做法应该是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 name (Ann, John, Pete)</span></span><br><span class="line">users.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.name &gt; b.name ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 age (Pete, Ann, John)</span></span><br><span class="line">users.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.age &gt; b.age ? <span class="number">1</span> : <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以让它更加简洁吗，比如这样？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">users.sort(byField(<span class="string">'name'</span>));</span><br><span class="line">users.sort(byField(<span class="string">'age'</span>));</span><br></pre></td></tr></table></figure>

<p>这样我们就只需要写 <code>byField(fieldName)</code>，而不是写一个函数。</p>
<p>编写函数 <code>byField</code> 来实现这个需求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byField</span>(<span class="params">fieldName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> (a[fieldName] &gt; b[fieldName] ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数大军</p>
<p>下列的代码创建了一个 <code>shooters</code> 数组。</p>
<p>每个函数都应该输出其编号。但好像出了点问题……</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArmy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shooters = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shooter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 创建一个 shooter 函数，</span></span><br><span class="line">      alert( i ); <span class="comment">// 应该显示其编号</span></span><br><span class="line">    &#125;;</span><br><span class="line">    shooters.push(shooter); <span class="comment">// 将此 shooter 函数添加到数组中</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……返回 shooters 数组</span></span><br><span class="line">  <span class="keyword">return</span> shooters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> army = makeArmy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……所有的 shooter 显示的都是 10，而不是它们的编号 0, 1, 2, 3...</span></span><br><span class="line">army[<span class="number">0</span>](); <span class="comment">// 编号为 0 的 shooter 显示的是 10</span></span><br><span class="line">army[<span class="number">1</span>](); <span class="comment">// 编号为 1 的 shooter 显示的是 10</span></span><br><span class="line">army[<span class="number">2</span>](); <span class="comment">// 10，其他的也是这样。</span></span><br></pre></td></tr></table></figure>

<p>为什么所有的 shooter 显示的都是同样的值？</p>
<p>修改代码以使得代码能够按照我们预期的那样工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArmy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shooters = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    <span class="keyword">let</span> shooter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个 shooter 函数，</span></span><br><span class="line">      <span class="built_in">console</span>.log(j); <span class="comment">// 应该显示其编号</span></span><br><span class="line">    &#125;;</span><br><span class="line">    shooters.push(shooter); <span class="comment">// 将此 shooter 函数添加到数组中</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ……返回 shooters 数组</span></span><br><span class="line">  <span class="keyword">return</span> shooters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 13</title>
    <url>/2020/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-13/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-13"><a href="#学习笔记-2020-11-13" class="headerlink" title="学习笔记 2020-11-13"></a>学习笔记 2020-11-13</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h3><h4 id="DOM-的演进"><a href="#DOM-的演进" class="headerlink" title="DOM 的演进"></a>DOM 的演进</h4><h5 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h5><ol>
<li><p>Node 的变化</p>
<p>DOM3 新增了两个用于比较节点的方法：</p>
<ul>
<li>isSameNode()</li>
<li>isEqualNode()</li>
</ul>
<p>这两个方法都接收一个节点参数。如果这个节点与参考节点相同或相等，则返回 true。节点相同，意味着引用同一个对象。节点相等，意味着节点类型相同，拥有相等的属性。</p>
<p>DOM3 也增加了给 DOM 节点附加额外数据的方法。</p>
<ul>
<li>setUserData()，接收 3 个参数：键、值、处理函数，用于给节点追加数据。</li>
<li>getUserData()，获取追加的信息。</li>
</ul>
<p>setUserData() 的处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行。处理函数接收 5 个参数：表示操作类型的数值、数据的键、数据的值、源节点和目标节点。</p>
</li>
<li><p>内嵌窗格的变化</p>
<p>DOM2 HTML 给 HTMLFrameElement 类型新增了一个属性，叫 contentDocument。这个属性包含代表子内嵌窗格中内容的 document 对象的指针。</p>
<p>contentDocument 属性是 Document 的实例，拥有所有文档属性和方法。还有一个属性 contentWindow，返回相应窗格的 window 对象。</p>
<p>跨域访问会抛出错误。</p>
</li>
</ol>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="存取元素样式"><a href="#存取元素样式" class="headerlink" title="存取元素样式"></a>存取元素样式</h5><p>任何支持 style 属性的 HTML 元素在 JS 中都会有一个对应的 style 属性。这个 style 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。</p>
<p>float 属性是 js 中的保留字，不能用作属性名，应写作 <code>cssFloat</code> 。</p>
<p>通过 style 属性设置的值也可以通过 style 对象获取。</p>
<ol>
<li><p>DOM 样式属性和方法</p>
<p>DOM2 Style 规范也在 style 对象上定义了一些属性和方法。</p>
<ul>
<li>cssText，包含 style 属性中的 CSS 代码。</li>
<li>length，应用给元素的 CSS 属性数量。</li>
<li>parentRule，表示 CSS 信息的 CSSRule 对象。</li>
<li>getPropertyCSSValue(propertyName)，返回包含 CSS 属性 propertyName 值的 CSSValue 对象，已废弃。</li>
<li>getPropertyPriority(<em>propertyName</em>)，如果 CSS 属性 <em>propertyName</em> 使用了 !important，则返回”important”，否则返回空字符串。</li>
<li>getPropertyValue(<em>propertyName</em>)，返回属性 <em>propertyName</em> 的字符串值。</li>
<li>item(<em>index</em>)，返回索引为 <em>index</em> 的 CSS 属性名。</li>
<li>removeProperty(<em>propertyName</em>)，从样式中删除 CSS 属性 <em>propertyName</em>。 </li>
<li>setProperty(<em>propertyName, value, priority</em>)，设置 CSS 属性 <em>propertyName</em> 的值为value，priority 是 “important” 或空字符串。</li>
</ul>
</li>
<li><p>计算样式</p>
<p>DOM2 Style 在 document.defaultView 上增加了 getComputedStyle() 方法。接收 2 个参数，要取得计算样式的元素和伪元素字符串。可以取得该元素的正确样式，包括样式表。在所有浏览器中计算样式都是只读的，还包含了浏览器内部样式表中的信息。</p>
</li>
</ol>
<h5 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h5><p>CSSStyleSheet 类型表示 CSS 样式表，包括使用 <code>&lt;link&gt;</code> 元素和通过 <code>&lt;style&gt;</code> 元素定义的样式表。这两个元素本身是 HTMLLinkElement 和 HTMLStyleElement 。</p>
<p>CSSStyleSheet 类型继承 StyleSheet ，后者可用作非 CSS 样式表的基类。以下是 CSSStyleSheet 从 StyleSheet 继承的属性。</p>
<ul>
<li>disabled ，表示样式表是否被禁用。</li>
<li>href，如果是使用 <code>&lt;link&gt;</code> 包含的样式表，则返回样式表的 URL，否则返回 null。</li>
<li>media，样式表支持的媒体类型集合，这个集合有一个 length 属性和一个 item() 方法。</li>
<li>ownerNode，拥有指向当前样式表的节点。如果样式表是通过 @import 被包含在另一个样式表中，这个属性值是 null 。</li>
<li>parentStyleSheet，如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性指向导入它的样式表。</li>
<li>title，ownerNode 的 title 属性。</li>
<li>type，字符串，表示样式表的类型。对 CSS 样式表来说，就是”text/css”。</li>
</ul>
<p>以上除了 disabled 其余为只读属性。除了以上继承的属性，CSSStyleSheet 类型还支持以下属性和方法。</p>
<ul>
<li>cssRules，当前样式表包含的样式规则的集合。</li>
<li>ownerRule，如果样式表是使用@import 导入的，则指向导入规则；否则为 null。 </li>
<li>deleteRule(<em>index</em>)，在指定位置删除 cssRules 中的规则。</li>
<li>insertRule(<em>rule</em>, <em>index</em>)，在指定位置向 cssRules 中插入规则。</li>
</ul>
<p>document.styleSheets 表示文档中可用的样式表哦集合。这个集合的 length 属性保存着文档中样式表的数量。</p>
<p>通过 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 元素也可以直接获取 CSSStyleSheet 对象。DOM 在这两个元素上暴露了 sheet 属性，其中包含对应的 CSSStyleSheet 对象。</p>
<ol>
<li><p>CSS 规则</p>
<p>CSSRule 类型表示样式表中的一条规则。它也是一个通用基类，很多类型都继承它。最常用的是表示样式信息的 CSSStyleRule ，以下是 CSSStyleRule 对象上可用的属性。</p>
<ul>
<li>cssText，返回整条规则的文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。</li>
<li>parentRule，如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是 null。 </li>
<li>parentStyleSheet，包含当前规则的样式表。</li>
<li>selectorText，返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在 Firefox、Safari、Chrome 和 IE 中是只读的，在 Opera 中是可以修改的。</li>
<li>style，返回 CSSStyleDeclaration 对象，可以设置和获取当前规则中的样式。</li>
<li>type，数值常量，表示规则类型。对于样式规则，它始终为 1。</li>
</ul>
</li>
<li><p>创建规则</p>
<p>可以使用 insertRule() 方法向样式表中添加新规则。接收两个参数，规则的文本和表示插入位置的索引值。</p>
</li>
<li><p>删除规则</p>
<p>可以使用 deleteRule() 方法删除规则，接收一个参数，要删除规则的索引。</p>
</li>
</ol>
<h5 id="元素尺寸"><a href="#元素尺寸" class="headerlink" title="元素尺寸"></a>元素尺寸</h5><p>以下介绍的属性和方法不是 DOM2 style 规范中定义的。</p>
<ol>
<li><p>偏移尺寸</p>
<p>元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框。以下 4 个属性用于取得元素的偏移尺寸：</p>
<ul>
<li>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度和上、下边框的高度。</li>
<li>offsetLeft，元素左边框外侧距离包含元素左边框内测的像素数。</li>
<li>offsetTop，元素上边框外侧距离包括元素上边框内测的像素数。</li>
<li>offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度和左、右边框的宽度。</li>
</ul>
<p>offsetLeft 和 offsetTop 是相对于包含元素的，包含元素保存在 offsetParent 属性中。</p>
<p><img src="/2020/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-13/image-20201113171012849.png" alt="image-20201113171012849"></p>
<p>要确定一个元素在页面中的偏移量，可以把它的 offsetLeft 和 offsetTop 属性分别与 offsetParent 的相同属性相加，一直加到根元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> actualLeft = element.offsetLeft;</span><br><span class="line">  <span class="keyword">let</span> current = element.offsetParent;</span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualLeft += current.offsetLeft;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> actualTop = element.offsetTop;</span><br><span class="line">  <span class="keyword">let</span> current = element.offsetParent;</span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualTop += current.offsetTop;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> actualTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有偏移尺寸属性都是只读的，每次访问都会重新计算。</p>
</li>
<li><p>客户端尺寸</p>
<p>元素的客户端尺寸包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性： clientWidth 和 clientHeight 。clientWdith 是内容区宽度加左、右内边距宽度。clientHeight 是内容区高度加上、下内边距高度。</p>
<p><img src="/2020/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-13/image-20201113171423440.png" alt="image-20201113171423440"></p>
<p>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性也是只读的，每次访问都会重新计算。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 12</title>
    <url>/2020/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-12/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-12"><a href="#学习笔记-2020-11-12" class="headerlink" title="学习笔记 2020-11-12"></a>学习笔记 2020-11-12</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h3><h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><h5 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h5><ol>
<li><p>内存与性能问题</p>
<p>如果被移除的子树元素中之前有关联的事件处理程序或其他 JavaScript 对象。那它们之间的绑定关系会滞留在内存中。在使用 innerHTML 、outerHTML 和 insertAdjacentHTML() 之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。</p>
<p>HTML 解析器会解析设置给 innerHTML 的值，解析器在浏览器中是底层代码，比 JavaScript 快得多。</p>
</li>
<li><p>跨站点脚本</p>
<p>innerHTML 不会执行自己创建的 <code>&lt;script&gt;</code> 标签，但仍然向恶意用户暴露了很大的攻击面。可以通过它创建元素并执行 onclick 之类的属性。</p>
</li>
</ol>
<h5 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView()"></a>scrollIntoView()</h5><p>scrollIntoView() 方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。方法参数如下：</p>
<ul>
<li>alignToTop ，布尔值。<ul>
<li>true 表示窗口滚动后元素顶部与视口顶部对齐。</li>
<li>false 表示窗口滚动后元素底部与视口底部对齐。</li>
</ul>
</li>
<li>scrollIntoViewOptions，可选对象。<ul>
<li>behavior，定义过渡动画，可取的值为 smooth 和 auto，默认为 auto 。</li>
<li>block，定义垂直方向的对齐，可取的值为 start、center、end 和 nearest，默认为 start。</li>
<li>inline，定义水平方向的对齐，可取的值为 start、center、end 和 nearest，默认为 nearest。</li>
</ul>
</li>
<li>不传参数等同于第一个参数为 true。</li>
</ul>
<h4 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h4><h5 id="children-属性"><a href="#children-属性" class="headerlink" title="children 属性"></a>children 属性</h5><p>IE9 之前的版本与其他浏览器在处理空白文本节点上的差异导致了 children 属性的出现。children 属性是一个 HTMLCollection ，只包含元素的 Element 类型的子节点。</p>
<h5 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains() 方法"></a>contains() 方法</h5><p>IE 首先引入了 contains() 方法，在要搜索的祖先元素上调用，参数是待确定的目标节点。</p>
<p>使用 DOM Level 3 的 compareDocumentPosition() 方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。</p>
<table>
<thead>
<tr>
<th>掩 码</th>
<th>节点关系</th>
</tr>
</thead>
<tbody><tr>
<td>0x1</td>
<td>断开（传入的节点不在文档中）</td>
</tr>
<tr>
<td>0x2</td>
<td>领先（传入的节点在 DOM 树中位于参考节点之前）</td>
</tr>
<tr>
<td>0x4</td>
<td>随后（传入的节点在 DOM 树中位于参考节点之后）</td>
</tr>
<tr>
<td>0x8</td>
<td>包含（传入的节点是参考节点的祖先）</td>
</tr>
<tr>
<td>0x10</td>
<td>被包含（传入的节点是参考节点的后代）</td>
</tr>
</tbody></table>
<h5 id="插入标记-1"><a href="#插入标记-1" class="headerlink" title="插入标记"></a>插入标记</h5><ol>
<li><p>innerText</p>
<p>该属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，innerText 会移除元素的所有后代并插入一个包含该值的文本节点。</p>
</li>
<li><p>outerText</p>
<p>类似于 innerText，只不过作用范围包含调用它的节点。在读取值时，两者表现相似。在写入值时，outerText 不止会移除所有后代节点，还会替换整个元素。</p>
</li>
</ol>
<h3 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h3><p>DOM1 主要定义了 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 在这些结构之上加入更多交互能力，提供了更高级的 XML 特性。</p>
<ul>
<li>DOM Core:：在 DOM1 核心部分的基础上，为节点增加方法和属性。</li>
<li>DOM Views：定义基于样式信息的不同试图。</li>
<li>DOM Events：定义通过事件实现 DOM 文档交互。</li>
<li>DOM Style：定义以编程方式访问和修改 CSS 样式的接口。</li>
<li>DOM Traversal and Range：新增遍历 DOM 文档及选择文档内容的接口。</li>
<li>DOM HTML：在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。</li>
<li>DOM Mutation Observers：定义基于 DOM 变化触发回调的接口。这个模块是 DOM4 级模块，用于取代 Mutation Events。</li>
</ul>
<h4 id="DOM-的演进"><a href="#DOM-的演进" class="headerlink" title="DOM 的演进"></a>DOM 的演进</h4><p>DOM2 和 DOM3 Core 模块的目标是扩展 DOM API，满足 XML 的所有需求并提供更好的错误处理和特性检测。</p>
<h5 id="XML-命名空间"><a href="#XML-命名空间" class="headerlink" title="XML 命名空间"></a>XML 命名空间</h5><h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="递归和堆栈"><a href="#递归和堆栈" class="headerlink" title="递归和堆栈"></a>递归和堆栈</h3><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol>
<li><p>对数字求和到给定值</p>
<p>编写一个函数 <code>sumTo(n)</code> 计算 <code>1 + 2 + ... + n</code> 的和。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sumTo(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">sumTo(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">sumTo(<span class="number">3</span>) = <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">sumTo(<span class="number">4</span>) = <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">10</span></span><br><span class="line">...</span><br><span class="line">sumTo(<span class="number">100</span>) = <span class="number">100</span> + <span class="number">99</span> + ... + <span class="number">2</span> + <span class="number">1</span> = <span class="number">5050</span></span><br></pre></td></tr></table></figure>

<p>用三种方式实现：</p>
<ol>
<li>使用循环。</li>
<li>使用递归，对 <code>n &gt; 1</code> 执行 <code>sumTo(n) = n + sumTo(n-1)</code>。</li>
<li>使用 <a href="https://en.wikipedia.org/wiki/Arithmetic_progression" target="_blank" rel="noopener">等差数列</a> 求和公式.</li>
</ol>
<p>结果示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTo</span>(<span class="params">n</span>) </span>&#123; <span class="comment">/*... 你的代码 ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">alert( sumTo(<span class="number">100</span>) ); <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>

<p>P.S. 哪种解决方式最快？哪种最慢？为什么？</p>
<p>P.P.S. 我们可以使用递归来计算 <code>sumTo(100000)</code> 吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    sum += n;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> n + sumTo(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((n + <span class="number">1</span>) * n) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算阶乘</p>
<p>自然数的 <a href="https://en.wikipedia.org/wiki/Factorial" target="_blank" rel="noopener">阶乘</a> 是指，一个数乘以 <code>数字减去 1</code>，然后乘以 <code>数字减去 2</code>，以此类推直到乘以 <code>1</code>。<code>n</code> 的阶乘被记作 <code>n!</code>。</p>
<p>我们可以将阶乘的定义写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">n! = n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * ...*<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>不同 <code>n</code> 的阶乘的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>! = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>! = <span class="number">2</span> * <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="number">3</span>! = <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> = <span class="number">6</span></span><br><span class="line"><span class="number">4</span>! = <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> = <span class="number">24</span></span><br><span class="line"><span class="number">5</span>! = <span class="number">5</span> * <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> = <span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>任务是编写一个函数 <code>factorial(n)</code> 使用递归调用计算 <code>n!</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( factorial(<span class="number">5</span>) ); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>P.S. 提示：<code>n!</code> 可以被写成 <code>n * (n-1)!</code>，比如 <code>3! = 3*2! = 3*2*1! = 6</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>斐波那契数</p>
<p><a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数</a> 序列有这样的公式： <code>Fn = Fn-1 + Fn-2</code>。换句话说，下一个数字是前两个数字的和。</p>
<p>前两个数字是 <code>1</code>，然后是 <code>2(1+1)</code>，然后 <code>3(1+2)</code>，<code>5(2+3)</code> 等：<code>1, 1, 2, 3, 5, 8, 13, 21...</code>。</p>
<p>斐波那契数与 <a href="https://en.wikipedia.org/wiki/Golden_ratio" target="_blank" rel="noopener">黄金比例</a> 以及我们周围的许多自然现象有关。</p>
<p>编写一个函数 <code>fib(n)</code> 返回第 <code>n</code> 个斐波那契数。</p>
<p>工作示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123; <span class="comment">/* 你的代码 */</span> &#125;</span><br><span class="line"></span><br><span class="line">alert(fib(<span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line">alert(fib(<span class="number">7</span>)); <span class="comment">// 13</span></span><br><span class="line">alert(fib(<span class="number">77</span>)); <span class="comment">// 5527939700884757</span></span><br></pre></td></tr></table></figure>

<p>P.S. 函数运行速度要快，对 <code>fib(77)</code> 的调用不应该超过几分之一秒。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考解法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> c = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出一个单链表</p>
<p>假设我们有一个单链表（在 <a href="https://zh.javascript.info/recursion" target="_blank" rel="noopener">递归和堆栈</a> 那章有讲过）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  next: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    next: &#123;</span><br><span class="line">      value: <span class="number">3</span>,</span><br><span class="line">      next: &#123;</span><br><span class="line">        value: <span class="number">4</span>,</span><br><span class="line">        next: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编写一个可以逐个输出链表元素的函数 <code>printList(list)</code>。</p>
<p>使用两种方式实现：循环和递归。</p>
<p>哪个更好：用递归还是不用递归的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printList</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = list;</span><br><span class="line">  <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp.value);</span><br><span class="line">    tmp = tmp.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printList</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(list.value);</span><br><span class="line">    printList(list.next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向输出单链表</p>
<p>反向输出前一个任务 <a href="https://zh.javascript.info/task/output-single-linked-list" target="_blank" rel="noopener">输出一个单链表</a> 中的单链表。</p>
<p>使用两种解法：循环和递归。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printList</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list) &#123;</span><br><span class="line">    printList(list.next);</span><br><span class="line">    <span class="built_in">console</span>.log(list.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printList</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = list;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">    arr.push(tmp.value);</span><br><span class="line">    tmp = tmp.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 11</title>
    <url>/2020/11/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-11/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-11"><a href="#学习笔记-2020-11-11" class="headerlink" title="学习笔记 2020-11-11"></a>学习笔记 2020-11-11</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM-拓展"><a href="#DOM-拓展" class="headerlink" title="DOM 拓展"></a>DOM 拓展</h3><h4 id="Selectors-API"><a href="#Selectors-API" class="headerlink" title="Selectors API"></a>Selectors API</h4><p>Selectors API 是 W3C 推荐标准，规定了浏览器原生支持的 CSS 查询API 。</p>
<p>核心是两个方法，querySelector() 和 querySelectorAll() 。在兼容浏览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。</p>
<ol>
<li><p>querySelector()</p>
<p>该方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素或 null 。</p>
</li>
<li><p>querySelectorAll()</p>
<p>该方法也接收一个用于查询的参数，但它会返回所有匹配的节点。该方法返回一个 NodeList 的静态实例。</p>
</li>
<li><p>matches()</p>
<p>该方法接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true ，否则返回 false 。</p>
</li>
</ol>
<h4 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h4><p>IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器会。这样导致了 childNodes 和 firstChild 等属性上的差异。为了弥补这个差异，同时不影响 DOM 规范， W3C 通过新的 Element Traversal 规范定义了一组新属性。</p>
<ul>
<li>childElementCount，返回子元素数量 ( 不包含文本节点和注释 )；</li>
<li>firstElementChild，指向第一个 Element 类型的子元素；</li>
<li>lastElementChild；</li>
<li>previousElementSibling，指向前一个 Element 类型的同胞元素；</li>
<li>nextElementSibling；</li>
</ul>
<h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p>HTML5 规范包含了与标记相关的大量 JavaScript API 定义。</p>
<h5 id="CSS-类拓展"><a href="#CSS-类拓展" class="headerlink" title="CSS 类拓展"></a>CSS 类拓展</h5><ol>
<li><p>getElementsByClassName()</p>
<p>该方法暴露在 document 对象和所有 HTML 元素上。返回包含相应类的元素的 NodeList 。</p>
<p>IE9 及以上版本，以及所有现代浏览器都支持该方法。</p>
</li>
<li><p>classList 属性</p>
<p>可以通过 className 属性操作类名，但该属性是一个字符串。</p>
<p>classList 是一个新的集合类型 DOMTokenList 的实例。该类型也有 length 属性表示自己包含多少项，可以通过 item() 或中括号取得个别的元素。还有一些方法：</p>
<ul>
<li>add(value)；</li>
<li>contains(value)，返回布尔值，表示给定的 value 是否存在；</li>
<li>remove(value)；</li>
<li>toggle(value)，若已存在则删除，不存在则添加。</li>
</ul>
<p>IE10 及以上版本和其他主流浏览器实现了该属性。</p>
</li>
</ol>
<h5 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h5><p>HTML5 添加了辅助 DOM 焦点管理的功能。</p>
<ol>
<li><p>document.activeElement</p>
<p>始终包含当前拥有焦点的 DOM 元素。</p>
<p>默认情况下，该属性会在页面刚加载完之后设置为 document.body 。在那之前，值为 null 。</p>
</li>
<li><p>document.hasFocus()</p>
<p>返回布尔值，表示文档是否拥有焦点。</p>
</li>
</ol>
<h5 id="HTMLDocument-拓展"><a href="#HTMLDocument-拓展" class="headerlink" title="HTMLDocument 拓展"></a>HTMLDocument 拓展</h5><ol>
<li><p>readyState</p>
<p>该属性最早是 IE4 添加到 document 对象上。HTML5将这个属性写入了标准。该属性有两个值：</p>
<ul>
<li>loading，表示文档正在加载；</li>
<li>complete，表示文档加载完成。</li>
</ul>
</li>
<li><p>compatMode 属性</p>
<p>自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。这个属性指示浏览器当前处于什么渲染模式下。</p>
<p>标准模式下，这个属性的值是 “CSS1Compat”，而在混杂模式下，值是 “BackCompat”。</p>
</li>
<li><p>head 属性</p>
<p>该属性指向文档的 <code>&lt;head&gt;</code> 属性。</p>
</li>
</ol>
<h5 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h5><p>characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集。</p>
<h5 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h5><p>浏览器允许给元素指定非标准的属性，最好以前缀 data- 来指定。</p>
<p>自定义属性可以通过元素的 dataset 属性来访问。dataset 属性是一个 DOMStringMap 的实例，包含一组键/值对映射。元素的每个 data-name 属性在 dataset 中都可以通过 data- 后面的字符串作为键来访问。</p>
<h5 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h5><ol>
<li><p>innerHTML</p>
<p>在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。在写入时，会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有子节点。</p>
</li>
<li><p>旧 IE中的 innerHTML</p>
<p>在所有现代浏览器中，通过 innerHTML 插入的 <code>&lt;script&gt;</code> 标签是不会执行的。而在 IE8 及之前的版本中，只要这样插入的 <code>&lt;script&gt;</code> 元素指定了 defer 属性，且 <code>&lt;script&gt;</code> 之前是 受控元素，那就是可以执行的。<code>&lt;script&gt;</code> 元素与 <code>&lt;style&gt;</code> 或注释一样，都是非受控元素，也就是在页面上看不到它们。IE 会把 innerHTML 中从非受控元素开始的内容都删掉。</p>
</li>
<li><p>outerHTML 属性</p>
<p>读取 outerHTML 属性时，会返回调用它的元素及所有后代元素的 HTML 字符串。在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。</p>
</li>
<li><p>insertAdjacentHTML() 与 insertAdjacentText()</p>
<p>这两个方法最早源自 IE ，接收两个参数，要插入标记的位置和要插入的 HTML 或文本。</p>
<p>第一个参数必须是下列值的一个：</p>
<ul>
<li>beforebegin，插入当前元素前面，作为前一个同胞节点；</li>
<li>afterbegin，插入当前元素内部，作为新的子节点或放在第一个子节点后面；</li>
<li>beforeend，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li>
<li>afterend，插入当前元素后面；</li>
</ul>
<p>以上值不区分大小写。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="JSON方法，toJSON"><a href="#JSON方法，toJSON" class="headerlink" title="JSON方法，toJSON"></a>JSON方法，toJSON</h3><h4 id="排除和转换：replacer"><a href="#排除和转换：replacer" class="headerlink" title="排除和转换：replacer"></a>排除和转换：replacer</h4><p>JSON.stringify 的完整语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="built_in">JSON</span>.stringify(value, replacer?, space?);</span><br></pre></td></tr></table></figure>

<ul>
<li>value，要编码的值。</li>
<li>replacer，要编码的属性数组或映射函数 <code>function(key, value)</code> 。</li>
<li>space，用于格式化的空格数量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">'Conference'</span>,</span><br><span class="line">  participants: [&#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;],</span><br><span class="line">  place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(meetup, [<span class="string">'title'</span>, <span class="string">'participants'</span>]));</span><br><span class="line"><span class="comment">// &#123;"title":"Conference","participants":[&#123;&#125;,&#123;&#125;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">'Conference'</span>,</span><br><span class="line">  participants: [&#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;],</span><br><span class="line">  place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> key == <span class="string">'occupiedBy'</span> ? <span class="literal">undefined</span> : value;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* key:value pairs that come to replacer:</span></span><br><span class="line"><span class="comment">:             [object Object]</span></span><br><span class="line"><span class="comment">title:        Conference</span></span><br><span class="line"><span class="comment">participants: [object Object],[object Object]</span></span><br><span class="line"><span class="comment">0:            [object Object]</span></span><br><span class="line"><span class="comment">name:         John</span></span><br><span class="line"><span class="comment">1:            [object Object]</span></span><br><span class="line"><span class="comment">name:         Alice</span></span><br><span class="line"><span class="comment">place:        [object Object]</span></span><br><span class="line"><span class="comment">number:       23</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="格式化：space"><a href="#格式化：space" class="headerlink" title="格式化：space"></a>格式化：space</h4><p>第三个参数用于优化格式的空格数量。</p>
<h4 id="自定义-“toJSON”"><a href="#自定义-“toJSON”" class="headerlink" title="自定义 “toJSON”"></a>自定义 “toJSON”</h4><p>可以给对象自定义 toJSON 方法来自定义 JSON 转换。</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="built_in">JSON</span>.parse(str, reviver?);</span><br></pre></td></tr></table></figure>

<ul>
<li>str，要解析的 JSON 字符串。</li>
<li>reviver，可选的函数 <code>function(key, value)</code> ，该函数将为每个键值对调用。</li>
</ul>
<p>例子，JSON 对象中的日期值 parse 之后依然是一个字符串，可以提供 reviver 函数来进行转换。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol>
<li><p>将对象转换为 JSON，然后再转换回来</p>
<p>将 <code>user</code> 转换为 JSON，然后将其转换回到另一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John Smith"</span>,</span><br><span class="line">  age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(user);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">JSON</span>.parse(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>排除反向引用</p>
<p>在简单循环引用的情况下，我们可以通过名称排除序列化中违规的属性。</p>
<p>但是，有时我们不能只使用名称，因为它既可能在循环引用中也可能在常规属性中使用。因此，我们可以通过属性值来检查属性。</p>
<p>编写 <code>replacer</code> 函数，移除引用 <code>meetup</code> 的属性，并将其他所有属性序列化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">"Conference"</span>,</span><br><span class="line">  occupiedBy: [&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Alice"</span>&#125;],</span><br><span class="line">  place: room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line">room.occupiedBy = meetup;</span><br><span class="line">meetup.self = meetup;</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* your code */</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果应该是：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "title":"Conference",</span></span><br><span class="line"><span class="comment">  "occupiedBy":[&#123;"name":"John"&#125;,&#123;"name":"Alice"&#125;],</span></span><br><span class="line"><span class="comment">  "place":&#123;"number":23&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value === meetup &amp;&amp; key !== <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 10</title>
    <url>/2020/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-10/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-10"><a href="#学习笔记-2020-11-10" class="headerlink" title="学习笔记 2020-11-10"></a>学习笔记 2020-11-10</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="MutationObserver-接口"><a href="#MutationObserver-接口" class="headerlink" title="MutationObserver 接口"></a>MutationObserver 接口</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ol>
<li><p>回调与 MutationRecord</p>
<p>每个回调都会收到一个 MutationRecord 实例的数组。包含发生了什么变化，DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// [MutationRecord]:</span></span><br><span class="line"><span class="comment">//  [</span></span><br><span class="line"><span class="comment">//   0: &#123;</span></span><br><span class="line"><span class="comment">//     MutationRecord,</span></span><br><span class="line"><span class="comment">//     addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">//     attributeName: "foo",</span></span><br><span class="line"><span class="comment">//     attributeNamespace: null,</span></span><br><span class="line"><span class="comment">//     nextSibling: null,</span></span><br><span class="line"><span class="comment">//     oldValue: null,</span></span><br><span class="line"><span class="comment">//     previousSibling: null,</span></span><br><span class="line"><span class="comment">//     removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">//     target: body,</span></span><br><span class="line"><span class="comment">//     type: "attributes",</span></span><br><span class="line"><span class="comment">//     __proto__: MutationRecord,</span></span><br><span class="line"><span class="comment">//     length: 1</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   __proto__: Array(0),</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.setAttributeNS(<span class="string">'baz'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">//   &#123; </span></span><br><span class="line"><span class="comment">//     addedNodes: NodeList [], </span></span><br><span class="line"><span class="comment">//     attributeName: "foo", </span></span><br><span class="line"><span class="comment">//     attributeNamespace: "baz", </span></span><br><span class="line"><span class="comment">//     nextSibling: null, </span></span><br><span class="line"><span class="comment">//     oldValue: null, </span></span><br><span class="line"><span class="comment">//     previousSibling: null </span></span><br><span class="line"><span class="comment">//     removedNodes: NodeList [], </span></span><br><span class="line"><span class="comment">//     target: body </span></span><br><span class="line"><span class="comment">//     type: "attributes" </span></span><br><span class="line"><span class="comment">//   &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutationRecords</span> =&gt;</span> <span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'baz'</span>;</span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>MutationRecord 实例的属性如下表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>被修改影响的目标节点</td>
</tr>
<tr>
<td>type</td>
<td>字符串，表示变化的类型：”attributes”、”characterData”或”childList”</td>
</tr>
<tr>
<td>oldValue</td>
<td>如果在 MutationObserverInit 对象中启用（attributeOldValue 或 characterData OldValue 为 true），”attributes”或”characterData”的变化事件会设置这个属性为被替代的值 “childList”类型的变化始终将这个属性设置为 null。</td>
</tr>
<tr>
<td>attributeName</td>
<td>对于”attributes”类型的变化，这里保存被修改属性的名字。其他变化事件会将这个属性设置为 null</td>
</tr>
<tr>
<td>attributeNamespace</td>
<td>对于使用了命名空间的”attributes”类型的变化，这里保存被修改属性的名字。对于使用了命名空间的”attributes”类型的变化，这里保存被修改属性的名字</td>
</tr>
<tr>
<td>addedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中添加节点的 NodeList。默认为空 NodeList。</td>
</tr>
<tr>
<td>removedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中删除节点的 NodeList。默认为空 NodeList。</td>
</tr>
<tr>
<td>previousSibling</td>
<td>对于”childList”类型的变化，返回变化节点的前一个同胞 Node。默认为 null。</td>
</tr>
<tr>
<td>nextSibling</td>
<td>对于”childList”类型的变化，返回变化节点的后一个同胞 Node。默认为 null。</td>
</tr>
</tbody></table>
<p>传给回调函数的第二个参数是观察变化的 MutationObserver 的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords, mutationObserver) =&gt; <span class="built_in">console</span>.log(mutationRecords,</span><br><span class="line">mutationObserver)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'foo'</span>; </span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>disconnect() 方法</p>
<p>默认情况下，只要被观察的元素不被垃圾回收，回调就不会被终止。调用 disconnect() 方法提前终止执行回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'&lt;body&gt; attributes changed'</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'foo'</span>;</span><br><span class="line">observer.disconnect();</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">//（没有日志输出）</span></span><br></pre></td></tr></table></figure>

<p>调用后，已经加入任务队列的回调也会被抛弃。</p>
<p>如果想执行已经入列的回调，可以使用 setTimeout() 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'&lt;body&gt; attributes changed'</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'foo'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  observer.disconnect();</span><br><span class="line">  <span class="built_in">document</span>.body.className = <span class="string">'bar'</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复用 MutationObserver</p>
<p>多次调用 observe() 方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。此时， MutationRecord 的 target 属性可以标识发生变化事件的目标节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutationRecords</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(mutationRecords.map(<span class="function"><span class="params">x</span> =&gt;</span> x.target))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),</span><br><span class="line">  childB = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childA);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childB);</span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.observe(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">observer.observe(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.setAttribute(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">childB.setAttribute(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;span&gt;]</span></span><br></pre></td></tr></table></figure>

<p>此时调用 disconnect() 方法会停止观察所有目标。</p>
</li>
<li><p>重用 MutationObserver</p>
<p>调用过 disconnect() 的 MutationObserver 还可以重新使用，只需要关联到新的目标节点。</p>
</li>
</ol>
<h5 id="MutationObserverInit-与观察范围"><a href="#MutationObserverInit-与观察范围" class="headerlink" title="MutationObserverInit 与观察范围"></a>MutationObserverInit 与观察范围</h5><p>MutationObserverInit 对象用于控制对目标节点的观察范围。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>subtree</td>
<td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代）。如果是 false，则只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树。默认为 false。</td>
</tr>
<tr>
<td>attributes</td>
<td>布尔值，表示是否观察目标节点的属性变化。默认为 false</td>
</tr>
<tr>
<td>attributeFilter</td>
<td>字符串数组，表示要观察哪些属性的变化。把这个值设置为 true 也会将 attributes 的值转换为 true。默认为观察所有属性</td>
</tr>
<tr>
<td>attributeOldValue</td>
<td>布尔值，表示 MutationRecord 是否记录变化之前的属性值。把这个值设置为 true 也会将 attributes 的值转换为 true。默认为 false。</td>
</tr>
<tr>
<td>characterData</td>
<td>布尔值，表示修改字符数据是否触发变化事件。默认为 false。</td>
</tr>
<tr>
<td>characterDataOldValue</td>
<td>布尔值，表示 MutationRecord 是否记录变化之前的字符数据。把这个值设置为 true 也会将 characterData 的值转换为 true。默认为 false。</td>
</tr>
<tr>
<td>childList</td>
<td>布尔值，表示修改目标节点的子节点是否触发变化事件。默认为 false。</td>
</tr>
</tbody></table>
<p>默认情况下，观察范围限定为一个元素及其子节点的变化。设置 subtree 可以将观察范围拓展到这个元素的子树，即所有后代节点。被观察子树的节点被移出子树之后仍然能够触发变化事件。</p>
<h5 id="异步回调与记录队列"><a href="#异步回调与记录队列" class="headerlink" title="异步回调与记录队列"></a>异步回调与记录队列</h5><p>MutationObserver 接口出于性能考虑而涉及，核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息会保存在 MutationRecord 实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM 变化事件的有序列表。</p>
<ol>
<li><p>记录队列</p>
<p>每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任务回调时，才会将观察者注册的回调作为微任务调度到任务队列上。</p>
<p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个 MutationRecord 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 MutationRecord 就用不着了。因此记录队列会被清空。</p>
</li>
<li><p>takeRecords() 方法</p>
<p>调用 MutationObserver 实例的 takeRecords() 方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例。</p>
</li>
</ol>
<h5 id="性能、内存与垃圾回收"><a href="#性能、内存与垃圾回收" class="headerlink" title="性能、内存与垃圾回收"></a>性能、内存与垃圾回收</h5><p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 MutationObserver 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p>
<ol>
<li><p>MutationObserver 的引用</p>
<p>MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p>
<p>然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</p>
</li>
<li><p>MutationRecord 的引用</p>
<p>记录队列中的每个 MutationRecord 的实例至少包含对已有 DOM 节点的一个引用。如果变化是 childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord ，然后让它们超出作用域并被垃圾回收。</p>
<p>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>创建日期</p>
<p>创建一个 <code>Date</code> 对象，日期是：Feb 20, 2012, 3:12am。时区是当地时区。</p>
<p>使用 <code>alert</code> 显示结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2012-02-20 3:12'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示星期数</p>
<p>编写一个函数 <code>getWeekDay(date)</code> 以短格式来显示一个日期的星期数：‘MO’，‘TU’，‘WE’，‘TH’，‘FR’，‘SA’，‘SU’。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 3 Jan 2012</span></span><br><span class="line">alert( getWeekDay(date) );        <span class="comment">// 应该输出 "TU"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeekDay</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> day = date.getDay();</span><br><span class="line">  <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'MO'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'TU'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'WE'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'TH'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'FR'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'SA'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'SU'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>欧洲的星期表示方法</p>
<p>欧洲国家的星期计算是从星期一（数字 1）开始的，然后是星期二（数字 2），直到星期日（数字 7）。编写一个函数 <code>getLocalDay(date)</code>，并返回日期的欧洲式星期数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 3 Jan 2012</span></span><br><span class="line">alert( getLocalDay(date) );       <span class="comment">// 星期二，应该显示 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocalDay</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> day = date.getDay();</span><br><span class="line">  <span class="keyword">return</span> day === <span class="number">0</span> ? <span class="number">7</span> : day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>许多天之前是哪个月几号？</p>
<p>写一个函数 <code>getDateAgo(date, days)</code>，返回特定日期 <code>date</code> 往前 <code>days</code> 天是哪个月的哪一天。</p>
<p>例如，假设今天是 20 号，那么 <code>getDateAgo(new Date(), 1)</code> 的结果应该是 19 号，<code>getDateAgo(new Date(), 2)</code> 的结果应该是 18 号。</p>
<p>跨月、年也应该是正确输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">alert( getDateAgo(date, <span class="number">1</span>) ); <span class="comment">// 1, (1 Jan 2015)</span></span><br><span class="line">alert( getDateAgo(date, <span class="number">2</span>) ); <span class="comment">// 31, (31 Dec 2014)</span></span><br><span class="line">alert( getDateAgo(date, <span class="number">365</span>) ); <span class="comment">// 2, (2 Jan 2014)</span></span><br></pre></td></tr></table></figure>

<p>P.S. 函数不应该修改给定的 <code>date</code> 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDateAgo</span>(<span class="params">date, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = date.getTime() - num * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(result).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDateAgo</span>(<span class="params">date, days</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dateCopy = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line"></span><br><span class="line">  dateCopy.setDate(date.getDate() - days);</span><br><span class="line">  <span class="keyword">return</span> dateCopy.getDate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某月的最后一天</p>
<p>写一个函数 <code>getLastDayOfMonth(year, month)</code> 返回 month 月的最后一天。有时候是 30，有时是 31，甚至在二月的时候会是 28/29。</p>
<p>参数：</p>
<ul>
<li><code>year</code> —— 四位数的年份，比如 2012。</li>
<li><code>month</code> —— 月份，从 0 到 11。</li>
</ul>
<p>举个例子，<code>getLastDayOfMonth(2012, 1) = 29</code>（闰年，二月）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastDayOfMonth</span>(<span class="params">year, month</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(year, month + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> date.getDate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>今天过去了多少秒？</p>
<p>写一个函数 <code>getSecondsToday()</code>，返回今天已经过去了多少秒？</p>
<p>例如：如果现在是 <code>10:00 am</code>，并且没有夏令时转换，那么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getSecondsToday() == <span class="number">36000</span> <span class="comment">// (3600 * 10)</span></span><br></pre></td></tr></table></figure>

<p>该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSecondsToday</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> hour = day.getHours();</span><br><span class="line">  <span class="keyword">const</span> minute = day.getMinutes();</span><br><span class="line">  <span class="keyword">const</span> second = day.getSeconds();</span><br><span class="line">  <span class="keyword">return</span> hour * <span class="number">3600</span> + minute * <span class="number">60</span> + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSecondsToday</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用当前的 day/month/year 创建一个对象</span></span><br><span class="line">  <span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(now.getFullYear(), now.getMonth(), now.getDate());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> diff = now - today; <span class="comment">// ms difference</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(diff / <span class="number">1000</span>); <span class="comment">// make seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>距离明天还有多少秒？</p>
<p>写一个函数 <code>getSecondsToTomorrow()</code>，返回距离明天的秒数。</p>
<p>例如，现在是 <code>23:00</code>，那么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getSecondsToTomorrow() == <span class="number">3600</span></span><br></pre></td></tr></table></figure>

<p>P.S. 该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSecondsToTomorrow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tomorrow = <span class="keyword">new</span> <span class="built_in">Date</span>(now.getFullYear(), now.getMonth(), now.getDate() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> diff = tomorrow - now;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random(diff / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化相对日期</p>
<p>写一个函数 <code>formatDate(date)</code>，能够对 <code>date</code> 进行如下格式化：</p>
<ul>
<li>如果 <code>date</code> 距离现在不到 1 秒，输出 <code>&quot;right now&quot;</code>。</li>
<li>否则，如果 <code>date</code> 距离现在不到 1 分钟，输出 <code>&quot;n sec. ago&quot;</code>。</li>
<li>否则，如果不到 1 小时，输出 <code>&quot;m min. ago&quot;</code>。</li>
<li>否则，以 <code>&quot;DD.MM.YY HH:mm&quot;</code> 格式输出完整日期。即：<code>&quot;day.month.year hours:minutes&quot;</code>，全部以两位数格式表示，例如：<code>31.12.16 10:00</code>。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - <span class="number">1</span>)) ); <span class="comment">// "right now"</span></span><br><span class="line"></span><br><span class="line">alert( formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - <span class="number">30</span> * <span class="number">1000</span>)) ); <span class="comment">// "30 sec. ago"</span></span><br><span class="line"></span><br><span class="line">alert( formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>)) ); <span class="comment">// "5 min. ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 昨天的日期，例如 31.12.16 20:00</span></span><br><span class="line">alert( formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - <span class="number">86400</span> * <span class="number">1000</span>)) );</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> diff = <span class="built_in">Math</span>.round((now - date) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hour = <span class="built_in">Math</span>.floor(diff / <span class="number">3600</span>);</span><br><span class="line">  <span class="keyword">const</span> minute = <span class="built_in">Math</span>.floor((diff - hour * <span class="number">3600</span>) / <span class="number">60</span>);</span><br><span class="line">  <span class="keyword">const</span> second = <span class="built_in">Math</span>.floor(diff % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hour) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;format(date.getDate())&#125;</span>.<span class="subst">$&#123;format(date.getMonth() + <span class="number">1</span>)&#125;</span>.<span class="subst">$&#123;format(</span></span></span><br><span class="line"><span class="string"><span class="subst">      date.getFullYear()</span></span></span><br><span class="line"><span class="string"><span class="subst">    )&#125;</span> <span class="subst">$&#123;format(date.getHours())&#125;</span>:<span class="subst">$&#123;format(date.getMinutes())&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minute) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;minute&#125;</span> min. ago`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (second) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;second&#125;</span> sec. ago`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`right now`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num = <span class="string">'0'</span> + num;</span><br><span class="line">  <span class="keyword">return</span> num.slice(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 09</title>
    <url>/2020/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-09/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-09"><a href="#学习笔记-2020-11-09" class="headerlink" title="学习笔记 2020-11-09"></a>学习笔记 2020-11-09</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h4><h5 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h5><p>在所有节点类型中，DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为轻量级文档，能够包含和操作节点，却没有完整文档那样额外的消耗。</p>
<ul>
<li>nodeType 等于 11 ；</li>
<li>nodeName 值为 “#document-fragment”；</li>
<li>nodeValue 值为 null ；</li>
<li>parentNode 值为 null ；</li>
<li>子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference 。</li>
</ul>
<p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。</p>
<p>使用 document.createDocumentFragment() 方法创建文档片段。</p>
<p>文档片段从 Node 类型继承了所有文档类型具备的可以执行 DOM 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过 appendChild() 或 insertBefore() 方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。</p>
<h5 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h5><p>元素数据在 DOM 中通过 Attr 类型表示。 Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上说，属性是存在于元素 attributes 属性中的节点。Attr 节点具有以下特征：</p>
<ul>
<li>nodeType 等于 2 ；</li>
<li>nodeName 值为属性名；</li>
<li>nodeValue 值为属性值；</li>
<li>parentNode 值为 null ；</li>
<li>在 HTML 中不支持子节点；</li>
<li>在 XML 中子节点可以是 Text 或 EntityReference。</li>
</ul>
<p>属性节点不被认为是 DOM 文档树的一部分。 Attr 节点很少直接被引用。</p>
<p>Attr 对象上有 3 个属性：name 、 value 和 specified 。其中， name 包含属性名 ( 与 nodeName 一样 )，value 包含属性值 ( 与 nodeValue一样 )，而 specified 是一个布尔值，表示属性使用的是默认值还是被指定的值。</p>
<p>可以使用 document.createAttribute() 方法创建新的 Attr 节点，参数为属性名。</p>
<h4 id="DOM-编程"><a href="#DOM-编程" class="headerlink" title="DOM 编程"></a>DOM 编程</h4><h5 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h5><p>动态脚本指的是动态创建 script 标签，嵌入代码。引入外部代码则是设置标签的 src 属性，嵌入源码则是创建文本节点。</p>
<p>通过 innerHTML 属性创建的 script 元素永不执行。</p>
<h5 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h5><p>动态样式指的是页面初始加载时不存在，后续添加的样式。例如动态创建 link 标签，引入外部样式表。或是动态创建 style 标签来写入样式。</p>
<p>通过外部文件加载样式是一个异步过程。</p>
<h5 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h5><p>通过 DOM 编程创建 table 元素，需要涉及大量标签。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">'100%'</span>;</span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span><br><span class="line">tbody.appendChild(row1);</span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell1_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,1'</span>));</span><br><span class="line">row1.appendChild(cell1_1);</span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell2_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,1'</span>));</span><br><span class="line">row1.appendChild(cell2_1);</span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span><br><span class="line">tbody.appendChild(row2);</span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell1_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,2'</span>));</span><br><span class="line">row2.appendChild(cell1_2);</span><br><span class="line"><span class="keyword">let</span> cell2_2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell2_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,2'</span>));</span><br><span class="line">row2.appendChild(cell2_2);</span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-09/image-20201109082609637.png" alt="image-20201109082609637"></p>
<p>因此，DOM 给表格添加了一些属性和方法：</p>
<p><code>&lt;table&gt;</code> 元素的属性和方法：</p>
<ul>
<li>caption，指向 <code>&lt;caption&gt;</code> 元素的指针；</li>
<li>tBodies，包含 <code>&lt;tbody&gt;</code> 元素的 HTMLCollection；</li>
<li>tFoot，指向 <code>&lt;tfoot&gt;</code>元素（如果存在）；</li>
<li>tHead，指向 <code>&lt;thead&gt;</code> 元素（如果存在）；</li>
<li>rows，包含表示所有行的 HTMLCollection； </li>
<li>createTHead()，创建 <code>&lt;thead&gt;</code>元素，放到表格中，返回引用；</li>
<li>createTFoot()，创建 <code>&lt;tfoot&gt;</code> 元素，放到表格中，返回引用；</li>
<li>createCaption()，创建 <code>&lt;caption&gt;</code> 元素，放到表格中，返回引用；</li>
<li>deleteTHead()，删除 <code>&lt;thead&gt;</code> 元素；</li>
<li>deleteTFoot()，删除 <code>&lt;tfoot&gt;</code> 元素；</li>
<li>deleteCaption()，删除 <code>&lt;caption&gt;</code> 元素；</li>
<li>deleteRow(<em>pos</em>)，删除给定位置的行；</li>
<li>insertRow(<em>pos</em>)，在行集合中给定位置插入一行。</li>
</ul>
<p><code>&lt;tbody&gt;</code> 元素添加了以下属性和方法：</p>
<ul>
<li>rows，包含 <code>&lt;tbody&gt;</code> 元素中所有行的 HTMLCollection；</li>
<li>deleteRow(<em>pos</em>)，删除给定位置的行；</li>
<li>insertRow(<em>pos</em>)，在行集合中给定位置插入一行，返回该行的引用。</li>
</ul>
<p><code>&lt;tr&gt;</code> 元素添加了以下属性和方法：</p>
<ul>
<li>cells，包含 <code>&lt;tr&gt;</code> 元素所有表元的 HTMLCollection； </li>
<li>deleteCell(<em>pos</em>)，删除给定位置的表元；</li>
<li>insertCell(<em>pos</em>)，在表元集合给定位置插入一个表元，返回该表元的引用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">'100%'</span>;</span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,1'</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,1'</span>));</span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.insertRow(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,2'</span>));</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,2'</span>));</span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure>

<h5 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h5><p>理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这 3 个集合类型都是实时的。</p>
<p>NodeList 是基于 DOM 文档的实时查询。</p>
<h4 id="MutationObserver-接口"><a href="#MutationObserver-接口" class="headerlink" title="MutationObserver 接口"></a>MutationObserver 接口</h4><p>该接口可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档、 DOM 树的一部分，或某个元素，还可以观察元素属性、子节点、文本或前三者任意组合的变化。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>MutationObserver 的实例要通过调用 MutationObserver 构造函数并传入一个回调参数来创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'DOM was mutated!'</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li><p>observe() 方法</p>
<p>新创建的实例不会关联 DOM 。使用 observe() 方法把这个 observer 与 DOM 关联，接收两个必需参数：要观察其变化的 DOM 节点，一个 MutationObserverInit 对象。</p>
<p>MutationObserverInit 对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'&lt;body&gt; attributes changed'</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Changed body class'</span>);</span><br></pre></td></tr></table></figure>

<p>该代码会创建一个观察者来观察 body 元素上的属性变化。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>解构赋值</p>
<p>我们有一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  years: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写一个解构赋值语句使得：</p>
<ul>
<li><code>name</code> 属性赋值给变量 <code>name</code>。</li>
<li><code>years</code> 属性赋值给变量 <code>age</code>。</li>
<li><code>isAdmin</code> 属性赋值给变量 <code>isAdmin</code>（如果属性缺失则取默认值 false）。</li>
</ul>
<p>下面是赋值完成后的值的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">years</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等号左侧是你的代码</span></span><br><span class="line"><span class="comment">// ... = user</span></span><br><span class="line"></span><br><span class="line">alert( name ); <span class="comment">// John</span></span><br><span class="line">alert( age ); <span class="comment">// 30</span></span><br><span class="line">alert( isAdmin ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; name, <span class="attr">years</span>: age, isAdmin = <span class="literal">false</span> &#125; = user;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最高薪资</p>
<p>这儿有一个 <code>salaries</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> salaries = &#123;</span><br><span class="line">  <span class="string">"John"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"Pete"</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="string">"Mary"</span>: <span class="number">250</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新建一个函数 <code>topSalary(salaries)</code>，返回收入最高的人的姓名。</p>
<ul>
<li>如果 <code>salaries</code> 是空的，函数应该返回 <code>null</code>。</li>
<li>如果有多个收入最高的人，返回其中任意一个即可。</li>
</ul>
<p>P.S. 使用 <code>Object.entries</code> 和解构语法来遍历键/值对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topSalary</span>(<span class="params">salaries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="built_in">Object</span>.entries(salaries);</span><br><span class="line">  <span class="keyword">if</span> (value.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxName = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [name, salary] <span class="keyword">of</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (salary &gt; max) &#123;</span><br><span class="line">      maxName = name;</span><br><span class="line">      max = salary;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 08</title>
    <url>/2020/11/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-08/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-08"><a href="#学习笔记-2020-11-08" class="headerlink" title="学习笔记 2020-11-08"></a>学习笔记 2020-11-08</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h4><h5 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h5><ol>
<li><p>HTML 元素</p>
<p>所有 HTML 元素都通过 HTMLElement 类型表示。 HTMLElement 直接继承 Element 并增加了一些属性。每个属性对应以下属性之一，它们是所有 HTML 元素上都有的标准属性：</p>
<ul>
<li>id：元素在文档中的唯一标识符。</li>
<li>title：包含元素的额外信息，通常以提示条形式展示。</li>
<li>lang：元素内容的语言代码。</li>
<li>dir：元素的书写方向 ( “ltr” 表示从左到右，“rtl”表示从右到左。 )</li>
<li>className：元素的 CSS 类。</li>
</ul>
<p>这些属性可以获取对应的值，也可以用来修改相应的值。</p>
<p>所有 HTML 元素都是 HTMLElement 或其子类型的实例。</p>
<p>下表是所有 HTML 元素以及对应的类型，( 斜体表示已经废弃的元素 )。</p>
<p><img src="/2020/11/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-08/image-20201108085455515.png" alt="image-20201108085455515"></p>
<p><img src="/2020/11/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-08/image-20201108085523831.png" alt="image-20201108085523831"></p>
</li>
<li><p>取得属性</p>
<p>每个元素都有零个或多个属性。与属性相关的 DOM 方法有三个：</p>
<ul>
<li>getAttribute()</li>
<li>setAttribute()</li>
<li>removeAttribute()</li>
</ul>
<p>getAttribute() 能取得正式属性和自定义属性。属性名不区分大小写。根据 HTML5 规范的要求，自定义属性名应该前缀 data- 以方便验证。</p>
<p>元素的所有属性都可以通过 DOM 元素对象的属性来取得，除了自定义属性。</p>
<p>通过 DOM 元素对象访问的属性有两个返回的值跟使用 getAttribute() 取得的值不一样。首先是 style 属性。在使用 getAttribute() 访问 style 属性时，返回的是 CSS 字符串。而在通过 DOM 对象的属性访问时， style 属性返回的是一个 ( CSSStyleDeclaration ) 对象。DOM 对象的 style 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 style 属性的字符串值。(存疑，验证了一下 style 属性会返回 DOM 对象 style 属性的修改。)</p>
<p>第二类是事件处理程序。在 DOM 元素上获取事件属性，得到 JS 代码。使用 getAttribute() 访问，得到字符串形式的源码。( 存疑，验证了以下使用 getAttribute() 获取的是 null 。)</p>
</li>
<li><p>设置属性</p>
<p>setAttribute() 接收两个参数，要设置的属性名和属性的值。适用于 HTML 属性和自定义属性。在 DOM 对象上添加自定义属性，不会自动变成元素的属性。</p>
</li>
<li><p>attributes 属性</p>
<p>Element 类型是唯一使用 attributes 属性的 DOM 节点类型。attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的实时集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。NamedNodeMap 对象包含下列方法：</p>
<ul>
<li>getNamedItem(name)，返回 nodeName 属性等于 name 的节点；</li>
<li>removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；</li>
<li>setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；</li>
<li>item(pos)，返回索引位置 pos 处的节点。</li>
</ul>
<p>attributes 属性中的每个节点的 nodeName 是对应属性的名字，nodeValue 是属性的值。</p>
<p>attributes 属性最有用的场景是需要迭代元素上所有属性的时候。</p>
</li>
<li><p>创建元素</p>
<p>使用 document.createElement() 方法创建新元素，接受一个参数，即要创建元素的标签名。HTML 文档中，标签名不区分大小写。</p>
<p>使用该方法创建新元素的同时也会将其 ownerDocument 属性设置为 document。</p>
</li>
<li><p>元素后代</p>
<p>元素可以拥有任意多个子元素和后代元素。</p>
</li>
</ol>
<h5 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h5><p>Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转移后的 HTML 字符。Text 类型的节点具有以下特征：</p>
<ul>
<li>nodeType 等于 3；</li>
<li>nodeName 值为 “#text”；</li>
<li>nodeValue 值为节点中包含的文本；</li>
<li>parentNode 值为 Element 对象；</li>
<li>不支持子节点。</li>
</ul>
<p>Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问。文本节点暴露了以下操作文本的方法：</p>
<ul>
<li>appendData(text)，向节点末尾添加文本 text；</li>
<li>deleteData(offset, count)，从位置 offset 开始删除 count 个字符；</li>
<li>insertData(offset, text)，在位置 offset 插入 text；</li>
<li>replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的文本；</li>
<li>splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点；</li>
<li>substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。</li>
</ul>
<p>还可以通过 length 属性获取文本节点中包含的字符数量。这个值等于 nodeValue.length 和 data.length 。</p>
<ol>
<li><p>创建文本节点</p>
<p>document.createTextNode() 可以用来创建新文本节点，接收一个参数，即要插入节点的文本。</p>
</li>
<li><p>规范化文本节点</p>
<p>normalize() 方法用于合并相邻的文本节点，是在 Node 类型中定义的。在父节点上调用时，所有同胞文本节点会被合并为一个文本节点。</p>
</li>
<li><p>拆分文本节点</p>
<p>Text 类型定义了一个与 normalize() 相反的方法—— splitText() 。这个方法可以在指定的偏移位置拆分 nodeValue 。</p>
</li>
</ol>
<h5 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h5><p>DOM 中的注释通过 Comment 类型表示，具有以下特征：</p>
<ul>
<li>nodeType 等于 8 ；</li>
<li>nodeName 值为 “#comment”；</li>
<li>nodeValue 值为注释的内容；</li>
<li>parentNode 值为 Document 或 Element 对象；</li>
<li>不支持子节点。</li>
</ul>
<p>Comment 类型与 Text 类型继承同一个基类 ( CharacterData ) ，因此拥有除 splitText() 之外 Text 节点所有的字符串操作方法。</p>
<p>可以使用 documen.createCommment() 方法创建注释节点，参数为注释文本。</p>
<h5 id="CDATASection-类型"><a href="#CDATASection-类型" class="headerlink" title="CDATASection 类型"></a>CDATASection 类型</h5><p>CDATASection 类型表示 XML 中特有的 CDATA 区块。CDATASection 类型继承 Text 类型，因此拥有包括 splitText() 在内的所有字符串操作方法。CDATASection 类型的节点具有以下特性：</p>
<ul>
<li>nodeType 等于 4 ；</li>
<li>nodeName 值为 “#cdata-section”；</li>
<li>nodeValue 值为 CDATA 区块的内容；</li>
<li>parentNode 值为 Document 或 Element 对象；</li>
<li>不支持子节点。</li>
</ul>
<p>CDATA 区块只有 XML 文档中有效。可以使用 document.createCDataSection() 并传入节点内容来创建 CDATA 区块。</p>
<h5 id="DocumentType-类型"><a href="#DocumentType-类型" class="headerlink" title="DocumentType 类型"></a>DocumentType 类型</h5><p>DocumentType 类型的节点包含文档的文档类型信息，具有以下特征：</p>
<ul>
<li>nodeType 等于 10 ；</li>
<li>nodeName 值为文档类型的名称；</li>
<li>nodeValue 值为 null ；</li>
<li>parentNode 值为 Document 对象；</li>
<li>不支持子节点。</li>
</ul>
<p>DocumentType 对象在 DOM Level 1 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器， DocumentType 对象保存在 document.doctype 属性中。DOM Level 1 规定了 DocumentType 对象的 3 个属性： name 、 entities 和 notations 。其中， name 是文档类型的名称， entities 是这个文档类型描述的实体的 NamedNodeMap ，而 notations 是这个文档类型描述的表示法的 NamedNodeMap 。因为浏览器中的文档通常是 HTML 和 XHTML 文档类型，所以 entities 和 notations 列表为空。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>属性求和</p>
<p>有一个带有任意数量薪水的 <code>salaries</code> 对象。</p>
<p>编写函数 <code>sumSalaries(salaries)</code>，该函数使用 <code>Object.values</code> 和 <code>for..of</code> 循环返回所有薪水的总和。</p>
<p>如果 <code>salaries</code> 是空对象，那么结果必须是 <code>0</code>。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> salaries = &#123;</span><br><span class="line">  <span class="string">"John"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">"Pete"</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="string">"Mary"</span>: <span class="number">250</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( sumSalaries(salaries) ); <span class="comment">// 650</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalaries</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> values = <span class="built_in">Object</span>.values(arr);</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算属性数量</p>
<p>写一个函数 <code>count(obj)</code>，该函数返回对象中的属性的数量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( count(user) ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>试着使代码尽可能简短。</p>
<p>P.S. 忽略 Symbol 类型属性，只计算“常规”属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(user).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 07</title>
    <url>/2020/11/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-07/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-07"><a href="#学习笔记-2020-11-07" class="headerlink" title="学习笔记 2020-11-07"></a>学习笔记 2020-11-07</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><h5 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h5><ol>
<li><p>操纵节点</p>
<p>因为所有关系指针都是只读的，所以 DOM 提供了一些操纵节点的方法。</p>
<ul>
<li><p>appendChild()：用于在 childNodes 列表末尾添加节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line"><span class="built_in">console</span>.log(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(someNode.lastChild == newNode); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>已存在的节点传给该方法，会使得该节点被转移到新位置。</p>
</li>
<li><p>insertBefore()：用于把节点放到指定位置。接收两个参数，要插入的节点和参照节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newNode == someNode.lastChild); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</span><br><span class="line"><span class="built_in">console</span>.log(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newNode == someNode.firstChild); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild);</span><br><span class="line"><span class="built_in">console</span>.log(newNode == someNode.childNodes[someNode.childNodes.length - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>replaceChild()：替换节点。接收两个参数，要插入的节点和要替换的节点。返回要替换的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure>
</li>
<li><p>removeChild()：移除节点。接收要被移除的节点。返回被移除的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerFirstChild = someNode.removeChild(someNode.firstChild);</span><br><span class="line"><span class="comment">// 删除最后一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerLastChild = someNode.removeChild(someNode.lastChild);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上所有方法都用于操纵某节点的子元素。</p>
</li>
<li><p>其他方法</p>
<p>所有节点类型还共享了两个方法：</p>
<ul>
<li>cloneNode()：返回与调用它的节点一模一样的节点，接收一个布尔值参数，表示是否深复制。深复制会复制节点以及整个子 DOM 树，浅复制只会复制调用该方法的节点。该方法不会复制添加到 DOM 节点的 JS 属性，例如事件处理程序。</li>
<li>normalize()：处理文档子树中的文本节点。在节点上调用该方法会检测这个节点的所有后代，从中搜索上述两种情形。删除空文本节点。合并两个相邻的同胞节点。</li>
</ul>
</li>
</ol>
<h5 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h5><p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例 ( HTMLDocument 继承 Document )，表示整个 HTML 页面。document 是 window 对象的属性，是一个全局对象。Document 类型的节点有以下特征：</p>
<ul>
<li>nodeType 为 9；</li>
<li>nodeName 值为 <code>#document</code> ；</li>
<li>nodeValue 值为 null ；</li>
<li>parentNode 值为 null ；</li>
<li>ownerDocument 值为 null；</li>
<li>子节点可以是 DocumentType ( 最多一个 )、Element ( 最多一个 )、ProcessingInstruction 或 Comment 类型。</li>
</ul>
<p>Document 类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过 HTMLDocument 的实例取得 document 对象。document 对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p>
<ol>
<li><p>文档子节点</p>
<p>Document 节点有两个访问子节点的快捷方式：</p>
<ul>
<li><p>documentElement 属性，指向 HTML 页面的 <code>&lt;html&gt;</code> 元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.firstChild); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>body 属性，指向 <code>&lt;body&gt;</code> 元素。</p>
</li>
</ul>
<p>Document 类型另一种可能的子节点是 DocumentType 。</p>
<p><code>&lt;!doctype&gt;</code> 标签是文档中独立的部分，其信息可以通过 doctype 属性来访问。</p>
<p>文档类型是只读的，只能有一个 Element 类型的子节点，即 <code>&lt;html&gt;</code> 。</p>
</li>
<li><p>文档信息</p>
<p>document 作为 HTMLDocument 的实例，还有一些标准 Document 对象上所没有的属性。</p>
<ul>
<li>title，包含 <code>&lt;title&gt;</code> 元素中的文本。通过这个属性可以读写页面的标题，但修改该元素不会改变 <code>&lt;title&gt;</code> 元素。</li>
<li>URL：包含当前页面的完整 URL 。</li>
<li>domain：包含页面的域名。</li>
<li>referrer：包含链接到当前页面的那个页面的 URL 。</li>
</ul>
<p>以上三个属性，只有 domain 是可以设置的，且设置的值受限。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'nczonline.net'</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>

<p>当页面中包含来自不同子域的窗格或内嵌窗格时，设置 document.domain 是有用的，可以避开跨域通信，使得彼此可以访问 JavaScript 对象。</p>
<p>浏览器对 domain 属性还有一个限制，这个属性一旦放松就不能再收紧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span>; <span class="comment">// 放松，成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'p2p.wrox.com'</span>; <span class="comment">// 收紧，错误！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定位元素</p>
<ul>
<li>getElementById() 接收一个参数，即要获取元素的 ID 。返回第一个匹配的元素或 null 。</li>
<li>getElementsByTagName() 接收一个参数，即要获取元素的标签名。返回包含零个或多个元素的 NodeList 。在 HTML 文档中，这个方法返回一个 HTMLCollection 对象。HTMLCollection 对象与 NodeList 很相似。它有一个额外的方法 namedItem() ，可通过标签的 name 属性取得某一项的引用。对于有 name 属性的元素，还可以直接使用中括号来获取。</li>
<li>getElementsByName() 接收一个参数，元素的 name 属性。</li>
</ul>
</li>
<li><p>特殊集合</p>
<ul>
<li>document.anchors 包含文档中所有带 name 属性的 <code>&lt;a&gt;</code> 元素。</li>
<li>document.applets 包含文档中所有 <code>&lt;applet&gt;</code> 元素。</li>
<li>document.forms 包含文档中所有 <code>&lt;form&gt;</code> 元素。</li>
<li>document.images 包含文档中所有 <code>&lt;img&gt;</code> 元素。</li>
<li>document.links 包含文档中所有带 href 属性的 <code>&lt;a&gt;</code> 元素。</li>
</ul>
</li>
<li><p>DOM 兼容性检测</p>
<p>DOM Level 1 在 document.implementation 上只定义了一个方法，即 hasFeature() 。这个方法接收两个参数：特性名称和 DOM 版本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">支持的版本</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Core</td>
<td align="center">1.0、2.0、3.0</td>
<td align="center">定义树形文档结构的基本 DOM 。</td>
</tr>
<tr>
<td align="center">XML</td>
<td align="center">1.0、2.0、3.0</td>
<td align="center">Core 的 XML 拓展，增加了对 CDATA 区块】处理指令和实体的支持。</td>
</tr>
<tr>
<td align="center">HTML</td>
<td align="center">1.0、2.0</td>
<td align="center">XML 的 HTML 拓展，增加了 HTML 特点的元素和实体。</td>
</tr>
<tr>
<td align="center">Views</td>
<td align="center">2.0</td>
<td align="center">文档基于某些样式的实现格式。</td>
</tr>
<tr>
<td align="center">StyleSheets</td>
<td align="center">2.0</td>
<td align="center">文档的相关样式表</td>
</tr>
<tr>
<td align="center">CSS</td>
<td align="center">2.0</td>
<td align="center">Cascading Style Sheets Level 1</td>
</tr>
<tr>
<td align="center">CSS2</td>
<td align="center">2.0</td>
<td align="center">Cascading Style Sheets Level 2</td>
</tr>
<tr>
<td align="center">Events</td>
<td align="center">2.0、3.0</td>
<td align="center">通用 DOM 事件</td>
</tr>
<tr>
<td align="center">UIEvents</td>
<td align="center">2.0、3.0</td>
<td align="center">用户界面事件</td>
</tr>
<tr>
<td align="center">TextEvents</td>
<td align="center">3.0</td>
<td align="center">文本输入设备触发的事件</td>
</tr>
<tr>
<td align="center">MouseEvents</td>
<td align="center">2.0、3.0</td>
<td align="center">鼠标导致的事件</td>
</tr>
<tr>
<td align="center">MutationEvents</td>
<td align="center">2.0、3.0</td>
<td align="center">DOM 树变化时触发的事件</td>
</tr>
<tr>
<td align="center">MutationNameEvents</td>
<td align="center">3.0</td>
<td align="center">DOM 元素或元素属性被重命名时触发的事件</td>
</tr>
<tr>
<td align="center">HTMLEvents</td>
<td align="center">2.0</td>
<td align="center">HTML 4.01 事件</td>
</tr>
<tr>
<td align="center">Range</td>
<td align="center">2.0</td>
<td align="center">在 DOM 树中操作一定范围的对象和方法</td>
</tr>
<tr>
<td align="center">Traversal</td>
<td align="center">2.0</td>
<td align="center">遍历 DOM 树的方法</td>
</tr>
<tr>
<td align="center">LS</td>
<td align="center">3.0</td>
<td align="center">文件与 DOM 树之间的同步加载与保存</td>
</tr>
<tr>
<td align="center">LS-Async</td>
<td align="center">3.0</td>
<td align="center">文件与 DOM 树之间的异步加载与保存</td>
</tr>
<tr>
<td align="center">Validation</td>
<td align="center">3.0</td>
<td align="center">修改 DOM 树并保证其继续有效的方法</td>
</tr>
<tr>
<td align="center">XPath</td>
<td align="center">3.0</td>
<td align="center">访问 XML 文档不同部分的语言</td>
</tr>
</tbody></table>
<p>目前该方法已被废弃。</p>
</li>
<li><p>文档写入</p>
<ul>
<li>write()</li>
<li>writeln()</li>
<li>open()</li>
<li>close()</li>
</ul>
<p>write() 和 writeln() 都接收一个字符串参数，将这个字符串写入网页。</p>
<p>在页面加载过程中，两个方法会向文档中输出内容，在页面加载完后调用会重写整个页面。</p>
<p>open() 和 close() 用于打开和关闭网页输出流。</p>
</li>
</ol>
<h5 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h5><p>Element 表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。该类型的节点具有以下特征：</p>
<ul>
<li>nodeType 等于 1；</li>
<li>nodeName 值为元素的标签名；</li>
<li>nodeValue 值为 null ；</li>
<li>parentNode 值为 Document 或 Element 对象；</li>
<li>子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference 类型。</li>
</ul>
<p>可以通过 nodeName 或 tagName 属性来获取元素的标签名。这两个属性返回同样的值。</p>
<p>在 HTML 中，元素标签名始终以全大写表示。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>存储 “unread” 标识</p>
<p>这里有一个 messages 数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = [</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"Hello"</span>, <span class="attr">from</span>: <span class="string">"John"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"How goes?"</span>, <span class="attr">from</span>: <span class="string">"John"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"See you soon"</span>, <span class="attr">from</span>: <span class="string">"Alice"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>你的代码可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。</p>
<p>现在，你应该使用什么数据结构来保存关于消息“是否已读”的信息？该结构必须很适合对给定的 message 对象给出“它读了吗？”的答案。</p>
<p>P.S. 当一个消息被从 <code>messages</code> 中删除后，它应该也从你的数据结构中消失。</p>
<p>P.S. 我们不能修改 message 对象，例如向其添加我们的属性。因为它们是由其他人的代码管理的，我们修改该数据可能会导致不好的后果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = [</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'Hello'</span>, <span class="attr">from</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'How goes?'</span>, <span class="attr">from</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'See you soon'</span>, <span class="attr">from</span>: <span class="string">'Alice'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readMessages = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个消息已读</span></span><br><span class="line">readMessages.add(messages[<span class="number">0</span>]);</span><br><span class="line">readMessages.add(messages[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// readMessages 包含两个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……让我们再读一遍第一条消息！</span></span><br><span class="line">readMessages.add(messages[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// readMessages 仍然有两个不重复的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回答：message[0] 已读？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Read message 0: '</span> + readMessages.has(messages[<span class="number">0</span>])); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">messages.shift();</span><br><span class="line"><span class="comment">// 现在 readMessages 有一个元素（技术上来讲，内存可能稍后才会被清理）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>保存阅读日期</p>
<p>这儿有一个和 <a href="https://zh.javascript.info/task/recipients-read" target="_blank" rel="noopener">上一个任务</a> 类似的 <code>messages</code> 数组。场景也相似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = [</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"Hello"</span>, <span class="attr">from</span>: <span class="string">"John"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"How goes?"</span>, <span class="attr">from</span>: <span class="string">"John"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">text</span>: <span class="string">"See you soon"</span>, <span class="attr">from</span>: <span class="string">"Alice"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>现在的问题是：你建议采用什么数据结构来保存信息：“消息是什么时候被阅读的？”。</p>
<p>在前一个任务中我们只需要保存“是/否”。现在我们需要保存日期，并且它应该在消息被垃圾回收时也被从内存中清除。</p>
<p>P.S. 日期可以存储为内建的 <code>Date</code> 类的对象，稍后我们将进行介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = [</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'Hello'</span>, <span class="attr">from</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'How goes?'</span>, <span class="attr">from</span>: <span class="string">'John'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">text</span>: <span class="string">'See you soon'</span>, <span class="attr">from</span>: <span class="string">'Alice'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">readMap.set(messages[<span class="number">0</span>], <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>





</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 06</title>
    <url>/2020/11/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-06/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-06"><a href="#学习笔记-2020-11-06" class="headerlink" title="学习笔记 2020-11-06"></a>学习笔记 2020-11-06</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h4 id="软件与硬件检测"><a href="#软件与硬件检测" class="headerlink" title="软件与硬件检测"></a>软件与硬件检测</h4><h5 id="浏览器元数据"><a href="#浏览器元数据" class="headerlink" title="浏览器元数据"></a>浏览器元数据</h5><ol>
<li><p>Battery Status API</p>
<p>浏览器可以访问设备电池及充电状态的信息。<code>navigator.getBattery()</code> 方法会返回一个期约实例，解决为一个 <code>BatteryManager</code> 对象，包含四个只读属性：</p>
<ul>
<li><code>charging</code> 布尔值，表示设备当前是否正接入电源充电，如果设备没有电池，则返回 <code>true</code> 。</li>
<li><code>chargingTime</code> 整数，表示预计离电池充满还有多少秒。如果电池已充满或设备没有电池，则返回 0 。</li>
<li><code>dischargingTime</code> 整数，表示预计离电量耗尽还有多少秒，如果设备没有电池，则返回 Infinity 。</li>
<li><code>level</code> 浮点数，表示电量百分比。电量完全耗尽返回 <code>0.0</code> ，电池充满或设备没有电池则返回 <code>1.0</code> 。</li>
</ul>
<p>这个 API 还提供了 4 个事件属性，可用于设置在相应的电池事件发生时调用的回调函数。</p>
<ul>
<li>onchargingchange</li>
<li>onchargingtimechange</li>
<li>ondischargingtimechange</li>
<li>onlevelchange</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.getBattery().then(<span class="function"><span class="params">battery</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 添加充电状态变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> chargingChangeHandler = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'chargingchange'</span>);</span><br><span class="line">  battery.onchargingchange = chargingChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.addEventListener(<span class="string">'chargingchange'</span>, chargingChangeHandler);</span><br><span class="line">  <span class="comment">// 添加充电时间变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> chargingTimeChangeHandler = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'chargingtimechange'</span>);</span><br><span class="line">  battery.onchargingtimechange = chargingTimeChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.addEventListener(<span class="string">'chargingtimechange'</span>, chargingTimeChangeHandler);</span><br><span class="line">  <span class="comment">// 添加放电时间变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> dischargingTimeChangeHandler = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'dischargingtimechange'</span>);</span><br><span class="line">  battery.ondischargingtimechange = dischargingTimeChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.addEventListener(<span class="string">'dischargingtimechange'</span>, dischargingTimeChangeHandler);</span><br><span class="line">  <span class="comment">// 添加电量百分比变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> levelChangeHandler = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'levelchange'</span>);</span><br><span class="line">  battery.onlevelchange = levelChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.addEventListener(<span class="string">'levelchange'</span>, levelChangeHandler);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><ol>
<li><p>处理器核心数</p>
<p><code>navigator.hardwareConcurrency</code> 属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值。这个值表示浏览器可以并行执行的最大工作线程数量，不一定是实际的 CPU 核心数。</p>
</li>
<li><p>设备内存大小、</p>
<p><code>navigator.deviceMemory</code> 属性返回设备大致的系统内存大小，包含单位为 GB 的浮点数。</p>
</li>
<li><p>最大触点数</p>
<p><code>navigator.maxTouchPoints</code> 属性返回触摸屏支持的最大关联触点数量，包含一个整数值。</p>
</li>
</ol>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>HTMl 中的每段标记都可以表示为一个节点。DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。</p>
<h4 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h4><h5 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h5><p>DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。 Node 接口在 JavaScript 中被实现为 Node 类型，在除 IE 之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。</p>
<p>每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：</p>
<ul>
<li>Node.ELEMENT_NODE ( 1 )</li>
<li>Node.ATTRIBUTE_NODE ( 2 )</li>
<li>Node.TEXT_NODE ( 3 )</li>
<li>Node.CDATA_SECTION_NODE ( 4 )</li>
<li>Node.ENTITY_PEFERENCE_NODE ( 5 )</li>
<li>Node.ENTITY_NODE ( 6 )</li>
<li>Node.PROCESSING_INSTRUCTION_NODE ( 7 )</li>
<li>Node.COMMENT_NODE ( 8 )</li>
<li>Node.DOCUMENT_NODE ( 9 )</li>
<li>Node.DOCUMENT_TYPE_NODE ( 10 )</li>
<li>Node.DOCUMENT_FRAGMENT_NODE ( 11 )</li>
<li>Node.NOTATION_NODE ( 12 )</li>
</ul>
<p>节点类型可以通过与这些常量比较来确定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Node is an element.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器并不支持所有节点类型。</p>
<ol>
<li><p>nodeName 与 nodeValue</p>
<p>nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">  value = someNode.nodeName; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对元素而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null 。</p>
</li>
<li><p>节点关系</p>
<p>每个节点有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。NodeList 对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来。NodeList 是实时的活动对象，而不是第一次访问时所获的内容的快照。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count = someNode.childNodes.length;</span><br></pre></td></tr></table></figure>

<p>每个节点有一个 parentNode 属性，指向其 DOM 树中的父元素。</p>
<p>childNodes 列表中的每个节点都是同一列表中其他节点的同胞节点，使用 previousSibling 和 nextSibling 可以在这个列表的节点间导航。列表中第一个节点和最后一个节点的同胞属性为 null 。</p>
<p>父节点和它的第一个及最后一个子节点也有专门属性：</p>
<ul>
<li>firstChild</li>
<li>lastChild</li>
</ul>
<p>还有一个方法是 <code>hasChildNodes()</code> ，可以判断节点是否有一个或多个子节点。</p>
<p>所有节点共享一个关系： ownerDocument 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们的文档所拥有。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>过滤数组中的唯一元素</p>
<p>定义 <code>arr</code> 为一个数组。</p>
<p>创建一个函数 <code>unique(arr)</code>，该函数返回一个由 <code>arr</code> 中所有唯一元素所组成的数组。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 你的代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="string">"Hare"</span>, <span class="string">"Krishna"</span>, <span class="string">"Hare"</span>, <span class="string">"Krishna"</span>,</span><br><span class="line">  <span class="string">"Krishna"</span>, <span class="string">"Krishna"</span>, <span class="string">"Hare"</span>, <span class="string">"Hare"</span>, <span class="string">":-O"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">alert( unique(values) ); <span class="comment">// Hare, Krishna, :-O</span></span><br></pre></td></tr></table></figure>

<p>P.S. 这里用到了 string 类型，但其实可以是任何类型的值。</p>
<p>P.S. 使用 <code>Set</code> 来存储唯一值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤字谜</p>
<p><a href="https://en.wikipedia.org/wiki/Anagram" target="_blank" rel="noopener">Anagrams</a> 是具有相同数量相同字母但是顺序不同的单词。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nap - pan</span><br><span class="line">ear - are - era</span><br><span class="line">cheaters - hectares - teachers</span><br></pre></td></tr></table></figure>

<p>写一个函数 <code>aclean(arr)</code>，它返回被清除了字谜（anagrams）的数组。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"nap"</span>, <span class="string">"teachers"</span>, <span class="string">"cheaters"</span>, <span class="string">"PAN"</span>, <span class="string">"ear"</span>, <span class="string">"era"</span>, <span class="string">"hectares"</span>];</span><br><span class="line"></span><br><span class="line">alert( aclean(arr) ); <span class="comment">// "nap,teachers,ear" or "PAN,cheaters,era"</span></span><br></pre></td></tr></table></figure>

<p>对于所有的字谜（anagram）组，都应该保留其中一个词，但保留的具体是哪一个并不重要。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aclean</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">  let newArr = [];</span><br><span class="line">  arr.forEach(item =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = item.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">set</span>.has(tmp)) &#123;</span><br><span class="line">      newArr.push(item);</span><br><span class="line">      <span class="keyword">set</span>.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aclean</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="comment">// 将单词 split 成字母，对字母进行排序，之后再 join 回来</span></span><br><span class="line">    <span class="keyword">let</span> sorted = word.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>); <span class="comment">// (*)</span></span><br><span class="line">    map.set(sorted, word);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代键</p>
<p>我们期望使用 <code>map.keys()</code> 得到一个数组，然后使用特定的方法例如 <code>.push</code> 等，对其进行处理。</p>
<p>但是运行不了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">"name"</span>, <span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = map.keys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: keys.push is not a function</span></span><br><span class="line">keys.push(<span class="string">"more"</span>);</span><br></pre></td></tr></table></figure>

<p>为什么？我们应该如何修改代码让 <code>keys.push</code> 工作？</p>
<p><code>map.keys()</code> 返回值是一个可迭代对象，不是数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'John'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Array</span>.from(map.keys());</span><br><span class="line">keys.push(<span class="string">'more'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// ["name", "more"]</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 05</title>
    <url>/2020/11/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-05/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-05"><a href="#学习笔记-2020-11-05" class="headerlink" title="学习笔记 2020-11-05"></a>学习笔记 2020-11-05</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h4 id="软件与硬件检测"><a href="#软件与硬件检测" class="headerlink" title="软件与硬件检测"></a>软件与硬件检测</h4><h5 id="浏览器元数据"><a href="#浏览器元数据" class="headerlink" title="浏览器元数据"></a>浏览器元数据</h5><ol>
<li><p>Geolocation API</p>
<p><code>navigator.geolocation</code> 属性可以让浏览器脚本感知当前设备的地理位置。这个 API 只在安全执行环境中可用。</p>
<p>这个 API  可以查询素数系统并尽可能精确地返回设备的位置信息。根据宿舍系统的硬件和配置，返回结果的精度可能不一样。手机 GPS 的坐标系统可能具有极高的精度，而 IP 地址的精度就要差很多。</p>
<p>要获取浏览器当前的位置，可以使用 <code>getCurrentPosition()</code> 方法。这个方法返回一个 <code>Coordinates</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="params">position</span> =&gt;</span> (p = position));</span><br><span class="line"><span class="built_in">console</span>.log(p.timestamp); <span class="comment">// 1525364883361</span></span><br><span class="line"><span class="built_in">console</span>.log(p.coords); <span class="comment">// Coordinates &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.coords.latitude, p.coords.longitude); <span class="comment">// 37.4854409, -122.2325506 经纬度</span></span><br><span class="line"><span class="built_in">console</span>.log(p.coords.accuracy); <span class="comment">// 58 精度</span></span><br><span class="line"><span class="built_in">console</span>.log(p.coords.altitude); <span class="comment">// -8.800000190734863 海拔高度</span></span><br><span class="line"><span class="built_in">console</span>.log(p.coords.altitudeAccuracy); <span class="comment">// 200</span></span><br><span class="line"><span class="comment">// 浏览器会弹出确认对话框请用户允许访问 Geolocation API</span></span><br><span class="line"><span class="comment">// 这个例子显示了用户拒绝之后的结果</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  () =&gt; &#123;&#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.code); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message); <span class="comment">// User denied Geolocation</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 这个例子展示了在不安全的上下文中执行代码的结果</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  () =&gt; &#123;&#125;,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.code); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message); <span class="comment">// Only secure origins are allowed</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>还可以传入第三个参数，一个 <code>PositionOptions</code> 对象。这个对象支持 3 个属性：</p>
<ul>
<li>enableHighAccuracy: 布尔值，表示是否返回精确的值。</li>
<li>timeout: 毫秒，表示在以 TIMEOUT 状态调用错误回调之前等待的最长时间。</li>
<li>maxmumAge: 毫秒，表示返回坐标的最长有效期。</li>
</ul>
</li>
<li><p>Connection State 和 NetworkInformation API</p>
<p>浏览器会跟踪网络连接状态并以两种方式暴露这些信息：</p>
<ul>
<li>连接事件</li>
<li><code>navigator.onLine</code> 属性。</li>
</ul>
<p>在设备连接到网络时，浏览器会记录这个事实并在 window 对象上触发 onLine 事件。相应地，当设备断开网络连接后，浏览器会在 window 对象上触发 offline 事件。任何时候都可以通过 <code>navigator.onLine</code> 属性来确定浏览器的联网状态。这个属性返回布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connectionStateChange = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(navigator.onLine);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, connectionStateChange);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, connectionStateChange);</span><br><span class="line"><span class="comment">// 设备联网时：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 设备断网时：</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>联网的判定取决于浏览器和系统实现。</p>
<p>navigator 对象还暴露了 NetworkInformation API ，可以通过 <code>navigator.connection</code> 属性使用。这个 API　提供了一些只读属性，并未连接属性变化事件处理程序定义了一个事件对象。</p>
<ul>
<li>downlink：整数，表示当前设备的带宽，以 Mbit/s 为单位。</li>
<li>downlinkMax：整数，表示当前设备最大的下行带宽，根据网络的第一跳来确定。</li>
<li>effectiveType：字符串枚举值，表示连接速度和质量。这个值有以下 4 种可能：<ul>
<li>slow-2g</li>
<li>2g</li>
<li>3g</li>
<li>4g</li>
</ul>
</li>
<li>rtt：毫秒，表示当前网络实际的往返时间。</li>
<li>type：字符串枚举值，表示网络连接技术，可能为下列值：<ul>
<li>bluetooth</li>
<li>cellular</li>
<li>ethernet</li>
<li>none</li>
<li>mixed</li>
<li>other</li>
<li>unknown</li>
<li>wifi</li>
<li>wimax</li>
</ul>
</li>
<li>saveData：布尔值，表示用户设备是否启用了节流模式。</li>
<li>onchange：事件处理程序，会在任何连接状态变化时激发一个 change 事件。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 04</title>
    <url>/2020/11/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-04/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-04"><a href="#学习笔记-2020-11-04" class="headerlink" title="学习笔记 2020-11-04"></a>学习笔记 2020-11-04</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h3><h4 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h4><p>用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个 HTTP 请求的头部，在 JS 中可以通过 <code>navigator.userAgent</code> 访问。</p>
<ul>
<li><code>Firefox</code> 核心是 <code>Gecko</code></li>
<li><code>IE</code> 核心是 <code>Trident</code></li>
<li><code>Safari</code> 核心是 <code>WebKit</code></li>
<li><code>Chrome</code> 核心是 <code>Blink</code></li>
<li><code>Opera</code> 核心是 <code>Presto</code></li>
</ul>
<h4 id="软件与硬件检测"><a href="#软件与硬件检测" class="headerlink" title="软件与硬件检测"></a>软件与硬件检测</h4><h5 id="识别浏览器与操作系统"><a href="#识别浏览器与操作系统" class="headerlink" title="识别浏览器与操作系统"></a>识别浏览器与操作系统</h5><ol>
<li><p><code>navigator.oscpu</code></p>
<p>对应用户代理字符串中操作系统/系统架构相关信息。</p>
</li>
<li><p><code>navigator.vendor</code></p>
<p>包含浏览器开发商信息。</p>
</li>
<li><p><code>navigator.platform</code></p>
<p>表示浏览器所在的操作系统。</p>
</li>
<li><p><code>screen.colorDepth</code> 和 <code>screen.pixelDepth</code></p>
<p>返回一样的值，即显示器每像素颜色的位深，不包含 alpha 通道。</p>
</li>
<li><p><code>screen.orientation</code></p>
<p>返回一个 <code>ScreenOrientation</code> 对象，包含 <code>Screen Orientation API</code> 定义的屏幕信息。</p>
</li>
</ol>
<h5 id="浏览器元数据"><a href="#浏览器元数据" class="headerlink" title="浏览器元数据"></a>浏览器元数据</h5><ol>
<li><p>Geolocation API</p>
<p>可以让浏览器脚本感知当前设备的地理位置。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a><code>Array.from</code></h4><p>这个函数接收一个必选的可迭代对象或类数组对象，接收两个可选的参数，第一个是映射函数，第二个是映射函数的 <code>this</code> 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    current: <span class="keyword">this</span>.from,</span><br><span class="line">    last: <span class="keyword">this</span>.to,</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.current &lt;= <span class="keyword">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, num =&gt; num * num);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 4, 9, 16, 25];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slice</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(str).slice(start, end).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'𝒳😂𩷶'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slice(str, <span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 😂𩷶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 03</title>
    <url>/2020/11/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-03/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-03"><a href="#学习笔记-2020-11-03" class="headerlink" title="学习笔记 2020-11-03"></a>学习笔记 2020-11-03</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h4><p>已经成为客户端标识浏览器的标准。只要浏览器启用 JavaScript， navigator 对象就一定存在。</p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>activeVrDisplays</code></td>
<td>返回数组，包含 ispresenting 属性为 true 的VRDisplay 实例。</td>
</tr>
<tr>
<td><code>appCodeName</code></td>
<td>即使在非 Mozilla 浏览器中也会返回 Mozilla 。</td>
</tr>
<tr>
<td><code>appName</code></td>
<td>浏览器全名。</td>
</tr>
<tr>
<td><code>appVersion</code></td>
<td>浏览器版本。通常与实际的浏览器版本不一致。</td>
</tr>
<tr>
<td><code>battery</code></td>
<td>返回暴露 Battery Status API 的 BatteryManager 对象。</td>
</tr>
<tr>
<td><code>buildId</code></td>
<td>浏览器的构建编号。</td>
</tr>
<tr>
<td><code>connection</code></td>
<td>返回暴露 Network Information API 的 NetworkInformation 对象。</td>
</tr>
<tr>
<td><code>cookieEnabled</code></td>
<td>返回布尔值，表示是否启用了 cookie 。</td>
</tr>
<tr>
<td><code>credentials</code></td>
<td>返回暴露 Credentials Management API 的 CredentialsContainer 对象。</td>
</tr>
<tr>
<td><code>deviceMemory</code></td>
<td>返回单位为 GB 的设备内存容量。</td>
</tr>
<tr>
<td><code>doNotTrack</code></td>
<td>返回用户的 不跟踪 设置。</td>
</tr>
<tr>
<td><code>gelocation</code></td>
<td>返回暴露 Geolocation API 的 Geolocation 对象。</td>
</tr>
<tr>
<td><code>getVRDisplays()</code></td>
<td>返回数组，包含可用的每个 VRDisplay 实例。</td>
</tr>
<tr>
<td><code>getUserMedia()</code></td>
<td>返回与可用媒体设备硬件关联的流。</td>
</tr>
<tr>
<td><code>hardwareConcurrency</code></td>
<td>返回设备的处理器核心数量。</td>
</tr>
<tr>
<td><code>javaEnabled</code></td>
<td>返回布尔值，表示浏览器是否启用了 Java 。</td>
</tr>
<tr>
<td><code>language</code></td>
<td>返回浏览器的主语言。</td>
</tr>
<tr>
<td><code>languages</code></td>
<td>返回浏览器偏好的语言数组。</td>
</tr>
<tr>
<td><code>locks</code></td>
<td>返回暴露 Web Locks API 的 LockManager 对象。</td>
</tr>
<tr>
<td><code>mediaCapabilities</code></td>
<td>返回暴露 Media Capabilities API 的 MediaCapabilities 对象。</td>
</tr>
<tr>
<td><code>mediaDevices</code></td>
<td>返回可用的媒体设备。</td>
</tr>
<tr>
<td><code>maxTouchPoints</code></td>
<td>返回设备触摸屏支持的最大触点数。</td>
</tr>
<tr>
<td><code>mimeTypes</code></td>
<td>返回浏览器中注册的 MIME 类型数组。</td>
</tr>
<tr>
<td><code>onLine</code></td>
<td>返回布尔值，表示浏览器是否联网。</td>
</tr>
<tr>
<td><code>oscpu</code></td>
<td>返回浏览器运行设备的操作系统和 CPU 。</td>
</tr>
<tr>
<td><code>permissions</code></td>
<td>返回暴露 Permissions API 的 Persimissions 对象。</td>
</tr>
<tr>
<td><code>platform</code></td>
<td>抱回浏览器运行的系统平台。</td>
</tr>
<tr>
<td><code>plugins</code></td>
<td>返回浏览器安装的插件数组。在 IE 中，这个数组包含页面中所有 <code>&lt;embed&gt;</code> 元素。</td>
</tr>
<tr>
<td><code>product</code></td>
<td>返回产品名称。</td>
</tr>
<tr>
<td><code>productSub</code></td>
<td>返回产品的额外信息。</td>
</tr>
<tr>
<td><code>registerProtocolHandler()</code></td>
<td>将一个网站注册为特定协议的处理程序。</td>
</tr>
<tr>
<td><code>requestMediaKeySystemAccess()</code></td>
<td>返回一个期约，解决为 MediaKeySystemAccess 对象。</td>
</tr>
<tr>
<td><code>sendBeacon()</code></td>
<td>异步传输一些小数据。</td>
</tr>
<tr>
<td><code>serviceWorker</code></td>
<td>返回用来与 ServiceWorker 实例交互的 ServiceWorkerContainer 。</td>
</tr>
<tr>
<td><code>share()</code></td>
<td>返回当前平台的原生共享机制。</td>
</tr>
<tr>
<td><code>storage</code></td>
<td>返回暴露 Storage API 的 StorageManager 对象。</td>
</tr>
<tr>
<td><code>userAgent</code></td>
<td>返回浏览器的用户代理字符串。</td>
</tr>
<tr>
<td><code>vendor</code></td>
<td>返回浏览器的厂商名称。</td>
</tr>
<tr>
<td><code>vendorSub</code></td>
<td>返回浏览器厂商的更多信息。</td>
</tr>
<tr>
<td><code>vibrate()</code></td>
<td>触发设备振动。</td>
</tr>
<tr>
<td><code>webdriver</code></td>
<td>返回浏览器当前是否被自动化程序控制。</td>
</tr>
</tbody></table>
<ol>
<li><p>检测插件</p>
<p>除 IE10 及更低版本外的浏览器，都可以通过 plugins 数组来检测浏览器是否安装了某个插件。这个数组的每一项都包含：</p>
<ul>
<li>name：插件名称。</li>
<li>description：插件介绍。</li>
<li>filename：插件的文件名。</li>
<li>length：由当前插件处理的 MIME 类型数量。</li>
</ul>
<p>旧版本 IE 中检测插件使用 <code>ActiveXObject</code> 。</p>
</li>
<li><p>注册处理程序</p>
<p>现代浏览器支持 navigator 上的 <code>registerProtocolHandler()</code> 方法。可以把一个网站注册为处理某种特定类型信息用用程序。接收三个参数，要处理的协议、处理该协议的 URL 、以及应用名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.registerProtocolHandler(</span><br><span class="line">  <span class="string">'mailto'</span>,</span><br><span class="line">  <span class="string">'http://www.somemailclient.com?cmd=%s'</span>,</span><br><span class="line">  <span class="string">'Some Mail Client'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h4><p>这个对象中保存的是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>availHeight</code></td>
<td>屏幕像素高度减去系统组件高度( 只读 )</td>
</tr>
<tr>
<td><code>availLeft</code></td>
<td>没有被系统组件占用的屏幕的最左侧像素 ( 只读 )</td>
</tr>
<tr>
<td><code>availTop</code></td>
<td>没有被系统组件占用的屏幕的最顶端像素 ( 只读 )</td>
</tr>
<tr>
<td><code>availWidth</code></td>
<td>屏幕像素宽度减去系统组件宽度  ( 只读 )</td>
</tr>
<tr>
<td><code>colorDepth</code></td>
<td>表示屏幕颜色的位数；多数系统是 32 ( 只读 )</td>
</tr>
<tr>
<td><code>height</code></td>
<td>屏幕像素高度。</td>
</tr>
<tr>
<td><code>left</code></td>
<td>当前屏幕左边的像素距离。</td>
</tr>
<tr>
<td><code>pixelDepth</code></td>
<td>屏幕的位深 ( 只读 )</td>
</tr>
<tr>
<td><code>top</code></td>
<td>当前屏幕顶端的像素距离。</td>
</tr>
<tr>
<td><code>width</code></td>
<td>屏幕像素宽度。</td>
</tr>
<tr>
<td><code>orientation</code></td>
<td>返回 Screen Orientation API 中屏幕的朝向。</td>
</tr>
</tbody></table>
<h4 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h4><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。</p>
<ol>
<li><p>导航</p>
<p><code>go()</code> 方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，可以是一个整数，表示前进或后退多少步。</p>
<p>在旧版本的一些浏览器中，<code>go()</code> 方法的参数也可以是一个字符串，浏览器会导航到历史中包含该字符串的第一个位置或什么也不做。</p>
<p><code>go()</code> 有两个简写方法：<code>back()</code> 和 <code>forward()</code> 。</p>
<p><code>history</code> 对象还有一个 <code>length</code> 属性，表示历史记录中有多个条目。</p>
</li>
<li><p>历史状态管理</p>
<p><code>hashchange</code> 会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。状态管理 API 可以让开发者改变浏览器 URL 而不会加载新页面。可以使用 <code>history.pushState()</code> 方法。接收三个参数，一个 state 对象，一个新状态 的标题和一个可选的相对 URL 。</p>
<p><code>pushState</code> 方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的相对 URL 。浏览器页不会向服务器发送请求。此时单击后退按钮，就会触发 window 对象上的 popstate 事件。popstate 事件的事件对象有一个 state 属性，包含通过 pushState 第一个参数传入的 state 对象。</p>
<p>基于这个状态，应该把页面重置为状态对象所表示的状态。浏览器不会自动做这件事。页面初次加载时没有状态。</p>
<p>可以通过 <code>history.state</code> 获取当前的状态对象，也可以使用 <code>replaceState()</code> 并传入与 <code>pushState()</code> 同样的前两个参数来更新状态。此时只会覆盖当前状态。</p>
<p>传给 <code>pushState()</code> 和 <code>replaceState()</code> 的 state 对象应该只包含可被序列化的信息。因此， DOM 元素之类并不适合放到状态对象里保存。</p>
</li>
</ol>
<h4 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h4><p>因为浏览器实现不一，所以 Web 开发者需要面对跨平台浏览器开发的统一性问题，需要使用各种方法来检测客户端，以实现功能。</p>
<h5 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h5><p>能力检测指在 JS 运行时使用一套简单的逻辑检测，测试浏览器是否支持某种特性。只需要检测自己关心的能力是否存在即可。</p>
<p>例如， IE5 之前的版本没有 <code>document.getElementById()</code> 这个方法，可以通过 <code>document.all</code> 属性实现相同的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.all[id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No way to retrieve element!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>安全能力检测</p>
<p>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。</p>
<p>比如想要检测 <code>sort</code> 方法，不仅仅是检测这个方法是否存在，而是要检测这个属性是不是一个函数。</p>
</li>
<li><p>基于能力检测进行浏览器分析</p>
<p>恰当地使用能力检测可以精准地分析运行代码的浏览器。使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。</p>
<ul>
<li><p>检测特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测浏览器是否支持 Netscape 式的插件</span></span><br><span class="line"><span class="keyword">let</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"><span class="comment">// 检测浏览器是否具有 DOM Level 1 能力</span></span><br><span class="line"><span class="keyword">let</span> hasDOM1 = !!(</span><br><span class="line">  <span class="built_in">document</span>.getElementById &amp;&amp;</span><br><span class="line">  <span class="built_in">document</span>.createElement &amp;&amp;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserDetector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 测试条件编译</span></span><br><span class="line">    <span class="comment">// IE6~10 支持</span></span><br><span class="line">    <span class="keyword">this</span>.isIE_Gte6Lte10 = <span class="comment">/*@cc_on!@*/</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 测试 documentMode</span></span><br><span class="line">    <span class="comment">// IE7~11 支持</span></span><br><span class="line">    <span class="keyword">this</span>.isIE_Gte7Lte11 = !!<span class="built_in">document</span>.documentMode;</span><br><span class="line">    <span class="comment">// 测试 StyleMedia 构造函数</span></span><br><span class="line">    <span class="comment">// Edge 20 及以上版本支持</span></span><br><span class="line">    <span class="keyword">this</span>.isEdge_Gte20 = !!<span class="built_in">window</span>.StyleMedia;</span><br><span class="line">    <span class="comment">// 测试 Firefox 专有扩展安装 API</span></span><br><span class="line">    <span class="comment">// 所有版本的 Firefox 都支持</span></span><br><span class="line">    <span class="keyword">this</span>.isFirefox_Gte1 = <span class="keyword">typeof</span> InstallTrigger !== <span class="string">'undefined'</span>;</span><br><span class="line">    <span class="comment">// 测试 chrome 对象及其 webstore 属性</span></span><br><span class="line">    <span class="comment">// Opera 的某些版本有 window.chrome，但没有 window.chrome.webstore</span></span><br><span class="line">    <span class="comment">// 所有版本的 Chrome 都支持</span></span><br><span class="line">    <span class="keyword">this</span>.isChrome_Gte1 = !!<span class="built_in">window</span>.chrome &amp;&amp; !!<span class="built_in">window</span>.chrome.webstore;</span><br><span class="line">    <span class="comment">// Safari 早期版本会给构造函数的标签符追加"Constructor"字样，如：</span></span><br><span class="line">    <span class="comment">// window.Element.toString(); // [object ElementConstructor]</span></span><br><span class="line">    <span class="comment">// Safari 3~9.1 支持</span></span><br><span class="line">    <span class="keyword">this</span>.isSafari_Gte3Lte9_1 = <span class="regexp">/constructor/i</span>.test(<span class="built_in">window</span>.Element);</span><br><span class="line">    <span class="comment">// 推送通知 API 暴露在 window 对象上</span></span><br><span class="line">    <span class="comment">// 使用默认参数值以避免对 undefined 调用 toString()</span></span><br><span class="line">    <span class="comment">// Safari 7.1 及以上版本支持</span></span><br><span class="line">    <span class="keyword">this</span>.isSafari_Gte7_1 = <span class="function">(<span class="params">(&#123; pushNotification = &#123;&#125; &#125; = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">      pushNotification.toString() == <span class="string">'[object SafariRemoteNotification]'</span>)(<span class="built_in">window</span>.safari);</span><br><span class="line">    <span class="comment">// 测试 addons 属性</span></span><br><span class="line">    <span class="comment">// Opera 20 及以上版本支持</span></span><br><span class="line">    <span class="keyword">this</span>.isOpera_Gte20 = !!<span class="built_in">window</span>.opr &amp;&amp; !!<span class="built_in">window</span>.opr.addons;</span><br><span class="line">  &#125;</span><br><span class="line">  isIE() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isIE_Gte6Lte10 || <span class="keyword">this</span>.isIE_Gte7Lte11;</span><br><span class="line">  &#125;</span><br><span class="line">  isEdge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isEdge_Gte20 &amp;&amp; !<span class="keyword">this</span>.isIE();</span><br><span class="line">  &#125;</span><br><span class="line">  isFirefox() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isFirefox_Gte1;</span><br><span class="line">  &#125;</span><br><span class="line">  isChrome() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isChrome_Gte1;</span><br><span class="line">  &#125;</span><br><span class="line">  isSafari() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isSafari_Gte3Lte9_1 || <span class="keyword">this</span>.isSafari_Gte7_1;</span><br><span class="line">  &#125;</span><br><span class="line">  isOpera() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isOpera_Gte20;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类暴露的通用浏览器检测方法使用了检测浏览器范围的能力测试。随着浏览器的变迁及发展，可以不断调整底层检测逻辑，但主要的 API 可以保持不变。</p>
</li>
<li><p>能力检测的局限</p>
<p>通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。</p>
</li>
</ul>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>将 border-left-width 转换成 borderLeftWidth</p>
<p>编写函数 <code>camelize(str)</code> 将诸如 “my-short-string” 之类的由短划线分隔的单词变成骆驼式的 “myShortString”。</p>
<p>即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">camelize(<span class="string">"background-color"</span>) == <span class="string">'backgroundColor'</span>;</span><br><span class="line">camelize(<span class="string">"list-style-image"</span>) == <span class="string">'listStyleImage'</span>;</span><br><span class="line">camelize(<span class="string">"-webkit-transition"</span>) == <span class="string">'WebkitTransition'</span>;</span><br></pre></td></tr></table></figure>

<p>提示：使用 <code>split</code> 将字符串拆分成数组，对其进行转换之后再 <code>join</code> 回来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">    arr[i] = arr[i][<span class="number">0</span>].toUpperCase() + arr[i].slice(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤范围</p>
<p>写一个函数 <code>filterRange(arr, a, b)</code>，该函数获取一个数组 <code>arr</code>，在其中查找数值大小在 <code>a</code> 和 <code>b</code> 之间的元素，并返回它们的数组。</p>
<p>该函数不应该修改原数组。它应该返回新的数组。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered = filterRange(arr, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">alert( filtered ); <span class="comment">// 3,1（匹配值）</span></span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// 5,3,8,1（未修改）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterRange</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &lt;= b &amp;&amp; item &gt;= a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原位 ( in place ) 过滤范围</p>
<p>写一个函数 <code>filterRangeInPlace(arr, a, b)</code>，该函数获取一个数组 <code>arr</code>，并删除其中介于 <code>a</code> 和 <code>b</code> 区间以外的所有值。检查：<code>a ≤ arr[i] ≤ b</code>。</p>
<p>该函数应该只修改数组。它不应该返回任何东西。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">filterRangeInPlace(arr, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// 删除了范围在 1 到 4 之外的所有值</span></span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// [3, 1]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterRangeInPlace</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; b || item &lt; a) &#123;</span><br><span class="line">      arr.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>降序排列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-10</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……你的代码以降序对其进行排序</span></span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// 8, 5, 2, 1, -10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-10</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 8, 5, 2, 1, -10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制和排序数组</p>
<p>我们有一个字符串数组 <code>arr</code>。我们希望有一个排序过的副本，但保持 <code>arr</code> 不变。</p>
<p>创建一个函数 <code>copySorted(arr)</code> 返回这样一个副本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"HTML"</span>, <span class="string">"JavaScript"</span>, <span class="string">"CSS"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sorted = copySorted(arr);</span><br><span class="line"></span><br><span class="line">alert( sorted ); <span class="comment">// CSS, HTML, JavaScript</span></span><br><span class="line">alert( arr ); <span class="comment">// HTML, JavaScript, CSS (no changes)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copySorted</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item).sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可扩展的 calculator</p>
<p>创建一个构造函数 <code>Calculator</code>，以创建“可扩展”的 calculator 对象。</p>
<p>该任务由两部分组成。</p>
<ol>
<li><p>首先，实现 <code>calculate(str)</code> 方法，该方法接受像 <code>&quot;1 + 2&quot;</code> 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 <code>+</code> 和减号 <code>-</code>。</p>
<p>用法示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> Calculator;</span><br><span class="line"></span><br><span class="line">alert( calc.calculate(<span class="string">"3 + 7"</span>) ); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后添加方法 <code>addMethod(name, func)</code>，该方法教 calculator 进行新操作。它需要运算符 <code>name</code> 和实现它的双参数函数 <code>func(a,b)</code>。</p>
<p>例如，我们添加乘法 <code>*</code>，除法 <code>/</code> 和求幂 <code>**</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> powerCalc = <span class="keyword">new</span> Calculator;</span><br><span class="line">powerCalc.addMethod(<span class="string">"*"</span>, (a, b) =&gt; a * b);</span><br><span class="line">powerCalc.addMethod(<span class="string">"/"</span>, (a, b) =&gt; a / b);</span><br><span class="line">powerCalc.addMethod(<span class="string">"**"</span>, (a, b) =&gt; a ** b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = powerCalc.calculate(<span class="string">"2 ** 3"</span>);</span><br><span class="line">alert( result ); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>此任务中没有括号或复杂的表达式。</li>
<li>数字和运算符之间只有一个空格。</li>
<li>你可以自行选择是否添加错误处理功能。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.method = &#123;</span><br><span class="line">    <span class="string">'+'</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b,</span><br><span class="line">    <span class="string">'-'</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">let</span> op = arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">this</span>.method[op](+arr[<span class="number">0</span>], +arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.addMethod = <span class="function"><span class="keyword">function</span> (<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method[name] = func;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.methods = &#123;</span><br><span class="line">    <span class="string">"-"</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b,</span><br><span class="line">    <span class="string">"+"</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> split = str.split(<span class="string">' '</span>),</span><br><span class="line">      a = +split[<span class="number">0</span>],</span><br><span class="line">      op = split[<span class="number">1</span>],</span><br><span class="line">      b = +split[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.methods[op] || <span class="built_in">isNaN</span>(a) || <span class="built_in">isNaN</span>(b)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.methods[op](a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.addMethod = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.methods[name] = func;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射到 names</p>
<p>你有一个 <code>user</code> 对象数组，每个对象都有 <code>user.name</code>。编写将其转换为 names 数组的代码。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">"Pete"</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">"Mary"</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [ john, pete, mary ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="comment">/* ... your code */</span></span><br><span class="line"></span><br><span class="line">alert( names ); <span class="comment">// John, Pete, Mary</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = users.map(<span class="function"><span class="params">item</span> =&gt;</span> item.name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射到对象</p>
<p>你有一个 <code>user</code> 对象数组，每个对象都有 <code>name</code>，<code>surname</code> 和 <code>id</code>。</p>
<p>编写代码以该数组为基础，创建另一个具有 <code>id</code> 和 <code>fullName</code> 的对象数组，其中 <code>fullName</code> 由 <code>name</code> 和 <code>surname</code> 生成。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">surname</span>: <span class="string">"Smith"</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">"Pete"</span>, <span class="attr">surname</span>: <span class="string">"Hunt"</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">"Mary"</span>, <span class="attr">surname</span>: <span class="string">"Key"</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [ john, pete, mary ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> usersMapped = <span class="comment">/* ... your code ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">usersMapped = [</span></span><br><span class="line"><span class="comment">  &#123; fullName: "John Smith", id: 1 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; fullName: "Pete Hunt", id: 2 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; fullName: "Mary Key", id: 3 &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">alert( usersMapped[<span class="number">0</span>].id ) <span class="comment">// 1</span></span><br><span class="line">alert( usersMapped[<span class="number">0</span>].fullName ) <span class="comment">// John Smith</span></span><br></pre></td></tr></table></figure>

<p>所以，实际上你需要将一个对象数组映射到另一个对象数组。在这儿尝试使用箭头函数 <code>=&gt;</code> 来编写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usersMapped = users.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;</span><br><span class="line">  id: item.id,</span><br><span class="line">  fullName: item.name + <span class="string">' '</span> + item.surname</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>按年龄对用户排序</p>
<p>编写函数 <code>sortByAge(users)</code> 获得对象数组的 <code>age</code> 属性，并根据 <code>age</code> 对这些对象数组进行排序。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">"Pete"</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">"Mary"</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [ pete, john, mary ];</span><br><span class="line"></span><br><span class="line">sortByAge(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now: [john, mary, pete]</span></span><br><span class="line">alert(arr[<span class="number">0</span>].name); <span class="comment">// John</span></span><br><span class="line">alert(arr[<span class="number">1</span>].name); <span class="comment">// Mary</span></span><br><span class="line">alert(arr[<span class="number">2</span>].name); <span class="comment">// Pete</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortByAge</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.age - b.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机排列数组</p>
<p>编写函数 <code>shuffle(array)</code> 来随机排列数组的元素。</p>
<p>多次运行 <code>shuffle</code> 可能导致元素顺序的不同。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">shuffle(arr);</span><br><span class="line"><span class="comment">// arr = [3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">shuffle(arr);</span><br><span class="line"><span class="comment">// arr = [2, 1, 3]</span></span><br><span class="line"></span><br><span class="line">shuffle(arr);</span><br><span class="line"><span class="comment">// arr = [3, 1, 2]</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>所有元素顺序应该具有相等的概率。例如，可以将 <code>[1,2,3]</code> 重新排序为 <code>[1,2,3]</code> 或 <code>[1,3,2]</code> 或 <code>[3,1,2]</code> 等，每种情况的概率相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取平均年龄</p>
<p>编写 <code>getAverageAge(users)</code> 函数，该函数获取一个具有 <code>age</code> 属性的对象数组，并返回平均年龄。</p>
<p>平均值的计算公式是 <code>(age1 + age2 + ... + ageN) / N</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">"Pete"</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">"Mary"</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [ john, pete, mary ];</span><br><span class="line"></span><br><span class="line">alert( getAverageAge(arr) ); <span class="comment">// (25 + 30 + 29) / 3 = 28</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAverageAge</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> prev + item.age, <span class="number">0</span>) / arr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组去重</p>
<p><code>arr</code> 是一个数组。</p>
<p>创建一个函数 <code>unique(arr)</code>，返回去除重复元素后的数组 <code>arr</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* your code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hare"</span>, <span class="string">"Krishna"</span>, <span class="string">"Hare"</span>, <span class="string">"Krishna"</span>,</span><br><span class="line">  <span class="string">"Krishna"</span>, <span class="string">"Krishna"</span>, <span class="string">"Hare"</span>, <span class="string">"Hare"</span>, <span class="string">":-O"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">alert( unique(strings) ); <span class="comment">// Hare, Krishna, :-O</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从数组创建键 ( 值 ) 对象</p>
<p>假设我们收到了一个用户数组，形式为：<code>{id:..., name:..., age... }</code>。</p>
<p>创建一个函数 <code>groupById(arr)</code> 从该数组创建对象，以 <code>id</code> 为键（key），数组项为值。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'john'</span>, <span class="attr">name</span>: <span class="string">"John Smith"</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'ann'</span>, <span class="attr">name</span>: <span class="string">"Ann Smith"</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">'pete'</span>, <span class="attr">name</span>: <span class="string">"Pete Peterson"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> usersById = groupById(users);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 调用函数后，我们应该得到：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usersById = &#123;</span></span><br><span class="line"><span class="comment">  john: &#123;id: 'john', name: "John Smith", age: 20&#125;,</span></span><br><span class="line"><span class="comment">  ann: &#123;id: 'ann', name: "Ann Smith", age: 24&#125;,</span></span><br><span class="line"><span class="comment">  pete: &#123;id: 'pete', name: "Pete Peterson", age: 31&#125;,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>处理服务端数据时，这个函数很有用。</p>
<p>在这个任务里我们假设 <code>id</code> 是唯一的。没有两个具有相同 <code>id</code> 的数组项。</p>
<p>请在解决方案中使用数组的 <code>.reduce</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupById</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.reduce(<span class="function">(<span class="params">obj, item</span>) =&gt;</span> &#123;</span><br><span class="line">    obj[item.id] = item;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 02</title>
    <url>/2020/11/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-02/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-02"><a href="#学习笔记-2020-11-02" class="headerlink" title="学习笔记 2020-11-02"></a>学习笔记 2020-11-02</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><h5 id="导航与打开新窗口"><a href="#导航与打开新窗口" class="headerlink" title="导航与打开新窗口"></a>导航与打开新窗口</h5><p><code>window.open()</code> 方法可以用于导航到指定 URL ，也可以用于打开新浏览器窗口。这个方法接收 4 个参数，要加载的 URL 、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。</p>
<p>如果 <code>window.open()</code> 的第二个参数是一个已经存在的窗口或窗格的名字，则会在对应的窗口或窗格中打开 URL 。</p>
<ol>
<li><p>弹出窗口</p>
<p>如果 <code>window.open()</code> 的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口会带有所有默认的浏览器特性。如果打开的不是新窗口，则忽略第三个参数。</p>
<p>特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>fullscreen</code></td>
<td>yes | no</td>
<td>表示新窗口是否最大化。仅限 IE 支持。</td>
</tr>
<tr>
<td><code>height</code></td>
<td>数值</td>
<td>新窗口高度，不能小于 100 。</td>
</tr>
<tr>
<td><code>left</code></td>
<td>数值</td>
<td>新窗口的 x 轴坐标。这个值不能是负值。</td>
</tr>
<tr>
<td><code>location</code></td>
<td>yes | no</td>
<td>表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为 no 时，地址栏可能隐藏或禁用。</td>
</tr>
<tr>
<td><code>Menubar</code></td>
<td>yes | no</td>
<td>表示是否显示菜单栏，默认为 no 。</td>
</tr>
<tr>
<td><code>resizable</code></td>
<td>yes | no</td>
<td>表示是否可以拖动改变新窗口大小，默认为 no 。</td>
</tr>
<tr>
<td><code>scrollbars</code></td>
<td>yes | no</td>
<td>表示是否可以在内容过长时滚动，默认为 no 。</td>
</tr>
<tr>
<td><code>status</code></td>
<td>yes | no</td>
<td>表示是否显示状态栏，不同浏览器默认值不同。</td>
</tr>
<tr>
<td><code>toolbar</code></td>
<td>yes | no</td>
<td>表示是否显示工具栏，默认为 no 。</td>
</tr>
<tr>
<td><code>top</code></td>
<td>数值</td>
<td>新窗口的 y 轴坐标，这个值不能是负值。</td>
</tr>
<tr>
<td><code>width</code></td>
<td>数值</td>
<td>新窗口的宽度，这个值不能小于 100 。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, </span><br><span class="line"> <span class="string">"wroxWindow"</span>, </span><br><span class="line"> <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br></pre></td></tr></table></figure>

<p><code>window.open()</code> 方法会返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别，只是为控制新窗口提供了方便。</p>
<p>可以使用 <code>close()</code> 方法关闭新打开的窗口。但该方法只能用于使用 <code>window.open()</code> 创建的弹出窗口。</p>
<p>新创建窗口的 <code>window</code> 对象有一个属性 <code>opener</code> ，指向打开它的窗口。窗口不会跟踪记录自己打开的新窗口。</p>
</li>
</ol>
<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>js 是单线程语言，允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。 <code>setTimeout()</code> 用于指定在一定时间后执行某些代码，而 <code>setInterval()</code> 用于指定每隔一段时间执行某些代码。</p>
<p>定时器会返回一个表示该超时排期的数值 ID 。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。</p>
<p>所有超时执行的代码都会在全局作用域中的一个匿名函数中运行，因此函数中的 <code>this</code> 在非严格模式下始终指向 window，而在严格模式下是 undefined 。</p>
<p>第二个参数的间隔时间指的是向队列添加新任务前等待的时间，而不在乎何时执行也不在乎执行的时长。</p>
<h5 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h5><ol>
<li><code>alert()</code></li>
<li><code>confirm()</code> 返回值为 true 或 false 。</li>
<li><code>prompt()</code> 返回值为 用户点击确定 ? 文本框内的值 : <code>null</code> 。</li>
<li><code>find()</code> 查找的异步对话框。</li>
<li><code>print()</code> 打引的异步对话框。</li>
</ol>
<h4 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h4><p>location 提供了当前窗口中加载文档的信息以及通常的导航功能。它既是 window 的属性，也是 document 的属性。 location 对象不仅保存着当前加载文档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息。</p>
<p>以 <code>http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</code> 为例。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>location.hash</code></td>
<td><code>#contents</code></td>
<td>URL 散列值( 井号后跟零或多个字符 )，如果没有则为空字符串。</td>
</tr>
<tr>
<td><code>location.host</code></td>
<td><code>www.wrox.com:80</code></td>
<td>服务器名及端口号</td>
</tr>
<tr>
<td><code>location.hostname</code></td>
<td><code>www.wrox.com</code></td>
<td>服务器名</td>
</tr>
<tr>
<td><code>location.href</code></td>
<td><code>http://www.wrox.com:80/WileyCDA/?q=javascript#contents</code></td>
<td>当前加载页面的完整 URL。 location 的 toString() 方法返回这个值。</td>
</tr>
<tr>
<td><code>location.pathname</code></td>
<td><code>/WileyCDA</code></td>
<td>URL 中的路径和文件名。</td>
</tr>
<tr>
<td><code>location.port</code></td>
<td><code>80</code></td>
<td>请求的端口。如果 URL 中没有端口，则返回空字符串。</td>
</tr>
<tr>
<td><code>location.protocol</code></td>
<td><code>http:</code></td>
<td>页面使用的协议。通常是 <code>http:</code> 或 <code>https:</code> 。</td>
</tr>
<tr>
<td><code>location.search</code></td>
<td><code>?q=javascript</code></td>
<td>URL 的查询字符串。这个字符串以问号开头。</td>
</tr>
<tr>
<td><code>location.username</code></td>
<td><code>foouser</code></td>
<td>域名前指定的用户名。</td>
</tr>
<tr>
<td><code>location.password</code></td>
<td><code>barpassword</code></td>
<td>域名前指定的密码。</td>
</tr>
<tr>
<td><code>location.origin</code></td>
<td><code>http://www.wrox.com</code></td>
<td>URL 的源地址。只读。</td>
</tr>
</tbody></table>
<h5 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = <span class="string">'?q=javascript&amp;num=10'</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> URLSearchParams(qs);</span><br><span class="line"><span class="built_in">console</span>.log(searchParams.toString()); <span class="comment">// " q=javascript&amp;num=10"</span></span><br><span class="line">searchParams.has(<span class="string">'num'</span>); <span class="comment">// true</span></span><br><span class="line">searchParams.get(<span class="string">'num'</span>); <span class="comment">// 10</span></span><br><span class="line">searchParams.set(<span class="string">'page'</span>, <span class="string">'3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(searchParams.toString()); <span class="comment">// " q=javascript&amp;num=10&amp;page=3"</span></span><br><span class="line">searchParams.delete(<span class="string">'q'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(searchParams.toString()); <span class="comment">// " num=10&amp;page=3"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> param <span class="keyword">of</span> searchParams) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["num", "10"]</span></span><br><span class="line"><span class="comment">// ["page", "3"]</span></span><br></pre></td></tr></table></figure>

<h5 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h5><p>可以使用 <code>assign()</code> 方法来修改浏览器的地址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure>

<p>该操作会在浏览器历史记录中增加一条记录。直接修改 <code>location.href</code> 或是 <code>window.location</code> 设置 URL ，都会调用 <code>assign()</code> 方法。</p>
<p>除了 <code>hash</code> 之外，修改 <code>location</code> 的一个属性，都会导致页面重新加载新 URL 。</p>
<p><code>location.replace()</code> 方法不会增加历史记录。</p>
<p><code>location.reload()</code> 方法会重新加载当前显示的页面。给这个方法传入参数 <code>true</code> 可以使得网页重新从服务器加载。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>数组被拷贝了吗？</p>
<p>下面的代码将会显示什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">"Apples"</span>, <span class="string">"Pear"</span>, <span class="string">"Orange"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在“副本”里 push 了一个新的值</span></span><br><span class="line"><span class="keyword">let</span> shoppingCart = fruits;</span><br><span class="line">shoppingCart.push(<span class="string">"Banana"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fruits 里面是什么？</span></span><br><span class="line">alert( fruits.length ); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>数组的赋值是引用赋值，所以输出是 4 。</p>
</li>
<li><p>数组操作</p>
<p>我们试试下面的 5 个数组操作。</p>
<ol>
<li>创建一个数组 <code>styles</code>，里面存储有 “Jazz” 和 “Blues”。</li>
<li>将 “Rock-n-Roll” 从数组末端添加进去。</li>
<li>用 “Classics” 替换掉数组最中间的元素。查找数组最中间的元素的代码应该适用于任何奇数长度的数组。</li>
<li>去掉数组的第一个值并显示它。</li>
<li>在数组前面添加 <code>Rap</code> 和 <code>Reggae</code>。</li>
</ol>
<p>过程中的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Jazz, Blues</span><br><span class="line">Jazz, Bues, Rock-n-Roll</span><br><span class="line">Jazz, Classics, Rock-n-Roll</span><br><span class="line">Classics, Rock-n-Roll</span><br><span class="line">Rap, Reggae, Classics, Rock-n-Roll。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> styles = [<span class="string">'Jazz'</span>, <span class="string">'Blues'</span>];</span><br><span class="line">styles.push(<span class="string">'Rock-n-Roll'</span>);</span><br><span class="line">styles[<span class="built_in">Math</span>.floor((styles.length - <span class="number">1</span>) / <span class="number">2</span>)] = <span class="string">'Classics'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(styles.shift());</span><br><span class="line">styles.unshift(<span class="string">'Rap'</span>, <span class="string">'Reggae'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数组上下文调用</p>
<p>结果是什么？为什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line"></span><br><span class="line">arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="keyword">this</span> );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>数组对象。获取该函数的形式类似于对象的方法引用，然后调用方法。</p>
</li>
<li><p>输入数字求和</p>
<p>写出函数 <code>sumInput()</code>，要求如下：</p>
<ul>
<li>使用 <code>prompt</code> 向用户索要值，并存在数组中。</li>
<li>当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。</li>
<li>计算并返回数组所有项之和。</li>
</ul>
<p>P.S. <code>0</code> 是有效的数字，不要因为是 0 就停止问询。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> numbers = [];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = prompt(<span class="string">"A number please?"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 应该结束了吗？</span></span><br><span class="line">    <span class="keyword">if</span> (value === <span class="string">""</span> || value === <span class="literal">null</span> || !<span class="built_in">isFinite</span>(value)) <span class="keyword">break</span>;</span><br><span class="line">    numbers.push(+value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">alert( sumInput() );</span><br></pre></td></tr></table></figure>
</li>
<li><p>最大子数组</p>
<p>输入是以数字组成的数组，例如 <code>arr = [1, -2, 3, 4, -9, 6]</code>.</p>
<p>任务是：找出所有项的和最大的 <code>arr</code> 数组的连续子数组。</p>
<p>写出函数 <code>getMaxSubSum(arr)</code>，用其找出并返回最大和。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getMaxSubSum([<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>]) == <span class="number">5</span>（高亮项的加和）</span><br><span class="line">getMaxSubSum([<span class="number">2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>]) == <span class="number">6</span></span><br><span class="line">getMaxSubSum([<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>, <span class="number">11</span>]) == <span class="number">11</span></span><br><span class="line">getMaxSubSum([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>]) == <span class="number">3</span></span><br><span class="line">getMaxSubSum([<span class="number">100</span>, <span class="number">-9</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">5</span>]) == <span class="number">100</span></span><br><span class="line">getMaxSubSum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">6</span>（所有项的和）</span><br></pre></td></tr></table></figure>

<p>如果所有项都是负数，那就一个项也不取（子数组是空的），所以返回的是 0：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getMaxSubSum([<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>]) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>请尝试想出一个快速的解决方案：复杂度可以是 <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener">O(n2)</a>，有能力达到 O(n) 则更好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxSubSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = arr.slice(i, j);</span><br><span class="line">      <span class="keyword">let</span> sum = tmp.reduce(<span class="function">(<span class="params">item, prev</span>) =&gt;</span> prev + item);</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; result) result = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxSubSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    tmp += item;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; result) result = tmp;</span><br><span class="line">    <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 11 01</title>
    <url>/2020/11/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-11-01/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-11-01"><a href="#学习笔记-2020-11-01" class="headerlink" title="学习笔记 2020-11-01"></a>学习笔记 2020-11-01</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h3><h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><h5 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h5><ol>
<li><p>实现 sleep()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - t0);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 1502</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用平行执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">await</span> randomDelay(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure>

<p>就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序。</p>
<p>如果顺序不是必须保证的，那么可以先一次性初始化所有期约，再分别等待它们的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">      resolve(id);</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>)</span><br><span class="line">    .fill(<span class="literal">null</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`awaited <span class="subst">$&#123;<span class="keyword">await</span> p&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// awaited 0</span></span><br><span class="line"><span class="comment">// awaited 1</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// awaited 2</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// awaited 3</span></span><br><span class="line"><span class="comment">// awaited 4</span></span><br><span class="line"><span class="comment">// 964ms elapsed</span></span><br></pre></td></tr></table></figure>

<p>期约没有按顺序执行，但 await 按顺序收到了每个期约的值。</p>
</li>
<li><p>串行执行期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> fn(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<p>此处 await 传递了每个函数的返回值。</p>
</li>
<li><p>栈追踪与内存管理</p>
<p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(reject, <span class="number">1000</span>, <span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// setTimeout (async)</span></span><br><span class="line"><span class="comment">// fooPromiseExecutor</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>这是拒绝期约的栈追踪信息。</p>
<p>JS 引擎在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(reject, <span class="number">1000</span>, <span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// async function (async)</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><p>BOM 的核心是 window 对象，表示浏览器的实例。window 对象是 ECMAScript 中的 Global 对象，也是浏览器窗口的 JavaScript 接口。</p>
<h5 id="Global-作用域"><a href="#Global-作用域" class="headerlink" title="Global 作用域"></a>Global 作用域</h5><p>通过 <code>var</code> 声明的所有全局变量和函数都会变成 window 对象的属性和方法。</p>
<p>访问未声明的变量会抛出错误，但是可以在 window 对象上查询是否存在可能未声明的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这会导致抛出错误，因为 oldValue 没有声明</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue;</span><br><span class="line"><span class="comment">// 这不会抛出错误，因为这里是属性查询</span></span><br><span class="line"><span class="comment">// newValue 会被设置为 undefined</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;</span><br></pre></td></tr></table></figure>

<h5 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h5><p>top 对象始终指向最上层窗口，即浏览器窗口本身。parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top 等于 window 。最上层的 window 如果不是通过 <code>window.open</code> 打开的，那么其 name 属性就不会包含值。</p>
<p>self 对象始终指向 window 。实际上，self 和 window 就是同一个对象。</p>
<p>这些都是 window 对象的属性。</p>
<h5 id="窗口位置与像素比"><a href="#窗口位置与像素比" class="headerlink" title="窗口位置与像素比"></a>窗口位置与像素比</h5><p>window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 <code>screenLeft</code> 和 <code>screenTop</code> 属性，用于表示窗口相对于屏幕左侧和顶部的位置。</p>
<p>可以使用 <code>moveTo()</code> 和 <code>moveBy()</code> 方法移动窗口。<code>moveTo</code> 接收要移动到的新位置的绝对坐标 x 和 y 。<code>moveBy</code> 接收相对当前位置在两个方向上移动的像素数。</p>
<p>CSS 像素是 Web 开发中使用的统一像素单位。这个单位的背后是一个角度：<code>0.0213°</code> 。如果屏幕距离人眼是一臂长，则以这个角度计算的 CSS 像素大小约为 1/96 英寸。这样定义像素大小是为了在不同设备上统一标准。不同像素密度的屏幕下会有不同的缩放系数，以便把物理像素( 屏幕实际的分辨率 )转换为 CSS 像素( 浏览器报告的虚拟分辨率 )。</p>
<p>手机屏幕的物理分辨率可能是 1920x1080 。但因为其像素可能非常小，所以浏览器就需要把其分辨率降为较低的逻辑分辨率，比如 640x320 。这个物理像素与 CSS 像素之间的转换比率由 <code>window.devicePixelRatio</code> 属性提供。对于前面的例子，该属性的值就是 3 。于是，12 像素( CSS 像素)就会用 36 像素的物理像素来显示。</p>
<p><code>window.devicePixelRatio</code> 实际上与每英寸像素数( DPI )是对应的。 DPI 表示单位像素密度，而 <code>window.devicePixelRatio</code> 表示物理像素与逻辑像素之间的缩放系数。</p>
<h5 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h5><p>所有现代浏览器都支持 4 个属性：</p>
<ul>
<li><code>innerWidth</code></li>
<li><code>innerHeight</code></li>
<li><code>outerWidth</code></li>
<li><code>outerHeight</code></li>
</ul>
<p><code>outerWidth</code> 和 <code>outerHeight</code> 返回浏览器窗口自身的大小。( 不管是在最外层 window 上使用，还是在窗格 <code>&lt;frame&gt;</code> 中使用 )。</p>
<p><code>innerWidth</code> 和 <code>innerHeight</code> 返回浏览器窗口中页面视口的大小( 不包含浏览器边框和工具栏 )。</p>
<p><code>document.documentElement.clientWidth</code> 和 <code>document.documentElement.clientHeight</code> 返回页面视口的宽度和高度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">  pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">'number'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查是否存在 <code>inner</code> 属性，不存在的话，检查页面是否处于标准模式，是的话使用 <code>documentElement</code> 的 <code>client</code> 属性，否则使用 <code>body</code> 的 <code>client</code> 属性。</p>
<p>可以使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法调整窗口大小。<code>resizeTo()</code> 接收新的宽度和高度值，<code>resizeBy()</code> 接收缩放比例。</p>
<h5 id="视口位置"><a href="#视口位置" class="headerlink" title="视口位置"></a>视口位置</h5><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值。</p>
<ul>
<li><code>window.pageXoffset/window.scrollX</code></li>
<li><code>window.pageYoffset/window.scrollY</code></li>
</ul>
<p>可以使用 <code>scroll()</code> 、<code>scrollTo()</code> 和 <code>scrollBy()</code> 方法滚动页面。三个方法都接收表示相对视口距离的 x 和 y 坐标。前两个方法中表示要滚动到的坐标，最后一个方法表示滚动的距离。</p>
<p>这几个方法也都接收一个 <code>ScrollToOptions</code> 字典，除了提供偏移值，还可以通过 <code>behavior</code> 属性告诉浏览器是否平滑滚动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常滚动 </span></span><br><span class="line"><span class="built_in">window</span>.scrollTo(&#123; </span><br><span class="line"> left: <span class="number">100</span>, </span><br><span class="line"> top: <span class="number">100</span>, </span><br><span class="line"> behavior: <span class="string">'auto'</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 平滑滚动</span></span><br><span class="line"><span class="built_in">window</span>.scrollTo(&#123; </span><br><span class="line"> left: <span class="number">100</span>, </span><br><span class="line"> top: <span class="number">100</span>, </span><br><span class="line"> behavior: <span class="string">'smooth'</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串的内部格式始终是 <code>UTF-16</code> 。它不依赖于页面编码。</p>
<p>反引号允许我们在第一个反引号之前指定一个<strong>模板函数</strong> 。</p>
<p>语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func<span class="string">`string`</span></span><br></pre></td></tr></table></figure>

<p>函数 <code>func</code> 被自动调用，接收字符串和嵌入式表达式，并处理它们。</p>
<p>访问字符的方法有方括号和调用 <code>str.charAt(pos)</code> 。区别是，没有找到时，方括号返回 <code>undefined</code> ，而函数调用返回一个空字符串。</p>
<p>字符串也可以使用 <code>for-of</code> 遍历。</p>
<p>查找子字符串的方法：</p>
<ul>
<li><p><code>str.indexOf(substr, ?pos)</code> ，从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code> 。</p>
</li>
<li><p><code>str.lastIndexOf(substr, pos)</code> </p>
<blockquote>
<p>旧代码中会使用 <code>if (~str.indexOf(...))</code> 来判断是否存在。因为 <code>~</code> 符号对数字转换成 32-bit 整数，然后按位取反。所以 n 会转化为 -(n+1) 。计算机中负数以补码形式存在，如 1 的 32-bit 取反后正好是 -2 的补码形式。</p>
</blockquote>
</li>
<li><p><code>str.includes(substr, pos)</code></p>
</li>
<li><p><code>str.startsWith</code></p>
</li>
<li><p><code>str.endsWith</code></p>
</li>
</ul>
<p>获取子字符串的方法：</p>
<ul>
<li><code>slice(start, ?end)</code> ，返回从 start 开始到但不包含的 end 的部分。支持负参数，表示从末尾开始。</li>
<li><code>substring(start, ?end)</code> ，返回字符串在 start 和 end 之间的部分，允许 start 大于 end 。不支持负参数。所有负参数被视为 0 。</li>
<li><code>substr(start, ?length)</code> ，返回从 start 开始的给定 length 部分。支持负参数。</li>
</ul>
<p>比较字符串：</p>
<ul>
<li><code>str.codePointAt(pos)</code> 返回在 <code>pos</code> 位置的字符代码。</li>
<li><code>str.charCodeAt(pos)</code></li>
<li><code>str.fromCodePoint(code)</code> 通过 <code>code</code> 创建字符。</li>
<li><code>str.fromCharCode(code)</code></li>
<li><code>str.localeCompare(str2)</code> 会根据语言规则返回一个整数，若 <code>str</code> 小于 <code>str2</code> 则返回负数，若 <code>str</code> 大于 <code>str2</code> 正数，如果相等则返回 <code>0</code> 。该方法还可以指定语言并设置区别大小之类的附加规则。</li>
</ul>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>首字母大写</p>
<p>写一个函数 <code>ucFirst(str)</code>，并返回首字母大写的字符串 <code>str</code>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ucFirst(<span class="string">"john"</span>) == <span class="string">"John"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ucFirst</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> str;</span><br><span class="line">  <span class="keyword">return</span> str[<span class="number">0</span>].toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 spam</p>
<p>写一个函数 <code>checkSpam(str)</code>，如果 <code>str</code> 包含 <code>viagra</code> 或 <code>XXX</code> 就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>函数必须不区分大小写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkSpam(<span class="string">'buy ViAgRA now'</span>) == <span class="literal">true</span></span><br><span class="line">checkSpam(<span class="string">'free xxxxx'</span>) == <span class="literal">true</span></span><br><span class="line">checkSpam(<span class="string">"innocent rabbit"</span>) == <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSpam</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.toLowerCase().includes(<span class="string">'viagra'</span>) || str.toUpperCase().includes(<span class="string">'XXX'</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>截断文本</p>
<p>创建函数 <code>truncate(str, maxlength)</code> 来检查 <code>str</code> 的长度，如果超过 <code>maxlength</code> —— 应使用 <code>&quot;…&quot;</code> 来代替 <code>str</code> 的结尾部分，长度仍然等于 <code>maxlength</code>。</p>
<p>函数的结果应该是截断后的文本（如果需要的话）。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truncate(<span class="string">"What I'd like to tell on this topic is:"</span>, <span class="number">20</span>) = <span class="string">"What I'd like to te…"</span></span><br><span class="line"></span><br><span class="line">truncate(<span class="string">"Hi everyone!"</span>, <span class="number">20</span>) = <span class="string">"Hi everyone!"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">str, maxlength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length &gt; maxlength) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>, maxlength - <span class="number">1</span>) + <span class="string">'…'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取货币</p>
<p>我们有以 <code>&quot;$120&quot;</code> 这样的格式表示的花销。意味着：先是美元符号，然后才是数值。</p>
<p>创建函数 <code>extractCurrencyValue(str)</code> 从字符串中提取数值并返回。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( extractCurrencyValue(<span class="string">'$120'</span>) === <span class="number">120</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractCurrencyValue</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +str.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 31</title>
    <url>/2020/10/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-31/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-31"><a href="#学习笔记-2020-10-31" class="headerlink" title="学习笔记 2020-10-31"></a>学习笔记 2020-10-31</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h3><h4 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h4><h5 id="期约拓展"><a href="#期约拓展" class="headerlink" title="期约拓展"></a>期约拓展</h5><ol>
<li><p>期约取消</p>
<p>ECMAScript 规范未曾涉及期约取消这个特性。</p>
<p>我们可以通过在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cancelFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      cancelFn(resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"cancel"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">constructor</span>(cancelFn) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        cancelFn(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'delay cancelled'</span>);</span></span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> startButton = <span class="built_in">document</span>.querySelector(<span class="string">'#start'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cancelButton = <span class="built_in">document</span>.querySelector(<span class="string">'#cancel'</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">cancellableDelayedResolve</span><span class="params">(delay)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'set delay'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'delayed resolve'</span>);</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;, delay);</span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">cancelCallback</span> =&gt;</span></span></span><br><span class="line"><span class="actionscript">        cancelButton.addEventListener(<span class="string">'click'</span>, cancelCallback)</span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      cancelToken.promise.then(<span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(id));</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  startButton.addEventListener(<span class="string">'click'</span>, () =&gt; cancellableDelayedResolve(<span class="number">1000</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>期约进度通知</p>
<p>ECMAScript6 期约不支持进度追踪，可以通过扩展来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">    <span class="keyword">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executor(resolve, reject, status =&gt; &#123;</span><br><span class="line">        notifyHandlers.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(status));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  notify(notifyHandler) &#123;</span><br><span class="line">    <span class="keyword">this</span>.notifyHandlers.push(notifyHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><p>异步函数也称为 <code>async/await</code> 语法关键字，是 ES6 期约模式在 ECMAScript 函数中的应用。 async/await 是 ES8 规范新增的。</p>
<ol>
<li><p>async</p>
<p>该关键字用于声明异步函数。可以用在函数声明、函数表达式、箭头函数和方法上。</p>
<p>使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。</p>
<p>异步函数如果使用 <code>return</code> 关键字返回值，会被 <code>Promise.resolve()</code> 包装成一个期约对象。</p>
<p>在异步函数中抛出错误会返回拒绝的期约。</p>
<p>拒绝期约的错误不会被异步函数捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>await</p>
<p>使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>await 关键字会暂停执行异步函数后面的代码，让出 JS 运行时的执行线程。await 关键字尝试解包对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p>
<p>await 期待一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来解包。否则，将这个值当作已经解决的期约。</p>
</li>
</ol>
<h5 id="停止和恢复执行"><a href="#停止和恢复执行" class="headerlink" title="停止和恢复执行"></a>停止和恢复执行</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">6</span>)));</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>await 后面的值可用时会被添加到消息队列，等到同步线程执行完毕才会执行.</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><p>数字调用 toString 方法时需要使用两个点，防止识别为小数点。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>来自访问者的数字的总和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = +prompt(<span class="string">'first number'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> second = +prompt(<span class="string">'second number'</span>, <span class="number">0</span>);</span><br><span class="line">alert(first + second);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么 6.35.toFixed(1) == 6.3?</p>
<p>根据文档，<code>Math.round</code> 和 <code>toFixed</code> 都将数字舍入到最接近的数字：<code>0..4</code> 会被舍去，而 <code>5..9</code> 会进一位。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">1.35</span>.toFixed(<span class="number">1</span>) ); <span class="comment">// 1.4</span></span><br></pre></td></tr></table></figure>

<p>在下面这个类似的示例中，为什么 <code>6.35</code> 被舍入为 <code>6.3</code> 而不是 <code>6.4</code>？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">6.35</span>.toFixed(<span class="number">1</span>) ); <span class="comment">// 6.3</span></span><br></pre></td></tr></table></figure>

<p>如何以正确的方式来对 <code>6.35</code> 进行舍入？</p>
<p>在内部，<code>6.35</code> 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。</p>
<p>让我们来看看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">6.35</span>.toFixed(<span class="number">20</span>) ); <span class="comment">// 6.34999999999999964473</span></span><br></pre></td></tr></table></figure>

<p>精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。</p>
<p>那么 <code>1.35</code> 会怎样呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">1.35</span>.toFixed(<span class="number">20</span>) ); <span class="comment">// 1.35000000000000008882</span></span><br></pre></td></tr></table></figure>

<p>在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。</p>
<p><strong>如果我们希望以正确的方式进行舍入，我们应该如何解决 <code>6.35</code> 的舍入问题呢？</strong></p>
<p>在进行舍入前，我们应该使其更接近整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( (<span class="number">6.35</span> * <span class="number">10</span>).toFixed(<span class="number">20</span>) ); <span class="comment">// 63.50000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>63.5</code> 完全没有精度损失。这是因为小数部分 <code>0.5</code> 实际上是 <code>1/2</code>。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="built_in">Math</span>.round(<span class="number">6.35</span> * <span class="number">10</span>) / <span class="number">10</span>); <span class="comment">// 6.35 -&gt; 63.5 -&gt; 64(rounded) -&gt; 6.4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重复，直到输入的是一个数字</p>
<p>创建一个函数 <code>readNumber</code>，它提示输入一个数字，直到访问者输入一个有效的数字为止。</p>
<p>结果值必须以数字形式返回。</p>
<p>访问者也可以通过输入空行或点击“取消”来停止该过程。在这种情况下，函数应该返回 <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> input = prompt(<span class="string">'input'</span>, <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">if</span> (input === <span class="literal">null</span> || input.trim() === <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(input))) &#123;</span><br><span class="line">    input = prompt(<span class="string">'input'</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (input === <span class="literal">null</span> || input.trim() === <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考解决方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    num = prompt(<span class="string">"Enter a number please?"</span>, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">while</span> ( !<span class="built_in">isFinite</span>(num) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (num === <span class="literal">null</span> || num === <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> +num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`Read: <span class="subst">$&#123;readNumber()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>该解决方案有点复杂，因为我们需要处理 null 和空行。</p>
<p>所以，我们实际上接受输入，直到输入的是一个“常规数字”。null（取消）和空行都符合该条件，因为在数字形式中它们是 0。</p>
<p>在我们停止之后，我们需要专门处理 null 和空行（返回 null），因为将它们转换为数字将返回 0。</p>
</li>
<li><p>一个偶发的无限循环</p>
<p>这是一个无限循环。它永远不会结束。为什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 0.2 累加永远不会等于10。</p>
</li>
<li><p>从 min 到 max 的随机数</p>
<p>内建函数 <code>Math.random()</code> 会创建一个在 <code>0</code> 到 <code>1</code> 之间（不包括 <code>1</code>）的随机数。</p>
<p>编写一个 <code>random(min, max)</code> 函数，用以生成一个在 <code>min</code> 到 <code>max</code> 之间的随机浮点数（不包括 <code>max</code>)）。</p>
<p>运行示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( random(<span class="number">1</span>, <span class="number">5</span>) ); <span class="comment">// 1.2345623452</span></span><br><span class="line">alert( random(<span class="number">1</span>, <span class="number">5</span>) ); <span class="comment">// 3.7894332423</span></span><br><span class="line">alert( random(<span class="number">1</span>, <span class="number">5</span>) ); <span class="comment">// 4.3435234525</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 30</title>
    <url>/2020/10/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-30/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-30"><a href="#学习笔记-2020-10-30" class="headerlink" title="学习笔记 2020-10-30"></a>学习笔记 2020-10-30</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h3><h4 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h4><h5 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h5><ol>
<li><p>非重入期约方法</p>
<p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。添加在这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。在一个期约上调用 then() 会把 onResolved 处理程序推进消息队列。但这个程序程序在当前线程上的同步代码执行完成前不会执行。</p>
</li>
<li><p>邻近处理程序的执行顺序</p>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照它们的顺序依次执行。</p>
</li>
<li><p>拒绝期约与拒绝错误处理</p>
<p>在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。</p>
<p>在期约中抛出错误时，错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令。</p>
</li>
</ol>
<h5 id="期约连锁与期约合成"><a href="#期约连锁与期约合成" class="headerlink" title="期约连锁与期约合成"></a>期约连锁与期约合成</h5><ol>
<li><p>期约连锁</p>
<p>因为每个期约实例的方法都会返回一个新的期约对象，所以方法可以链式调用。</p>
</li>
<li><p>期约图</p>
<p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。</p>
</li>
<li><p>Promise.all() 和 Promise.race()</p>
<p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法。</p>
<ul>
<li><p>Promise.all()</p>
<p>该方法创建的期约会在一组期约全部解决之后再解决。接收一个可迭代对象。合成的期约只会在每个包含的期约都解决之后才解决。</p>
<p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝。</p>
<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序。</p>
<p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。</p>
</li>
<li><p>Promise.race()</p>
<p>该方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。接收一个可迭代对象。</p>
<p>该方法内部第一个落定的期约，无论是解决还是拒绝，该方法都会包装其解决值或是拒绝理由并返回新期约。</p>
</li>
</ul>
</li>
<li><p>串行期约合成</p>
<p>基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。类似于函数合成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addFive(addTwo(addThree(x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addTen(<span class="number">7</span>)); <span class="comment">// 17</span></span><br></pre></td></tr></table></figure>

<p>期约也可以类似合成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x).then(addTwo).then(addThree).then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [addTwo, addThree, addFive].reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">x</span> =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addTen = compose(addTwo, addThree, addFive);</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 29</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-29/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-29"><a href="#学习笔记-2020-10-29" class="headerlink" title="学习笔记 2020-10-29"></a>学习笔记 2020-10-29</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h3><h4 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h4><p>ECMAScript 6 增加了对 <code>Promises/A+</code> 规范的完善支持，即 <code>Promise</code> 类型。</p>
<p>创建 Promise  时需要传入执行器 ( executor ) 函数作为参数。</p>
<h5 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h5><ol>
<li><p>期约状态机</p>
<p>在把一个期约实例传给 console.log() 时，控制台输出表明该实例处于待定状态。期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<ul>
<li>待定 ( pending )</li>
<li>兑现 ( fulfilled ，有时候也成为 解决 ， resolved )</li>
<li>拒绝 ( rejected )</li>
</ul>
<p>待定是期约的最初始状态。在待定状态下，期约可以落定( settled )为代表成功的兑现状态，或者代表失败的拒绝状态。落定的行为是不可逆的。落定后，契约的状态不再改变。期约也可能永远处于待定状态。</p>
<p>期约的状态是私有的，无法直接通过 JavaScript 检测到。为了避免根据读取到的期约状态，以同步方式处理期约对象。期约的状态也不能被外部 JavaScript 代码修改。</p>
</li>
<li><p>解决值、拒绝理由及期约用例</p>
<p>期约有两大用途。</p>
<p>首先是抽象地表示一个异步操作。根据期约的状态可以得知一段异步代码是否已经完成。</p>
<p>在另外一些情况下，期约封装的异步操作会实际生成某个值。程序可以根据期约状态改变来访问这个值或是拒绝理由。</p>
<p>每个期约只要状态切换为兑现，就会有一个私有的内部值。只要状态切换为拒绝，就会有一个私有的内部理由。二者都是可选的，默认值为 <code>undefined</code> 。期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p>
</li>
<li><p>通过执行函数控制期约状态</p>
<p>期约的状态是私有的，在执行器函数内部进行操作。</p>
<p>执行器函数有两项职责：</p>
<ul>
<li>初始化期约的异步行为。</li>
<li>控制状态的最终转换。</li>
</ul>
<p>控制期约状态的转换是通过调用它的两个函数参数实现的。即 <code>resolve()</code> 和 <code>reject()</code> 。调用前者会把状态切换为兑现，调用后者会把状态切换为拒绝。</p>
</li>
<li><p><code>Promise.resolve()</code></p>
<p>可以通过调用 Promise.resolve() 静态方法实例化一个解决的期约。这个解决的期约的值对应着传入的第一个参数，其余参数会被忽略。这个方法可以包装任何非期约值，包括错误对象，将其转换为解决的期约。</p>
</li>
<li><p><code>Promise.reject()</code></p>
<p>Promise.reject() 会实例化一个拒绝的期约并抛出一个异步错误。这个错误只能通过拒绝处理程序捕获。</p>
<p>Promise.resolve() 会接收期约参数的值来作为返回值的值。但 Promise.reject 不会把期约参数的值来传递，而是直接把这个期约对象作为拒绝的理由。</p>
</li>
<li><p>同步/异步执行的二元性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'foo'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'bar'</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure>

<p>此处期约抛出的错误无法被同步代码所捕获。因为期约对象需要通过异步模式捕获错误。期约是同步对象，但是异步执行模式的媒介。</p>
<p>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此只能使用异步结构与之交互。</p>
</li>
</ol>
<h5 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h5><p>期约实例的方法是连接外部同步代码与内部异步代码的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连接对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p>
<ol>
<li><p>实现 Thenable 接口</p>
<p>在 ECMAScript 暴露的异步结构中，任何对象都有一个 <code>then()</code> 方法。这个方法被认为实现了 Thenable 接口。</p>
<p>ECMAScript 的 Promise 类型实现了 Thenable 接口。</p>
</li>
<li><p><code>Promise.prototype.then()</code></p>
<p>Promise.prototype.then() 是为期约实例添加处理程序的主要方法。接收最多两个参数： onResolved 处理程序和 onRejected 处理程序。两个参数都是可选的，提供的时候会在期约分别进入兑现和拒绝状态时执行。任何非函数参数都会被忽略。该方法返回一个新的期约实例。会通过 Promise.resolve() 包装生成新期约，没有提供处理程序的话，会包装上一个期约解决后的值。没有显示指定返回语句的话，会包装默认返回值 <code>undefined</code> 。</p>
<p>onRejected 处理程序返回值会被 Promise.resolve() 包装。</p>
</li>
<li><p><code>Promise.prototype.catch()</code></p>
<p>相当于调用 <code>Promise.prototype.then(null, onRejected)</code> 。</p>
</li>
<li><p><code>Promise.prototype.finally()</code></p>
<p>这个处理程序在期约转换为解决或拒绝状态时都会执行。但无法知道期约的状态，一般用于添加清理代码。该方法返回一个新的期约实例。不同于 <code>then()</code> 返回的实例，被设计为一个状态无关的方法。在大多数情况下它将表现为父期约的传递。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="对象—原始值转换"><a href="#对象—原始值转换" class="headerlink" title="对象—原始值转换"></a>对象—原始值转换</h3><p>所有对象在布尔上下文中均为 <code>true</code> 。</p>
<p>数值转换发生在对象相减或应用数学函数时。</p>
<p>字符串转换发生在输出对象和类似的上下文中。</p>
<p>为了进行转换， JavaScript 尝试查找并调用三个对象方法：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive]</code>。</li>
<li>如果上述方法不存在，且进行字符串转换，尝试 <code>obj.toString()</code> 和 <code>obj.valueOf()</code> 。</li>
<li>如果上述方法不存在，且进行数字转换或是默认转换，尝试 <code>obj.valueOf()</code> 和 <code>obj.toString()</code> 。</li>
</ol>
<p><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code> 。</p>
<p><code>valueOf</code> 方法返回对象本身。</p>
<p>三个方法唯一的限制是返回一个原始值而不是对象。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 28</title>
    <url>/2020/10/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-28/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-28"><a href="#学习笔记-2020-10-28" class="headerlink" title="学习笔记 2020-10-28"></a>学习笔记 2020-10-28</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h4><p>立即调用的匿名函数又被称作立即调用的函数表达式 ( <code>IIFE</code> ， <code>Immediately Invoked Function Expression</code> )。它类似于函数声明，但由于被包含在括号中，会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。</p>
<p>使用 <code>IIFE</code> 可以模拟块级作用域。即在一个函数表达式内部声明变量，然后立即调用这个函数。</p>
<p>使用立即调用的函数表达式可以解决 <code>var</code> 带来的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ES6</code> ，有了块级作用域的概念，就可以规避这个问题。</p>
<h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><p><code>JS</code> 没有私有成员的概念，所有对象属性都是公有的。有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的。</p>
<p>特权方法是能够访问函数私有变量及私有函数的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。因为形成了闭包，所以可行。</p>
<h5 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h5><p>特权方法可以通过使用私有作用域定义私有变量和函数来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>使用这种方法，避免了所有方法都在对象实例上重复定义。特权方法作为一个闭包，始终引用着包含它的作用域。但该种方法的每个实例没有了自己的私有变量。</p>
<h5 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h5><p>模块模式在一个单例对象上实现了相同的隔离和封装。</p>
<p>单例对象就是只有一个实例的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    publicMethod() &#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>模块模式是在单例对象基础上加以拓展，使其通过作用域链来关联私有变量和特权方法。</p>
<p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，就可以采用这个模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> application = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getComponentCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> components.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    registerComponent(component) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">'object'</span>) &#123;</span><br><span class="line">        components.push(component);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h5 id="模块增强模式"><a href="#模块增强模式" class="headerlink" title="模块增强模式"></a>模块增强模式</h5><p>在返回对象之前先对其进行增强，适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性和方法的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">  <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line">  object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">  object.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h3><p><code>ES6</code> 新增了正式的 <code>Promise</code> 引用类型，支持优雅地定义和组织异步逻辑。</p>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p>同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 <code>JavaScript</code> 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。但不一定必须如此，不想为等待某个操作而阻塞线程执行，就可以使用异步操作。</p>
<h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态。</p>
<p>在程序执行的每一步，都可以推断出程序的状态。</p>
<p>异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。但异步操作何时完成，异步操作中涉及到的数据何时可获取可操作，是不可知的。</p>
<h5 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h5><p>异步行为是 <code>JavaScript</code> 的基础。在早期，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>setTimtout</code> 定义了一个在指定时间后会被调度执行的回调函数。<code>1000</code> 毫秒之后， <code>JavaScript</code> 执行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 <code>JavaScript</code> 代码就完全不可见了。 <code>double</code> 函数会在 <code>setTimeout</code> 成功调度异步操作之后立即退出。</p>
<ol>
<li><p>异步返回值</p>
<p>假设 <code>setTimeout</code> 操作会返回一个有用的值。如何把这个值进行传递？一个方法是给异步操作提供一个回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, x =&gt; <span class="built_in">console</span>.log(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>失败处理</p>
<p>异步操作的失败处理在回调模型中也要考虑。因此出现了成功回调与失败回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Must provide number as first argument'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line">double(<span class="string">'b'</span>, successCallback, failureCallback);</span><br></pre></td></tr></table></figure>

<p>这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间存在的值作为参数的回调才能接收到它。</p>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>根据规范，对象的属性值只能是字符串类型或者 <code>Symbol</code> 类型。</p>
<p><code>Symbol</code> 不会被隐式转换为字符串。显式转换需要调用 <code>toString()</code> 。或者使用 <code>description</code> 属性来显示描述。</p>
<p><code>Symbol</code> 会在 <code>for-in</code> 中被跳过。</p>
<p><code>Object.assign</code> 会同时复制字符串和 <code>Symbol</code> 属性。</p>
<h4 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a>全局 symbol</h4><p>根据相同的名字创建出来的 <code>symbol</code> 都是不一样的。如果想要名字相同的 <code>Symbol</code> 具有相同的实体，可以使用 <strong>全局 Symbol 注册表</strong> 。</p>
<p>从注册表读取( 不存在则创建 ) <code>Symbol</code> ，使用 <code>Symbol.for(key)</code> 。</p>
<p>使用 <code>Symbol.keyFor(sym)</code> ，根据一个全局 Symbol 来返回一个名字。</p>
<h4 id="系统-Symbol"><a href="#系统-Symbol" class="headerlink" title="系统 Symbol"></a>系统 Symbol</h4><p>JavaScript 内部有很多系统 Symbol。</p>
<ul>
<li><code>Symbol.hasInstance</code></li>
<li><code>Symbol.isConcatSpreadable</code></li>
<li><code>Symbol.iterator</code></li>
<li><code>Symbol.toPrimitive</code></li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 27</title>
    <url>/2020/10/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-27/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-27"><a href="#学习笔记-2020-10-27" class="headerlink" title="学习笔记 2020-10-27"></a>学习笔记 2020-10-27</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>函数表达式创建的函数叫做匿名函数，也叫做兰姆达函数。因为 <code>function</code> 关键字没有标识符。未赋值给其他变量的匿名函数的 <code>name</code> 属性是空字符串。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归函数通常的形式是一个函数通过名称调用自己。</p>
<p>在非严格模式下，可以使用 <code>arguments.callee</code> 来访问自身函数。在严格模式下，可以使用命名函数表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p><code>ECMAScript6</code> 新增了一项内存管理优化机制，让 <code>JS</code> 引擎在满足条件时可以重用栈帧。例如尾调用，即外部函数的返回是内部函数的返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ES6</code> 优化之前，这个例子会在内存中发生如下操作。</p>
<ol>
<li>执行到 <code>outerFunction</code> 函数体，第一个栈帧被推到栈上。</li>
<li>执行 <code>outerFunction</code> 函数体，到 <code>return</code> 语句。计算返回值必须先计算 <code>innerFunction</code> 。</li>
<li>执行到 <code>innerFunction</code> 函数体，第二个栈帧被推到栈上。</li>
<li>执行 <code>innerFunction</code> 函数体，计算其返回值。</li>
<li>将返回值传回 <code>outerFunction</code> ，然后 <code>outerFunction</code> 再返回值。</li>
<li>将栈帧弹到栈外。</li>
</ol>
<p>在 <code>ES6</code> 优化之后，执行这个例子会在内存中发生如下操作。</p>
<ol>
<li>执行到 <code>outerFunction</code> 函数体，第一个栈帧被推到栈上。</li>
<li>执行 <code>outerFunction</code> 函数体，到达 <code>return</code> 语句。为求值返回语句，必须先求值 <code>innerFunction</code> 。</li>
<li>引擎发现把第一个栈帧弹出栈外也没问题，因为 <code>innerFunction</code> 的返回值也是 <code>outerFunction</code> 的返回值。</li>
<li>弹出 <code>outerFunction</code> 的栈帧。</li>
<li>执行到 <code>innerFunction</code> 函数体，栈帧被推到栈上。</li>
<li>执行 <code>innerFunction</code> 函数体，计算其返回值。</li>
<li>将 <code>innerFunction</code> 的栈帧弹出栈外。</li>
</ol>
<h5 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h5><p>条件是外部栈帧没有必要存在。</p>
<ul>
<li><p>代码在严格模式下执行。</p>
</li>
<li><p>外部函数的返回值是对为调用函数的调用。</p>
</li>
<li><p>尾调用函数返回后不需要执行额外的逻辑。</p>
</li>
<li><p>尾调用函数不是引用外部函数作用域中自由变量的闭包。</p>
</li>
</ul>
<p>要求严格模式的原因是非严格模式下函数调用中允许使用 <code>f.arguments</code> 和 <code>f.caller</code> ，而它们都会引用外部函数的栈帧。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数内部上下文中的叫活动对象，只在函数执行期间存在。在定义函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的 <code>[[Scope]]</code> 中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的 <code>[[Scope]]</code> 来创建其作用域链。接着创建函数的活动对象并将其推入作用域链的前端。</p>
<p>函数内部的代码访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁。</p>
<p>而在闭包中，一个函数若是引用了外部作用域的变量，当这个函数存在的时候，外部作用域就不会被销毁。即使外部作用域对应的函数已经执行完毕。</p>
<h5 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a><code>this</code> 对象</h5><p>可以利用闭包来使一个函数内部访问外部作用域的 <code>this</code> 对象。</p>
<p>即定义一个变量来保存外部函数的 <code>this</code> 引用，这样内部函数可以访问到该变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">'The Window'</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">'My Object'</span>,</span><br><span class="line">  getIdentity() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.identity;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getIdentity(); <span class="comment">// 'My Object'</span></span><br><span class="line">(object.getIdentity)(); <span class="comment">// 'My Object'</span></span><br><span class="line">(object.getIdentity = object.getIdentity)(); <span class="comment">// 'The Window'</span></span><br></pre></td></tr></table></figure>

<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><code>IE</code> 在 <code>IE9</code> 以前对 <code>JScript</code> 对象和 <code>COM</code> 对象使用了不同的垃圾回收机制，所以闭包在旧版本中可能会导致问题。即存在内存泄漏的问题。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="可选链-“-”"><a href="#可选链-“-”" class="headerlink" title="可选链 “?.”"></a>可选链 “?.”</h3><p>一个常见的情景：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address</span></span><br><span class="line"><span class="built_in">console</span>.log(user &amp;&amp; user.address &amp;&amp; user.address.street); <span class="comment">// undefined(不报错)</span></span><br></pre></td></tr></table></figure>

<p>可选链会在遇到 <code>undefined</code> 或 <code>null</code> 时停止运算并返回 <code>undefined</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address</span></span><br><span class="line"><span class="built_in">console</span>.log(user?.address?.street); <span class="comment">// undefined （不报错）</span></span><br></pre></td></tr></table></figure>

<p>可选链只允许前面的值成为可选值，不影响后面。可选链前的变量必须已声明，否则会触发一个错误。</p>
<p>可使用 <code>?.()</code> 可选的调用一个可能不存在的函数。</p>
<p>可使用 <code>?.[]</code> 来使用方括号访问属性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 26</title>
    <url>/2020/10/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-26/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-26"><a href="#学习笔记-2020-10-26" class="headerlink" title="学习笔记 2020-10-26"></a>学习笔记 2020-10-26</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数扩展与收集"><a href="#函数扩展与收集" class="headerlink" title="函数扩展与收集"></a>函数扩展与收集</h4><p><code>ECMAScript6</code> 新增了扩展操作符。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p>
<h5 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>对可迭代对象使用拓展操作符作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">a, b, c = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>, <span class="number">1</span>])); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h5 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h5><p>在函数定义时，使用扩展操作符可以将不同长度的独立参数组合为一个数组。收集参数前面可以有其余命名参数，但只能作为最后一个参数。</p>
<p>箭头函数也支持收集函数。</p>
<h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><p><code>JS</code> 引擎在代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。函数表达式必须等到代码执行到它，才会在执行上下文中生成函数定义。</p>
<p>因此函数声明在使用它之前是没有问题的，因为函数声明会被提升。</p>
<h4 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h4><p>函数可以作为变量传递，也可以被返回。</p>
<h4 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h4><h5 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><code>arguments</code></h5><p><code>arguments</code> 对象是一个类数组对象，包含调用参数时传入的所有参数。这个对象只有以 <code>function</code> 关键字定义函数时才会有。</p>
<p><code>arguments</code> 有一个 <code>callee</code> 属性，指向该 <code>arguments</code> 对象所在函数的指针。</p>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h5><p>在标准函数中， <code>this</code> 引用把函数当成方法调用的上下文对象。</p>
<p><code>this</code> 引用的值只有在函数被调用时才确定。</p>
<p>箭头函数中的 <code>this</code> 引用的是定义箭头函数的上下文。</p>
<h5 id="caller"><a href="#caller" class="headerlink" title="caller"></a><code>caller</code></h5><p><code>ECMAScript5</code> 也会给函数对象上添加一个属性： <code>caller</code> 。这个属性引用调用当前函数的函数。在全局中调用则为 <code>null</code> 。</p>
<p>严格模式下不能访问 <code>arguments.callee</code> ，也不能访问 <code>caller</code> ，不能给函数的 <code>caller</code> 属性赋值。</p>
<h5 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a><code>new.target</code></h5><p><code>ECMAScript6</code> 新增了检测函数是否使用 <code>new</code> 关键字调用的 <code>new.target</code> 属性。如果使用 <code>new</code> 关键字调用，则 <code>new.target</code> 将引用被调用的构造函数，否则为 <code>undefined</code> 。</p>
<h4 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h4><p>每个函数都有两个属性， <code>length</code> 和 <code>prototype</code> 。<code>length</code> 属性保存函数定义的命名参数的个数。</p>
<p><code>prototype</code> 属性保存引用类型所有实例方法。在 <code>ECMAScript5</code> 中，该属性是不可枚举的。</p>
<p>函数有两个方法，<code>apply()</code> 和 <code>call()</code> 。这两个方法都会以指定的 <code>this</code> 值来调用函数。区别在于 <code>apply()</code> 只需要最多两个参数，第二个参数可以是数组也可以是 <code>arguments</code> 对象。</p>
<p><code>ECMAScript5</code> 定义了一个新方法 <code>bind()</code> 。<code>bind()</code> 只会绑定 <code>this</code> 值，并创建一个新的函数实例。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>两个函数—一个对象</p>
<p>是否可以创建像 <code>new A()==new B()</code> 这样的函数 <code>A</code> 和 <code>B</code>？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B;</span><br><span class="line">alert( a == b ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果可以，请提供一个它们的代码示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> obj; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> obj; &#125;</span><br><span class="line">alert( <span class="keyword">new</span> A() == <span class="keyword">new</span> B() ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 new Calculator</p>
<p>创建一个构造函数 <code>Calculator</code>，它创建的对象中有三个方法：</p>
<ul>
<li><code>read()</code> 使用 <code>prompt</code> 请求两个值并把它们记录在对象的属性中。</li>
<li><code>sum()</code> 返回这些属性的总和。</li>
<li><code>mul()</code> 返回这些属性的乘积。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">calculator.read();</span><br><span class="line">alert( <span class="string">"Sum="</span> + calculator.sum() );</span><br><span class="line">alert( <span class="string">"Mul="</span> + calculator.mul() );</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = +prompt(<span class="string">'a?'</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.b = +prompt(<span class="string">'b?'</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.mul = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="keyword">this</span>.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 new Accumulator</p>
<p>创建一个构造函数 <code>Accumulator(startingValue)</code>。</p>
<p>它创建的对象应该：</p>
<ul>
<li>将“当前 value”存储在属性 <code>value</code> 中。起始值被设置到构造器 <code>startingValue</code> 的参数。</li>
<li><code>read()</code> 方法应该使用 <code>prompt</code> 来读取一个新的数字，并将其添加到 <code>value</code> 中。</li>
</ul>
<p>换句话说，<code>value</code> 属性是所有用户输入值与初始值 <code>startingValue</code> 的总和。</p>
<p>下面是示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> accumulator = <span class="keyword">new</span> Accumulator(<span class="number">1</span>); <span class="comment">// 初始值 1</span></span><br><span class="line">accumulator.read(); <span class="comment">// 添加用户输入的 value</span></span><br><span class="line">accumulator.read(); <span class="comment">// 添加用户输入的 value</span></span><br><span class="line">alert(accumulator.value); <span class="comment">// 显示这些值的总和</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Accumulator</span>(<span class="params">startingValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = startingValue;</span><br><span class="line">  <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value += +prompt(<span class="string">'new value?'</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><h3 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a><code>grid</code> 布局</h3><p><code>auto-fill</code> 与 <code>auto-fit</code> 的区别：</p>
<p><code>auto-fill</code> 只会自动控制子元素的大小来实现布局。而 <code>auto-fit</code> 会在父容器有多余宽度的时候拉伸子元素来填满父容器。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 25</title>
    <url>/2020/10/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-25/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-25"><a href="#学习笔记-2020-10-25" class="headerlink" title="学习笔记 2020-10-25"></a>学习笔记 2020-10-25</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h5><p>通过代理可以实现把被代理的类绑定到一个全局实例集合，让所有创建的实例都添加到这个集合中。再把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数实际上是个对象。每个函数都是 <code>Function</code> 类型的实例。</p>
<p>定义函数的方法有：</p>
<ul>
<li><p>函数声明</p>
</li>
<li><p>函数表达式</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p><code>Function</code> 构造函数</p>
<p>该构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体。</p>
</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数语法简洁，但不能使用 <code>arguments</code> 、 <code>super</code> 和 <code>new.target</code> ，也不能用作构造函数。也没有 <code>prototype</code> 属性。</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名就是指向函数的指针，与其他包含对象指针的变量具有相同的行为。一个函数可以有多个名称。使用不带括号的函数名会访问函数指针。</p>
<p><code>ECMAScript6</code> 的所有函数对象都会暴露一个只读的 <code>name</code> 属性。如果函数是一个获取函数、设置函数或是使用 <code>bind()</code> 实例化，标识符前面会加上一个前缀。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.name); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.name); <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;).name); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Function</span>().name); <span class="comment">// anonymous</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name); <span class="comment">// bound foo</span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  years: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> age() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.years;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> age(newAge) &#123;</span><br><span class="line">    <span class="keyword">this</span>.years = newAge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name); <span class="comment">// get age</span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.set.name); <span class="comment">// set age</span></span><br></pre></td></tr></table></figure>

<h4 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h4><p><code>ECMAScript</code> 函数的参数跟大多数其他语言不同，不关心传入参数的个数、类型。</p>
<p>原因是 <code>ECMAScript</code> 函数的参数在内部表现为一个数组。函数并不关心这个数组中包含什么。在使用 <code>function</code> 关键字定义非箭头函数时，可以在函数内部使用 <code>arguments</code> 对象来访问每个参数。</p>
<p><code>arguments</code> 是一个类数组对象，可以和命名参数一起使用。它的值始终会和对应的命名参数同步。两者是相对应的，但仅限于传入的参数对应。未传入的参数位置使用 <code>arguments</code> 修改是不会反映到命名参数上的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Arguments [99, length: 1]</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2); <span class="comment">// 99 undefined</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Arguments [5, 1: 10, length: 1]</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2); <span class="comment">// 5 undefined</span></span><br><span class="line">  num1 = <span class="number">1</span>;</span><br><span class="line">  num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Arguments [1, 1: 10, length: 1]</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(<span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<p>在严格模式下给 <code>aguments[1]</code> 赋值不会再影响 <code>num2</code> 。在函数中重写 <code>arguments</code> 对象会导致语法错误。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p><code>ECMAScript</code> 中后定义的同名函数会覆盖先定义的。</p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>在 <code>ECMAScript5.1</code> 及以前，实现默认参数的常用方式是检查某个参数是否等于 <code>undefined</code> 。</p>
<p><code>ECMAScript6</code> 之后支持显式定义默认参数。在函数定义中的参数后面用 <code>=</code> 赋默认值。</p>
<p>在使用默认参数时， <code>arguments</code> 对象的值不反映参数的默认值，只反映传给函数的参数。修改命名参数也不会影响 <code>arguments</code> 对象。</p>
<p>默认参数值不限于原始值或对象类型，也可以使用调用函数返回的值。</p>
<p>默认参数只有在函数被调用时才会求值，定义时不会求值。计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</p>
<p>函数参数是某个作用域中求值的。给多个参数定义默认值实际上和使用 <code>let</code> 关键字顺序声明变量一样，所以后定义默认值的参数可以引用先定义的参数。</p>
<p>参数初始化顺序遵循 <strong>“暂时性死区”</strong> 规则。前面定义的参数不能引用后面定义的。</p>
<p>参数存在于自己的作用域中，不能饮用函数体的作用域。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><p>在对象字面量中使用 <code>“this&quot;</code></p>
<p>这里 <code>makeUser</code> 函数返回了一个对象。</p>
<p>访问 <code>ref</code> 的结果是什么？为什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"John"</span>,</span><br><span class="line">    ref: <span class="keyword">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> user = makeUser();</span><br><span class="line">alert( user.ref.name ); <span class="comment">// 结果是什么？</span></span><br></pre></td></tr></table></figure>

<p><code>ref</code> 会指向全局对象，非严格模式下是 <code>window</code> 。因为 <code>this</code> 是在被调用的那一刻确定。调用 <code>makeUser</code> 时作为全局函数调用， <code>this</code> 绑定了 <code>window</code> 。</p>
</li>
<li><p>创建一个计算器</p>
<p>创建一个有三个方法的 <code>calculator</code> 对象：</p>
<ul>
<li><code>read()</code> 提示输入两个值，并将其保存为对象属性。</li>
<li><code>sum()</code> 返回保存的值的和。</li>
<li><code>mul()</code> 将保存的值相乘并返回计算结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">  <span class="comment">// ……你的代码……</span></span><br><span class="line">&#125;;</span><br><span class="line">calculator.read();</span><br><span class="line">alert( calculator.sum() );</span><br><span class="line">alert( calculator.mul() );</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">  a: <span class="number">0</span>,</span><br><span class="line">  b: <span class="number">0</span>,</span><br><span class="line">  read: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = +prompt(<span class="string">'please enter the first number'</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.b = +prompt(<span class="string">'please enter the second number'</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">  &#125;,</span><br><span class="line">  mul: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="keyword">this</span>.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式(调用)</p>
<p>有一个可以上下移动的 <code>ladder</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ladder = &#123;</span><br><span class="line">  step: <span class="number">0</span>,</span><br><span class="line">  up() &#123;</span><br><span class="line">    <span class="keyword">this</span>.step++;</span><br><span class="line">  &#125;,</span><br><span class="line">  down() &#123;</span><br><span class="line">    <span class="keyword">this</span>.step--;</span><br><span class="line">  &#125;,</span><br><span class="line">  showStep: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 显示当前的 step</span></span><br><span class="line">    alert( <span class="keyword">this</span>.step );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们要按顺序执行几次调用，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ladder.up();</span><br><span class="line">ladder.up();</span><br><span class="line">ladder.down();</span><br><span class="line">ladder.showStep(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>up</code>，<code>down</code> 和 <code>showStep</code> 的代码，让调用可以链接，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ladder.up().up().down().showStep(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这种方法在 JavaScript 库中被广泛使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ladder = &#123;</span><br><span class="line">  step: <span class="number">0</span>,</span><br><span class="line">  up() &#123;</span><br><span class="line">    <span class="keyword">this</span>.step++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  down() &#123;</span><br><span class="line">    <span class="keyword">this</span>.step--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  showStep: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 显示当前的 step</span></span><br><span class="line">    alert( <span class="keyword">this</span>.step );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="MDN学习记录"><a href="#MDN学习记录" class="headerlink" title="MDN学习记录"></a>MDN学习记录</h2><h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><p>使用 <code>column-gap</code> 改变列间隙。</p>
<p>使用 <code>column-rule</code> 在列间加入一条分割线。属性值类似于 <code>border</code> 的值。并且该分割线不占用宽度。</p>
<h4 id="列与内容折断"><a href="#列与内容折断" class="headerlink" title="列与内容折断"></a>列与内容折断</h4><p><code>break-inside</code> 属性用于表示该盒子不被拆开。</p>
<p><code>page-break-inside</code> 拥有更好的浏览器支持。</p>
<h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><p>响应式网页设计 ( <code>responsive web design</code> )，指的是允许 <code>Web</code> 网页适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。</p>
<ol>
<li>液态网格，这早先已由Gillenwater进行探讨，可以在Marcotte的文章《<a href="https://alistapart.com/article/fluidgrids/" target="_blank" rel="noopener">Fluid Grids</a>》（出版于2009年的《A List Apart》上）中读到。</li>
<li><a href="http://unstoppablerobotninja.com/entry/fluid-images" target="_blank" rel="noopener">液态图像</a>。通过使用相当简单的将设置 <code>max-width</code> 属性设置为 <code>100%</code> 的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。这使得图像可以被缩放，以被放到一个灵活尺寸的列，而不是溢出出去，同时也不会在列宽于图像的时候，使图像变得太大以至于画质变得粗糙。</li>
<li>媒体查询，媒体查询使以往 <code>Cameron Adams</code> 探讨过的、由 <code>JavaScript</code> 实现的布局类型切换，可以只使用CSS实现。和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li>
</ol>
<h4 id="媒介查询"><a href="#媒介查询" class="headerlink" title="媒介查询"></a>媒介查询</h4><p>下面的媒体查询进行测试，以知晓当前的Web页面是否被展示为屏幕媒体（也就是说不是印刷文档），且视口至少有800像素宽。用于 <code>.container</code> 选择器的CSS将只会在这两件前提存在的情况下应用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">2em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询，以及样式改变时的点，被叫做断点。</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><h4 id="媒体查询基础"><a href="#媒体查询基础" class="headerlink" title="媒体查询基础"></a>媒体查询基础</h4><p>最简单的媒体查询语法看起来是像这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> media-type and (media-feature-rule) &#123;</span><br><span class="line">  <span class="comment">/* CSS rules go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它由以下部分组成：</p>
<ul>
<li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li>
<li>一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试；</li>
<li>一组CSS规则，会在测试通过且媒体类型正确的时候应用。</li>
</ul>
<p>可指定的媒体类型为：</p>
<ul>
<li><code>all</code></li>
<li><code>print</code></li>
<li><code>screen</code></li>
<li><code>speech</code></li>
</ul>
<h4 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h4><p>一个受到良好支持的媒体特征是 <code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变body文本颜色的话，可使用下面的媒体查询。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> (orientation: landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用指点设备"><a href="#使用指点设备" class="headerlink" title="使用指点设备"></a>使用指点设备</h4><p>作为四级规范的一部分，<code>hover</code> 媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> (hover: hover) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是在四级规范中，出现了 <code>pointer</code> 媒体特征。它可取三个值：<code>none</code>、<code>fine</code> 和 <code>coarse</code> 。<code>fine</code> 指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。<code>coarse</code> 指针是你在触摸屏上的手指。<code>none</code> 值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。</p>
<p>使用 <code>pointer</code> 可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p>
<h4 id="媒体查询逻辑判断"><a href="#媒体查询逻辑判断" class="headerlink" title="媒体查询逻辑判断"></a>媒体查询逻辑判断</h4><ul>
<li>与 <code>and</code></li>
<li>或 <code>,</code></li>
<li>非 <code>not</code></li>
</ul>
<h4 id="特性查询"><a href="#特性查询" class="headerlink" title="特性查询"></a>特性查询</h4><p>可以通过特性查询来判断浏览器是否支持某个特性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">supports</span> (display: grid) &#123;</span><br><span class="line">  <span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 24</title>
    <url>/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-24"><a href="#学习笔记-2020-10-24" class="headerlink" title="学习笔记 2020-10-24"></a>学习笔记 2020-10-24</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h3><h4 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h4><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 <code>API</code> 方法、参数、关联 <code>ECMAScript</code> 操作和不变式。</p>
<p>有几种不同的 <code>JavaScript</code> 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。</p>
<h5 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h5><p><code>get()</code> 捕获器会在获取属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.get()</code> 。</p>
<ol>
<li><p>返回值</p>
<p>返回值无限制。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>proxy.property</code></li>
<li><code>proxy[property]</code></li>
<li><code>Object.create(proxy)[property]</code></li>
<li><code>Reflect.get(proxy, property, receiver)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象</li>
<li><code>property</code> 引用的目标对象上的字符串键参数</li>
<li><code>receiver</code> 处理对象或继承代理对象的对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target.property</code> 不可写且不可配置，则处理程序返回的值必须与 <code>target.property</code> 匹配。</p>
<p>如果 <code>target.property</code> 不可配置且 <code>[[Get]]</code> 特性为 <code>undefined</code> ，处理程序也必须返回 <code>undefined</code> 。</p>
</li>
</ol>
<h5 id="set"><a href="#set" class="headerlink" title="set()"></a><code>set()</code></h5><p><code>set()</code> 捕获器会在设置属性值的操作中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.set()</code> 。</p>
<ol>
<li><p>返回值</p>
<p>返回 <code>true</code> 表示成功，返回 <code>false</code> 表示失败，严格模式下会抛出 <code>TypeError</code> 。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>proxy.property = value</code></li>
<li><code>proxy[property] = value</code></li>
<li><code>Object.create(proxy)[property] = value</code></li>
<li><code>Reflect.set(proxy, property, value, receiver)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>property</code> 引用的目标对象上的字符串键属性。</li>
<li><code>value</code> 要赋给属性的值。</li>
<li><code>receiver</code> 接收最初赋值的对象。</li>
</ul>
</li>
</ol>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a><code>has()</code></h5><p><code>has()</code> 捕获器会在 <code>in</code> 操作符被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.has()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>has()</code> 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><p><code>property in proxy</code></p>
</li>
<li><p><code>property in Object.create(proxy)</code></p>
</li>
<li><p><code>with(proxy) {( property ); }</code></p>
</li>
<li><p><code>Reflect.has(proxy, property)</code></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>property</code> 引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target.property</code> 存在且不可配置，则处理程序必须返回 <code>true</code> 。</p>
<p>如果 <code>target.property</code> 存在且目标对象不可拓展，则处理程序必须返回 <code>true</code> 。</p>
</li>
</ol>
<h5 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a><code>defineProperty()</code></h5><p><code>defineProperty()</code> 捕获器会在 <code>Object.defineProperty()</code> 被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.defineProperty()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>defineProperty()</code> 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><p><code>Object.defineProperty(proxy, property, descriptor)</code></p>
</li>
<li><p><code>Reflect.defineProperty(proxy, property, descriptor)</code></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>property</code> 引用的目标对象上的字符串键属性。</li>
<li><code>descriptor</code> 包含可选的 <code>enumerable</code> 、 <code>configurable</code> 、 <code>writable</code> 、 <code>value</code> 、 <code>get</code> 和 <code>set</code> 定义的对象。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果目标对象不可拓展，则无法定义属性。</p>
<p>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。</p>
<p>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</p>
</li>
</ol>
<h5 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a><code>getOwnPropertyDescriptor()</code></h5><p><code>getOwnPropertyDescriptor()</code> 捕获器会在 <code>Object.getOwnPropertyDescriptor()</code> 中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.getOwnPropertyDscriptor()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>getOwnPropertyDescriptor()</code> 必须返回对象，或者在属性不存在时返回 <code>undefined</code> 。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>Object.getOwnpropertyDescriptor(proxy, property)</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(proxy, property)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>property</code> 引用的目标对象上的字符串键属性</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。</p>
<p>如果自有的 <code>target.property</code> 存在且可配置，则处理程序必须返回表示该属性可配置的对象。</p>
<p>如果 <code>target.property</code> 存在且 <code>target</code> 不可拓展，则处理程序必须返回 <code>undefined</code> 表示该属性不存在。</p>
<p>如果 <code>target.property</code> 不存在，则处理程序不能返回表示该属性可配置的对象。</p>
</li>
</ol>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a><code>deleteProperty()</code></h5><p><code>deleteProperty()</code> 捕获器会在 <code>delete</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.deleteProperty()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>deleteProperty()</code> 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>delete proxy.property</code></li>
<li><code>delete proxy[property]</code></li>
<li><code>Reflect.deleteProperty(proxy, property)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>property</code> 引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果自有的 <code>target.property</code> 存在且不可配置，则处理程序不能删除这个属性。</p>
</li>
</ol>
<h5 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a><code>ownKeys()</code></h5><p><code>ownKeys()</code> 捕获器会在 <code>Object.keys()</code> 及类似方法中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.ownKeys()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>ownKeys()</code> 必须返回包含字符串或符号的可枚举对象。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>Object.getOwnPropertyNames(proxy)</code></li>
<li><code>Object.getOwnPropertySymbols(proxy)</code></li>
<li><code>Object.keys(proxy)</code></li>
<li><code>Reflect.ownKeys(proxy)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>返回的可枚举对象必须包含 <code>target</code> 的所有不可配置的自由属性。</p>
<p>如果 <code>target</code> 不可拓展，则返回可枚举对象必须准确地包含自有属性键。</p>
</li>
</ol>
<h5 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a><code>getPrototypeOf()</code></h5><p><code>getPrototypeOf()</code> 捕获器会在 <code>Object.getPrototypeOf()</code> 中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.getPrototypeOf()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>getPrototypeOf()</code> 必须返回对象或 <code>null</code> 。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>Object.getPrototypeOf(proxy)</code></li>
<li><code>Reflect.getPrototypeOf(proxy)</code></li>
<li><code>proxy.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf(proxy)</code></li>
<li><code>proxy instanceof object</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<p><code>target</code> 目标对象。</p>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target</code> 不可拓展，则 <code>Object.getPrototypeOf(proxy)</code> 唯一有效的返回值就是 <code>Object.getPrototypeOf(target)</code> 的返回值。</p>
</li>
</ol>
<h5 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a><code>setPrototypeOf()</code></h5><p><code>setPrototypeOf()</code> 捕获器会在 <code>Object.setPrototypeOf()</code> 中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.setPrototypeOf()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>setPrototypeOf()</code> 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><p><code>Object.setPrototypeOf(proxy)</code></p>
</li>
<li><p><code>Reflect.setPrototypeOf(proxy)</code></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>prototype</code> <code>target</code> 的替代原型，如果是顶级原型则为 <code>null</code> 。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target</code> 不可拓展，则唯一有效的 <code>prototype</code> 参数就是 <code>Object.getPrototypeOf(target)</code> 的返回值。</p>
</li>
</ol>
<h5 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a><code>isExtensible()</code></h5><p><code>isExtensible()</code> 捕获器会在 <code>Object.isExtensible()</code> 中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.isExtensible()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>isExtensible()</code> 必须返回布尔值，表示 <code>target</code> 是否可拓展。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>target.isExtensible(proxy)</code></li>
<li><code>Reflect.isExtensible(proxy)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>target</code> 可拓展，则处理程序必须返回 <code>true</code> 。</p>
<p>如果 <code>target</code> 不可拓展，则处理程序必须返回 <code>false</code> 。</p>
</li>
</ol>
<h5 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a><code>preventExtensions()</code></h5><p><code>preventExtensions()</code> 捕获器会在 <code>Object.preventExtensions()</code> 中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.preventExtensions()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>preventExtensions()</code> 必须返回布尔值，表示 <code>target</code> 是否已经不可拓展。返回非布尔值会被转型为布尔值。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>Object.preventExtensions(proxy)</code></li>
<li><code>Reflect.preventExtensions(proxy)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p>如果 <code>Object.isExtensible(proxy)</code> 是 <code>false</code> ，则处理程序必须返回 <code>true</code> 。</p>
</li>
</ol>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h5><p><code>apply()</code> 捕获器会在调用函数时被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.apply()</code> 。</p>
<ol>
<li><p>返回值</p>
<p>返回值无限制</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>proxy(...argumentsList)</code></li>
<li><code>Function.prototype.apply(thisArg, argumentsList)</code></li>
<li><code>Function.prototype.call(thisArg, ...argumentsList)</code></li>
<li><code>Reflect.apply(target, thisArgument, argumentsList)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标对象。</li>
<li><code>thisArg</code> 调用函数时的 <code>this</code> 参数。</li>
<li><code>argumentsList</code> 调用函数时的参数列表。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p><code>target</code> 必须是一个函数对象。</p>
</li>
</ol>
<h5 id="construct"><a href="#construct" class="headerlink" title="construct()"></a><code>construct()</code></h5><p><code>construct()</code> 捕获器会在 <code>new</code> 操作符中被调用。对应的反射 <code>API</code> 方法为 <code>Reflect.construct()</code> 。</p>
<ol>
<li><p>返回值</p>
<p><code>construct()</code> 必须返回一个对象。</p>
</li>
<li><p>拦截的操作</p>
<ul>
<li><code>new proxy(...argumentsList)</code></li>
<li><code>Reflect.construct(target, argumentsList, newTarget)</code></li>
</ul>
</li>
<li><p>捕获器处理程序参数</p>
<ul>
<li><code>target</code> 目标构造函数。</li>
<li><code>argumentsList</code> 传给目标构造函数的参数列表。</li>
<li><code>newTarget</code> 最初被调用的构造函数。</li>
</ul>
</li>
<li><p>捕获器不变式</p>
<p><code>target</code> 必须可以用作构造函数。</p>
</li>
</ol>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h5><p>通过捕获 <code>get</code> 、<code>set</code> 和 <code>has</code> 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jake'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name; <span class="comment">// Getting name</span></span><br><span class="line">proxy.age = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure>

<h5 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h5><p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">'foo'</span>, <span class="string">'bar'</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObject, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.bar); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'baz'</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h5><p>所有赋值操作都会触发 <code>set()</code> 捕获器，可以根据所赋值决定允许还是拒绝赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  onlyNumbersGoHere: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, property, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.onlyNumbersGoHere = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere); <span class="comment">// 1</span></span><br><span class="line">proxy.onlyNumbersGoHere = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h5 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h5><p>可以对函数和构造函数参数进行审查。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.sort()[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(median, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Non-number argument provided'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="string">'7'</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id_ = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  construct(target, argumentsList, newTarget) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'User cannot be instantiated without id'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> proxy();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure>

<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h4><p><code>JS</code> 中主要的内存管理概念是 <strong>可达性</strong>。</p>
<p>当一个值以某种方式可访问或可用，都不能被释放。</p>
<h2 id="MDN-学习记录"><a href="#MDN-学习记录" class="headerlink" title="MDN 学习记录"></a>MDN 学习记录</h2><h3 id="Web-字体"><a href="#Web-字体" class="headerlink" title="Web 字体"></a>Web 字体</h3><p>可以选择自定义一个 <code>@font-face</code> 块指定远程资源字体文件，然后使用该字体应用在页面中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"myFont"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"myFont.ttf"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"myFont"</span>, <span class="string">"Bitstream Vera Serif"</span>, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数现代浏览器都支持 <code>WOFF / WOFF2</code> (Web Open Font Format versions 1 and 2，Web开放字体格式版本1和2) 字体。旧版本 <code>IE</code> 只支持 <code>EOT</code> (Embedded Open Type，嵌入式开放类型) 的字体。</p>
<blockquote>
<p>获得字体的网站：</p>
<ul>
<li>免费的字体经销商：这是一个可以下载免费字体的网站(可能还有一些许可条件，比如对字体创建者的信赖)。比如： <a href="https://www.fontsquirrel.com/" target="_blank" rel="noopener">Font Squirre</a>，<a href="http://www.dafont.com/" target="_blank" rel="noopener">dafont</a> 和 <a href="https://everythingfonts.com/" target="_blank" rel="noopener">Everything Fonts</a>。</li>
<li>收费的字体经销商：这是一个收费则字体可用的网站，例如<a href="http://www.fonts.com/" target="_blank" rel="noopener">fonts.com</a>或<a href="http://www.myfonts.com/" target="_blank" rel="noopener">myfonts.com</a>。您也可以直接从字体铸造厂中购买字体，例如<a href="https://www.linotype.com/" target="_blank" rel="noopener">Linotype</a>，<a href="http://www.monotype.com/" target="_blank" rel="noopener">Monotype</a> 或 <a href="http://www.exljbris.com/" target="_blank" rel="noopener">Exljbris</a>。</li>
<li><a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a></li>
</ul>
</blockquote>
<blockquote>
<p> 生成所需代码</p>
<p>对于每种字体，遵循以下步骤：</p>
<ol>
<li>确保已经满足了任何许可证的要求，如果打算在一个商业和/或Web项目中使用它。</li>
<li>前往 Fontsquirrel <a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="noopener">Webfont Generator</a>.</li>
<li>使用上传字体按钮上传你的两个字体文件。</li>
<li>勾选复选框，“是的，我上传的字体符合网络嵌入的合法条件。</li>
<li>点击下载套件（kit）。</li>
</ol>
<p>在生成器完成处理之后，得到一个ZIP文件，将它保存在与HTML和CSS相同的目录中。</p>
</blockquote>
<h3 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h3><h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h4><p>当父元素设置 <code>display: flex</code> 时，所有子元素变成了 <code>flex items</code> ，按照父元素的 <code>flex</code> 初值进行排列。<code>flex-direction</code> 初值为 <code>row</code> 。所以子元素一般默认按行排列。 <code>align-items</code> 初值为 <code>stretch</code> ，所以子元素会被拉伸至最高的元素高度。</p>
<p>子元素设置 <code>flex: 1</code> ，会使得所有子元素伸展并填充容器，不会留下空白。 </p>
<h4 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a><code>grid</code> 布局</h4><p><code>grid</code> 布局用于同时在两个维度上把元素按行按列排序整齐。弹性盒子用于设计横向或纵向的布局。</p>
<p>设置父元素的 <code>display</code> 值为 <code>grid</code> 即可进行 <code>grid</code> 布局。</p>
<p>可以使用 <code>grid-template-rows</code> 和 <code>grid-template-columns</code> 来定义行和列的轨道。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box5"</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box6"</span>&gt;</span>Six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024124853197.png" alt="image-20201024124853197"></p>
<p>也可以自定义子元素的 <code>grid-column</code> 和 <code>grid-row</code> 属性来设置子元素在哪里摆放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">4</span>; <span class="comment">/* 从第2列开始 到第4列结束 */</span></span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>; <span class="comment">/* 第1行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024125045813.png" alt="image-20201024125045813"></p>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>浮动会使得元素从正常布局流中移除。其他的周围内容就会被这个浮动元素环绕。</p>
<p><code>float</code> 的值：</p>
<ul>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>none</code> 默认值</li>
<li><code>inherit</code></li>
</ul>
<h4 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h4><ul>
<li><code>static</code> 静态定位</li>
<li><code>relative</code> 相对定位，相对于元素在正常文档流中的位置。</li>
<li><code>absolute</code> 绝对定位，从正常文档流移除，相对于该元素最近的被定位祖先元素或是页面的 <code>html</code> 元素。</li>
<li><code>fixed</code> 固定定位，相对于浏览器视口固定。</li>
<li><code>sticky</code> 粘性定位，先保持静态定位，当它的相对视口位置(<code>offset from the viewport</code>)达到某一个预设值时，会变成固定定位。</li>
</ul>
<h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>First of all, tell us your name and age.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"fname"</span>&gt;</span>First name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"fname"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lname"</span>&gt;</span>Last name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"lname"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"age"</span>&gt;</span>Age:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">label</span>, <span class="selector-tag">form</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">5%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-caption;</span><br><span class="line">  <span class="attribute">caption-side</span>: bottom;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024130617494.png" alt="image-20201024130617494"></p>
<h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>多列布局可以实现把内容按列排序，就像文本在报纸上排列那样。</p>
<p>使用 <code>column-count</code> 属性来告诉浏览器需要把一个多列容器转成多少列。</p>
<p>使用 <code>column-width</code> 属性来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Multi-column layout<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024131059533.png" alt="image-20201024131059533"></p>
<h4 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h4><p>正常布局流是一套在浏览器视口内放置、组织元素的系统。默认的，块级元素按照基于其父元素的书写顺序(默认值 <code>horizontal-tb</code> )的块流动方向放置。内联元素会在父级块元素的宽度内放置，溢出的文本或元素移到新的一行。</p>
<h4 id="弹性盒子-1"><a href="#弹性盒子-1" class="headerlink" title="弹性盒子"></a>弹性盒子</h4><p>行内元素设置为弹性盒子，可以设置 <code>display</code> 的值为 <code>inline-flex</code> 。</p>
<h5 id="flex-模型"><a href="#flex-模型" class="headerlink" title="flex 模型"></a><code>flex</code> 模型</h5><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p>
<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024132638213.png" alt="flex_terms"></p>
<ul>
<li><strong>主轴（main axis）</strong>是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴（cross axis）</strong>是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素（在本例中是 <code>section</code>）被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）（本例中是 <code>article</code> 元素。</li>
</ul>
<p>弹性盒子提供了 <code>flex-direction</code> 来指定主轴的方向。</p>
<ul>
<li><code>row</code></li>
<li><code>column</code></li>
<li><code>row-reverse</code></li>
<li><code>column-reverse</code></li>
</ul>
<h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>当弹性盒子子元素定宽或定高时，可能会导致子元素溢出父元素。</p>
<p>此时，可以设置父元素的 <code>flex-wrap</code> 属性为 <code>wrap</code> 来自动换行。</p>
<p>子元素设置 <code>flex</code> 值为宽度时，会使得子元素的宽度大于等于这个值，当父元素某一行有多余内容时，会自动伸展来填充空余内容。</p>
<h5 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a><code>flex-flow</code> 缩写</h5><p><code>flex-flow</code> 是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的缩写属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br><span class="line"><span class="comment">/* === */</span></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure>

<h5 id="flex-项的动态尺寸"><a href="#flex-项的动态尺寸" class="headerlink" title="flex 项的动态尺寸"></a><code>flex</code> 项的动态尺寸</h5><p>设置子元素的 <code>flex: 1</code> 。会使得子元素占用空间都相等。占用空间指在设置 <code>padding</code> 和 <code>margin</code> 之后剩余的空间。</p>
<p>可以设置子元素的 <code>flex: 1 xxxpx</code> 来设定最小宽度。</p>
<p>这会使得子元素首先分配最小宽度，剩余空间按照比例来分配。</p>
<h5 id="flex-缩写与全写"><a href="#flex-缩写与全写" class="headerlink" title="flex 缩写与全写"></a><code>flex</code> 缩写与全写</h5><p><code>flex</code> 是三个值的缩写属性：</p>
<ul>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
</ul>
<h5 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h5><p><code>align-items</code> 控制 <code>flex</code> 项在交叉轴上的位置。</p>
<ul>
<li><p>默认值是 <code>stretch</code> ，使所有 <code>flex</code> 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴上没有固定宽度，则所有 <code>flex</code> 项将变得与最长的 <code>flex</code> 项一样长。</p>
</li>
<li><p>可以设置 <code>align-self</code> 在某个子元素上覆盖 <code>align-items</code> 的行为。</p>
</li>
</ul>
<p><code>justify-content</code> 控制 <code>flex</code> 项在主轴上的位置。</p>
<ul>
<li>默认值是 <code>flex-start</code> ，使得所有 <code>flex</code> 项位于主轴的开始处。</li>
<li><code>flex-end</code> 使得<code>flex</code> 项位于结尾。</li>
<li><code>center</code> 使得各项居中。</li>
<li><code>space-around</code> 让各项沿着主轴均匀分布，任意一端都留一点空间。</li>
<li><code>space-between</code> 类似于上一个，但不会在两端留空间。</li>
</ul>
<h5 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a><code>flex</code> 项排序</h5><p>弹性盒子可以改变 <code>flex</code> 项的布局位置，而不影响到源顺序。</p>
<p>设置子元素的 <code>order</code> 属性即可。</p>
<ul>
<li><code>order</code> 值默认为 <code>0</code> 。</li>
<li><code>order</code> 值越大，在显示顺序中越靠后。</li>
<li>相同 <code>order</code> 值按源顺序显示。</li>
</ul>
<h4 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h4><p>设置父元素的 <code>display</code> 为 <code>grid</code> 后默认创建一个只有一列的网格，网页布局不会马上发生变化。</p>
<p>设置 <code>grid-template-columns</code> 可以创建网格列的模板。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="comment">/* 创建了三列，每列200px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fr-单位"><a href="#fr-单位" class="headerlink" title="fr 单位"></a><code>fr</code> 单位</h5><p><code>fr</code> 表示一个比例单位。分配父元素的可用空间。可用空间指的是除去那些确定被占用的空间外的空间。</p>
<h5 id="网格间隙"><a href="#网格间隙" class="headerlink" title="网格间隙"></a>网格间隙</h5><p><code>grid-column-gap</code> 定义列间隙。 <code>grid-row-gap</code> 定义行间隙。</p>
<p><code>grid-gap</code> 同时设定两者。</p>
<p><code>grid-</code> 前缀已经被修改，现在可以使用 <code>gap</code> 属性。</p>
<h5 id="重复构建行-列"><a href="#重复构建行-列" class="headerlink" title="重复构建行/列"></a>重复构建行/列</h5><p>可以使用 <code>repeat</code> 来重复构建相同宽度配置的列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr); <span class="comment">/* === 1fr 1fr 1fr; */</span></span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="显式网格与隐式网格"><a href="#显式网格与隐式网格" class="headerlink" title="显式网格与隐式网格"></a>显式网格与隐式网格</h5><p>显式网格是使用 <code>grid-template-columns</code> 或 <code>grid-template-rows</code> 创建的。</p>
<p>隐式网格是当有内容放到网格外时才会生成。</p>
<p>隐式网格中生成的行/列大小是参数默认 <code>auto</code> ，大小会根据放入的内容自动调整。也可以使用 <code>grid-auto-rows</code> 和 <code>grid-auto-columns</code> 属性手动设定隐式网格的大小。</p>
<h5 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a><code>minmax()</code></h5><p><code>minmax</code> 函数为一个行/列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为100像素，并且如果内容尺寸大于100像素则会根据内容自动调整。在这里试一下把 <code>grid-auto-rows</code> 属性设置为<code>minmax</code>函数。</p>
<h5 id="自动使用多列填充"><a href="#自动使用多列填充" class="headerlink" title="自动使用多列填充"></a>自动使用多列填充</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(<span class="selector-tag">auto-fill</span>, <span class="selector-tag">minmax</span>(200<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>));</span><br></pre></td></tr></table></figure>

<p>可以实现自动填充多列，<code>auto-fill</code> 自动确定重复次数，<code>minmax</code> 来确定列宽。</p>
<p>此时的子元素会至少大于 <code>200px</code> ，且自动填满父容器。</p>
<h5 id="基于线的元素放置"><a href="#基于线的元素放置" class="headerlink" title="基于线的元素放置"></a>基于线的元素放置</h5><ul>
<li><p><code>grid-column-start</code></p>
</li>
<li><p><code>grid-column-end</code></p>
</li>
<li><p><code>grid-row-start</code></p>
</li>
<li><p><code>grid-row-end</code></p>
<p>以上属性指定元素从哪条线放置到哪条线。属性值为分隔线序号。</p>
<p>也可以使用缩写形式:</p>
</li>
<li><p><code>grid-column</code></p>
</li>
<li><p><code>grid-row</code></p>
</li>
</ul>
<p>序号之间需要使用 <code>/</code> 分开。</p>
<h5 id="使用-grid-template-areas-放置元素"><a href="#使用-grid-template-areas-放置元素" class="headerlink" title="使用 grid-template-areas 放置元素"></a>使用 <code>grid-template-areas</code> 放置元素</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'header header'</span> <span class="string">'sidebar content'</span> <span class="string">'footer footer'</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-24/image-20201024145718630.png" alt="image-20201024145718630"></p>
<p>你需要填满网格的每个格子，对于横跨多个格子的元素，需要重复写该元素的区域名。每个区域名只能出现在一个连续的区域。一个连续的区域必须是一个矩形。使用 <code>.</code> 符号让格子留空。</p>
<h5 id="手动实现网格系统"><a href="#手动实现网格系统" class="headerlink" title="手动实现网格系统"></a>手动实现网格系统</h5><p>在过去，一般使用浮动来手动实现网格。给出外部容器的总宽度，使用 <code>12</code> 列布局，计算出每个网格的宽度，然后配置一个网格类。</p>
<p>但这样的网格系统宽度固定，若是想要实现流体网格，需要使用百分比单位。</p>
<p>将固定值除以预设的外部容器宽度得到百分比进行替换。同时给予外部容器 <code>width</code> 百分比与 <code>max-width</code> 预设值。</p>
<p>手动实现网格的方式无法控制跨越行，且难以控制元素的高度。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 23</title>
    <url>/2020/10/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-23/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-23"><a href="#学习笔记-2020-10-23" class="headerlink" title="学习笔记 2020-10-23"></a>学习笔记 2020-10-23</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h3><h4 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h4><p>代理是目标对象的抽象。</p>
<p>使用 <code>Proxy</code> 构造函数创建代理。这个构造函数接收两个参数：目标对象和处理程序对象。两个参数都是必须的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">'target'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// id 属性会访问同一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// target</span></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为两个对象访问的是同一个值</span></span><br><span class="line">target.id = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.id = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="comment">// 都会应用到目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">'id'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.hasOwnProperty(<span class="string">'id'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined</span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype 'undefined' in instanceof check</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype 'undefined' in instanceof check</span></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="built_in">console</span>.log(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>使用代理的主要目的是可以定义 <strong>捕获器</strong> 。捕获器就是在处理程序对象中定义的 <strong>“基本操作的拦截器”</strong> 。每次在代理对象上调用捕获器对应的基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<p>定义 <code>get()</code> 捕获器。在代理对象上 <code>proxy[property]</code> 、 <code>proxy.property</code> 或 <code>object.create(proxy)[property]</code> 等操作都会触发基本的 <code>get()</code> 操作以获取属性。</p>
<p>捕获器接收三个参数，目标对象、要查询的属性和代理对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(trapTarget, property, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(trapTarget === target);</span><br><span class="line">    <span class="built_in">console</span>.log(property);</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以使用全局 <code>Reflect</code> 对象的同名方法来重建原始操作。</p>
<p>处理程序对象中所有可以捕获的方法都有对应的 <code>Reflect</code> <code>API</code> 方法。这些方法与拦截器捕获的方法具有相同的名称和函数签名，具有与被拦截方法相同的行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const handler = &#123; </span></span><br><span class="line"><span class="comment">//   get: Reflect.get </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>创建一个可以捕获所有方法，每个方法都转发给对应反射 <code>API</code> 的空代理，只需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, <span class="built_in">Reflect</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><p>捕获处理程序的行为必须遵守 <strong>”捕获器不变式“</strong> 。</p>
<p>例如，目标对象有一个不可配置且不可写的数据属性。捕获器在返回一个与该属性不同的值时，会抛出 <code>TypeError</code> 。</p>
<h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><p>普通代理对象与目标对象之间的联系会在代理对象的生命周期内一直持续存在。</p>
<p><code>Proxy</code> 暴露了 <code>revocable()</code> 方法。这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。撤销函数是幂等的，调用多少次的结果都一样。撤销代理之后再次调用代理会抛出 <code>TypeError</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'intercepted'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// intercepted</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h4 id="实用反射-API"><a href="#实用反射-API" class="headerlink" title="实用反射 API"></a>实用反射 <code>API</code></h4><ol>
<li><p>反射 <code>API</code> 和对象 <code>API</code></p>
<p>反射 <code>API</code> 并不限于捕获处理程序。大多数反射 <code>API</code> 在 <code>Object</code> 类型上有对应的方法。</p>
</li>
<li><p>状态标记</p>
<p>很多反射方法返回称作 <strong>”状态标记“</strong> 的布尔值，表示意图执行的操作是否成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o, <span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failure'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(o, <span class="string">'foo'</span>, &#123; <span class="attr">value</span>: <span class="string">'bar'</span> &#125;)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failure'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下方法都会提供状态标记：</p>
<ul>
<li><code>Reflect.defineProperty()</code></li>
<li><code>Reflect.preventExtensions()</code></li>
<li><code>Reflect.setPrototypeOf()</code></li>
<li><code>Reflect.set()</code></li>
<li><code>Reflect.deleteProperty()</code></li>
</ul>
</li>
<li><p>用一等函数替代操作符</p>
<p>以下反射方法提供只有通过操作符才能完成的操作：</p>
<ul>
<li><code>Reflect.get()</code> 可以替代对象属性访问操作符。</li>
<li><code>Reflect.set()</code> 可以替代 = 赋值操作符。</li>
<li><code>Reflect.has()</code> 可以替代 <code>in</code> 操作符或 <code>with()</code> 。</li>
<li><code>Reflect.deleteProperty()</code> 可以替代 <code>delete</code> 操作符。</li>
<li><code>Reflect.construct()</code> 可以替代 <code>new</code> 操作符。</li>
</ul>
</li>
<li><p>安全地应用函数</p>
<p>在通过 <code>apply</code> 方法调用函数时，被调用的函数可能也定义了自己的 <code>apply</code> 属性。为绕过这个问题，可以使用定义在 <code>Function</code> 原型上的 <code>apply</code> 方法，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h4><p>通过代理另一个代理，可以形成多层代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first proxy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(firstProxy, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second proxy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(secondProxy.foo);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<h4 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h4><ol>
<li><p>代理的 <code>this</code> 问题</p>
<p>方法中的 <code>this</code> 指向调用这个方法的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  thisValEqualsProxy() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> === proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(target.thisValEqualsProxy()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.thisValEqualsProxy()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>调用代理上的任何方法，比如 <code>proxy.outerMethod()</code> ，而这个方法又会调用另一个方法， <code>this.innerMethod()</code> 。实际上会调用 <code>proxy.innerMethod()</code> 。当目标对象依赖于对象标识，就会出现意外。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> id(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> id() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <code>WeakMap</code> 实例被代理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> id(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> id() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.id); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(userInstanceProxy.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>User</code> 实例一开始使用目标对象作为 <code>WeakMap</code> 的键。代理对象尝试从自身取得这个实例。换句话说，构造函数中设置 <code>wm</code> 中的键名为 <code>user</code> 实例。代理对象获取时却使用自身来作为键名获取，自然无法获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> id(userId) &#123;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> id() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserClassProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> UserClassProxy(<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxyUser.id); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>把代理 <code>User</code> 实例改为代理 <code>User</code> 类本身。此时使用的键名就是代理的实例。</p>
</li>
<li><p>代理与内部槽位</p>
<p>代理与内置引用类型的实例通常可以很好地协同。但有些内置类型可能会依赖代理无法控制的机制，导致在代理上调用某些方法会出错。</p>
<p>例如 <code>Date</code> 类型。根据 <code>ECMAScript</code> 规范，该类型方法的执行依赖 <code>this</code> 值上的内部槽位 <code>[[NumberDate]]</code> 。代理对象上不存在这个内部槽位，这个内部槽位的值也不能通过普通的 <code>get()</code> 和 <code>set()</code> 操作访问到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Date</span>); <span class="comment">// true</span></span><br><span class="line">proxy.getDate(); <span class="comment">// TypeError: 'this' is not a Date objec</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="MDN-学习记录"><a href="#MDN-学习记录" class="headerlink" title="MDN 学习记录"></a>MDN 学习记录</h2><h4 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h4><p>使用 <code>object-fit</code> 属性，可以设置替换元素以不同方式调整到合乎盒子的大小。</p>
<ul>
<li><code>cover</code> 使图片覆盖盒子</li>
<li><code>contain</code> 使图片完全展示在盒子内部</li>
<li><code>fill</code> 不按比例放缩来覆盖盒子</li>
</ul>
<p>在一些浏览器中，表单元素默认不会继承字体样式。</p>
<p>不同浏览器中，对于 <code>form</code> 元素使用不同的盒子模型。</p>
<p>对表格设置 <code>css</code> 属性 <code>table-layout</code> 为 <code>fixed</code> ，然后可以自定义 <code>thead</code> 中的单元格宽度。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 22</title>
    <url>/2020/10/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-22/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-22"><a href="#学习笔记-2020-10-22" class="headerlink" title="学习笔记 2020-10-22"></a>学习笔记 2020-10-22</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h5><ol>
<li><p>实例成员</p>
</li>
<li><p>原型方法与访问器</p>
<p>在类块中定义的方法作为原型方法。</p>
<p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据。</p>
<p>类方法等同于对象属性，可以使用字符串、符号或计算的值作为键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">'symbolKey'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  stringKey() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'invoked stringKey'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  [symbolKey]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'invoked symbolKey'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="string">'computed'</span> + <span class="string">'Key'</span>]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'invoked computedKey'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.stringKey(); <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey](); <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.computedKey(); <span class="comment">// invoked computedKey</span></span><br></pre></td></tr></table></figure>

<p>类定义也支持获取和设置访问器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name_ = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'Jake'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态类方法</p>
<p>静态类成员在类定义中使用 <code>static</code> 关键字作为前缀。在静态成员中， <code>this</code> 引用类自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="keyword">this</span>.locate = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'instance'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">  locate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prototype'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类本身上</span></span><br><span class="line">  <span class="keyword">static</span> locate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'class'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">'123'</span>;</span><br><span class="line">  <span class="keyword">static</span> age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.locate(); <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line">Person.prototype.locate(); <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line">Person.locate(); <span class="comment">// class, class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name);</span><br><span class="line"><span class="built_in">console</span>.log(Person.age);</span><br></pre></td></tr></table></figure>

<p>静态类方法适合作为实例工厂：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age_ = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="comment">// 使用随机年龄创建并返回一个 Person 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.create()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非函数原型和类成员</p>
<p>在类的外部，可以给原型手动添加属性。</p>
</li>
<li><p>迭代器与生成器语法</p>
<p>类定义语法支持在原型和类本身上定义生成器方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">  *createNicknameIterator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Jack'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Jake'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'J-Dog'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">  <span class="keyword">static</span> *createJobIterator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Butcher'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Baker'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Candlestick maker'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jobIter = Person.createJobIterator();</span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Butcher</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Baker</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Candlestick maker</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.createNicknameIterator();</span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jake</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

<p>也可以添加一个默认的迭代器，把类实例变成可迭代对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nicknames = [<span class="string">'Jack'</span>, <span class="string">'Jake'</span>, <span class="string">'J-Dog'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="keyword">this</span>.nicknames.entries();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nicknames = [<span class="string">'Jack'</span>, <span class="string">'Jake'</span>, <span class="string">'J-Dog'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nicknames.entries();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><code>ES6</code> 的类继承使用了新语法，但背后依然使用原型链。</p>
<ol>
<li><p>继承基础</p>
<p><code>ES6</code> 类支持单继承。使用 <code>extends</code> 关键字，就可以继承任何拥有 <code>[[Construct]]</code> 和原型的对象。不仅可以继承一个类，也可以继承普通的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Engineer();</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>派生类可以通过原型链访问到类和原型上定义的方法。</p>
<p><code>extends</code> 关键字也可以在类表达式中使用。</p>
</li>
<li><p>构造函数、 <code>HomeObject</code> 和 <code>super()</code></p>
<p>在派生类的构造函数中调用 <code>super</code> 来调用父类构造函数。也可以通过 <code>super</code> 来调用继承的类上定义的静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">'123'</span>;</span><br><span class="line">  <span class="keyword">static</span> identify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'vehicle'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> identify() &#123;</span><br><span class="line">    <span class="keyword">super</span>.identify();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.name); <span class="comment">// 123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bus.identify(); <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure>

<p><code>ES6</code> 给类构造函数和静态方法添加了内部特性 <code>[[HomeObject]]</code> ，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，只能在 <code>JavaScript</code> 引擎内部访问。 <code>super</code> 始终会定义为 <code>[[HomeObject]]</code> 的原型。</p>
<ul>
<li><code>super</code> 只能在派生类构造函数和静态方法中使用。</li>
<li>不能单独引用 <code>super</code> 关键字，要么用它调用构造函数，要么用它引用静态方法。</li>
<li>调用 <code>super()</code> 会调用父类构造函数，并将返回的实例赋值给 <code>this</code> 。</li>
<li><code>super()</code> 的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</li>
<li>如果没有定义类构造函数，在实例化派生类时会调用 <code>super()</code> ，而且会传入所有传给派生类的参数。</li>
<li>在类构造函数中，不能在调用 <code>super()</code> 之前引用 <code>this</code> 。</li>
<li>如果派生类显式定义了构造函数，则必须调用 <code>super()</code> ，要么必须在其中返回一个对象。</li>
</ul>
</li>
<li><p>抽象基类</p>
<p>抽象基类是指可被其他类继承但自身不会被实例化的类。 <code>ECMAScript</code> 中没有专门支持这种类的语法。但可以通过 <code>new.target</code> 来实现。</p>
<p><code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数。通过在实例化时检查 <code>new.target</code> 是不是抽象基类，可以阻止对抽象基类的实例化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Vehicle cannot be directly instantiated'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Vehicle(); <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>

<p>可以通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Vehicle cannot be directly instantiated'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.foo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Inheriting class must define foo()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> Van(); <span class="comment">// Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure>

<p>此处的原理是原型函数在调用类构造函数之前就已经存在，以此来进行判断。</p>
</li>
<li><p>继承内置类型</p>
<p><code>ES6</code> 类可以方便地拓展内置类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  shuffle() &#123;</span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">      [<span class="keyword">this</span>[i], <span class="keyword">this</span>[j]] = [<span class="keyword">this</span>[j], <span class="keyword">this</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.shuffle();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>内置类型的方法返回了新的实例，该实例类型依然保持不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以通过覆盖 <code>Symbol.species</code> 访问器来覆盖这个默认行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类混入</p>
<p>把不同类的行为集中到一个类是一种常见的 <code>JavaScript</code> 模式。<code>ES6</code> 没有显式支持多类继承，但可以通过现有特征模拟。</p>
<p><code>extends</code> 后可以跟任何能够解析为一个类或一个构造函数的表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'evaluated expression'</span>);</span><br><span class="line">  <span class="keyword">return</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">getParentClass</span>() </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可求值的表达式</span></span><br></pre></td></tr></table></figure>

<p>多类继承可以通过嵌套多个函数来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    baz() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">FooMixin</span>(<span class="title">BarMixin</span>(<span class="title">BazMixin</span>(<span class="title">Vehicle</span>))) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo(); <span class="comment">// foo</span></span><br><span class="line">b.bar(); <span class="comment">// bar</span></span><br><span class="line">b.baz(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>也可以通过辅助函数来展开嵌套调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function"><span class="params">Superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    baz() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mixins.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> current(accumulator), BaseClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo(); <span class="comment">// foo</span></span><br><span class="line">b.bar(); <span class="comment">// bar</span></span><br><span class="line">b.baz(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多 <code>JS</code> 框架 (例如 <code>React</code> ) 已经抛弃混入模式，转向了组合模式。把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承。</p>
</blockquote>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><h4 id="你好，对象"><a href="#你好，对象" class="headerlink" title="你好，对象"></a>你好，对象</h4><p>按下面的要求写代码，一条对应一行代码：</p>
<ol>
<li>创建一个空的对象 <code>user</code>。</li>
<li>为这个对象增加一个属性，键是 <code>name</code>，值是 <code>John</code>。</li>
<li>再增加一个属性，键是 <code>surname</code>，值是 <code>Smith</code>。</li>
<li>把键为 <code>name</code> 的属性的值改成 <code>Pete</code>。</li>
<li>删除这个对象中键为 <code>name</code> 的属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">user.name = <span class="string">'John'</span>;</span><br><span class="line">user.surname = <span class="string">'Smith'</span>;</span><br><span class="line">user.name = <span class="string">'Pete'</span>;</span><br><span class="line"><span class="keyword">delete</span> user.name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查空对象</p>
<p>写一个 <code>isEmpty(obj)</code> 函数，当对象没有属性的时候返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>应该像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> schedule = &#123;&#125;;</span><br><span class="line">alert( isEmpty(schedule) ); <span class="comment">// true</span></span><br><span class="line">schedule[<span class="string">"8:30"</span>] = <span class="string">"get up"</span>;</span><br><span class="line">alert( isEmpty(schedule) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象属性求和</p>
<p>我们有一个保存着团队成员工资的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> salaries = &#123;</span><br><span class="line">  John: <span class="number">100</span>,</span><br><span class="line">  Ann: <span class="number">160</span>,</span><br><span class="line">  Pete: <span class="number">130</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一段代码求出我们的工资总和，将计算结果保存到变量 <code>sum</code>。从所给的信息来看，结果应该是 <code>390</code>。</p>
<p>如果 <code>salaries</code> 是一个空对象，那结果就为 <code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> salaries) &#123;</span><br><span class="line">  sum += salaries[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数值属性都乘以2</p>
<p>创建一个 <code>multiplyNumeric(obj)</code> 函数，把 <code>obj</code> 所有的数值属性都乘以 <code>2</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在调用之前</span></span><br><span class="line"><span class="keyword">let</span> menu = &#123;</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">300</span>,</span><br><span class="line">  title: <span class="string">"My menu"</span></span><br><span class="line">&#125;;</span><br><span class="line">multiplyNumeric(menu);</span><br><span class="line"><span class="comment">// 调用函数之后</span></span><br><span class="line">menu = &#123;</span><br><span class="line">  width: <span class="number">400</span>,</span><br><span class="line">  height: <span class="number">600</span>,</span><br><span class="line">  title: <span class="string">"My menu"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意 <code>multiplyNumeric</code> 函数不需要返回任何值，它应该就地修改对象。</p>
<p>P.S. 用 <code>typeof</code> 检查值类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyNumeric</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = obj[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prev === <span class="string">'number'</span>) &#123;</span><br><span class="line">      obj[key] = prev * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="MDN-学习记录"><a href="#MDN-学习记录" class="headerlink" title="MDN 学习记录"></a>MDN 学习记录</h2><h3 id="重设所有属性值"><a href="#重设所有属性值" class="headerlink" title="重设所有属性值"></a>重设所有属性值</h3><p>可以设置一个属性叫 <code>all</code> ，来进行所有属性的修改，值可以是 <code>inherit</code> <code>initial</code> <code>unset</code> <code>revert</code> 。</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>在 <code>CSS</code> 规则中，一个选择器无效，该选择器所对应的属性都将不生效。</p>
<h3 id="值选择器"><a href="#值选择器" class="headerlink" title="值选择器"></a>值选择器</h3><p>这些选择器允许基于一个元素自身是否存在（例如<code>href</code>）或者基于各式不同的按属性值的匹配，来选取元素。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[attr=value]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr~=value]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素 ，其值正为 <code>value</code> ，或者匹配带有一个 <code>attr</code> 属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">`[attr</td>
<td align="left">=value]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Attribute presence and value selectors<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"a b"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"ab"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"a-c"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class="a"]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class~="a"]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class|="a"]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-22/image-20201022130858506.png" alt="image-20201022130858506"></p>
<h3 id="子字符串匹配选择器"><a href="#子字符串匹配选择器" class="headerlink" title="子字符串匹配选择器"></a>子字符串匹配选择器</h3><p>这些选择器让更高级的属性的值的子字符串的匹配变得可行。例如，如果你有<code>box-warning</code>和<code>box-error</code>类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用<code>[class^=&quot;box-&quot;]</code>来把它们两个都选中。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr^=value]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素，其值开头为 <code>value</code> 子字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr$=value]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素，其值结尾为 <code>value</code> 子字符串</td>
</tr>
<tr>
<td align="left"><code>[attr*=value]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为 <code>attr</code> 的属性的元素，其值的字符串中的任何地方，至少出现了一次 <code>value</code> 子字符串。</td>
</tr>
</tbody></table>
<h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><p>可以在中括号内，匹配条件后加入 <code>i</code> 表示忽略大小写。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^="a"]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^="a" i]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active" target="_blank" rel="noopener"><code>:active</code></a></td>
<td align="left">在用户激活（例如点击）元素的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link" target="_blank" rel="noopener"><code>:any-link</code></a></td>
<td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank" target="_blank" rel="noopener"><code>:blank</code></a></td>
<td align="left">匹配空输入值的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input" target="_blank" rel="noopener"><code>&lt;input&gt;</code>元素</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked" target="_blank" rel="noopener"><code>:checked</code></a></td>
<td align="left">匹配处于选中状态的单选或者复选框。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:current" target="_blank" rel="noopener"><code>:current</code></a></td>
<td align="left">匹配正在展示的元素，或者其上级元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default" target="_blank" rel="noopener"><code>:default</code></a></td>
<td align="left">匹配一组相似的元素中默认的一个或者更多的UI元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir" target="_blank" rel="noopener"><code>:dir</code></a></td>
<td align="left">基于其方向性（HTML<code>dir</code>属性或者CSS<code>direction</code>属性的值）匹配一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled" target="_blank" rel="noopener"><code>:disabled</code></a></td>
<td align="left">匹配处于关闭状态的用户界面元素</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty" target="_blank" rel="noopener"><code>:empty</code></a></td>
<td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled" target="_blank" rel="noopener"><code>:enabled</code></a></td>
<td align="left">匹配处于开启状态的用户界面元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first" target="_blank" rel="noopener"><code>:first</code></a></td>
<td align="left">匹配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media" target="_blank" rel="noopener">分页媒体</a>的第一页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child" target="_blank" rel="noopener"><code>:first-child</code></a></td>
<td align="left">匹配兄弟元素中的第一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type" target="_blank" rel="noopener"><code>:first-of-type</code></a></td>
<td align="left">匹配兄弟元素中第一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus" target="_blank" rel="noopener"><code>:focus</code></a></td>
<td align="left">当一个元素有焦点的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible" target="_blank" rel="noopener"><code>:focus-visible</code></a></td>
<td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within" target="_blank" rel="noopener"><code>:focus-within</code></a></td>
<td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:future" target="_blank" rel="noopener"><code>:future</code></a></td>
<td align="left">匹配当前元素之后的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover" target="_blank" rel="noopener"><code>:hover</code></a></td>
<td align="left">当用户悬浮到一个元素之上的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate" target="_blank" rel="noopener"><code>:indeterminate</code></a></td>
<td align="left">匹配未定态值的UI元素，通常为<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox" target="_blank" rel="noopener">复选框</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range" target="_blank" rel="noopener"><code>:in-range</code></a></td>
<td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid" target="_blank" rel="noopener"><code>:invalid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang" target="_blank" rel="noopener"><code>:lang</code></a></td>
<td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang" target="_blank" rel="noopener">lang</a>属性的值）匹配元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child" target="_blank" rel="noopener"><code>:last-child</code></a></td>
<td align="left">匹配兄弟元素中最末的那个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type" target="_blank" rel="noopener"><code>:last-of-type</code></a></td>
<td align="left">匹配兄弟元素中最后一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left" target="_blank" rel="noopener"><code>:left</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Pages" target="_blank" rel="noopener">分页媒体</a>中，匹配左手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link" target="_blank" rel="noopener"><code>:link</code></a></td>
<td align="left">匹配未曾访问的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:local-link" target="_blank" rel="noopener"><code>:local-link</code></a></td>
<td align="left">匹配指向和当前文档同一网站页面的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is" target="_blank" rel="noopener"><code>:is()</code></a></td>
<td align="left">匹配传入的选择器列表中的任何选择器。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not" target="_blank" rel="noopener"><code>:not</code></a></td>
<td align="left">匹配作为值传入自身的选择器未匹配的物件。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child" target="_blank" rel="noopener"><code>:nth-child</code></a></td>
<td align="left">匹配一列兄弟元素中的元素——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type" target="_blank" rel="noopener"><code>:nth-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child" target="_blank" rel="noopener"><code>:nth-last-child</code></a></td>
<td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type" target="_blank" rel="noopener"><code>:nth-last-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child" target="_blank" rel="noopener"><code>:only-child</code></a></td>
<td align="left">匹配没有兄弟元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type" target="_blank" rel="noopener"><code>:only-of-type</code></a></td>
<td align="left">匹配兄弟元素中某类型仅有的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional" target="_blank" rel="noopener"><code>:optional</code></a></td>
<td align="left">匹配不是必填的form元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range" target="_blank" rel="noopener"><code>:out-of-range</code></a></td>
<td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:past" target="_blank" rel="noopener"><code>:past</code></a></td>
<td align="left">匹配当前元素之前的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown" target="_blank" rel="noopener"><code>:placeholder-shown</code></a></td>
<td align="left">匹配显示占位文字的input元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:playing" target="_blank" rel="noopener"><code>:playing</code></a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:paused" target="_blank" rel="noopener"><code>:paused</code></a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only" target="_blank" rel="noopener"><code>:read-only</code></a></td>
<td align="left">匹配用户不可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write" target="_blank" rel="noopener"><code>:read-write</code></a></td>
<td align="left">匹配用户可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required" target="_blank" rel="noopener"><code>:required</code></a></td>
<td align="left">匹配必填的form元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right" target="_blank" rel="noopener"><code>:right</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Pages" target="_blank" rel="noopener">分页媒体</a>中，匹配右手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root" target="_blank" rel="noopener"><code>:root</code></a></td>
<td align="left">匹配文档的根元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope" target="_blank" rel="noopener"><code>:scope</code></a></td>
<td align="left">匹配任何为参考点元素的的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid" target="_blank" rel="noopener"><code>:valid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target" target="_blank" rel="noopener"><code>:target</code></a></td>
<td align="left">匹配当前URL目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier" target="_blank" rel="noopener">URL分段</a>的元素）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited" target="_blank" rel="noopener"><code>:visited</code></a></td>
<td align="left">匹配已访问链接。</td>
</tr>
</tbody></table>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after" target="_blank" rel="noopener"><code>::after</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before" target="_blank" rel="noopener"><code>::before</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter" target="_blank" rel="noopener"><code>::first-letter</code></a></td>
<td align="left">匹配元素的第一个字母。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line" target="_blank" rel="noopener"><code>::first-line</code></a></td>
<td align="left">匹配包含此伪元素的元素的第一行。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error" target="_blank" rel="noopener"><code>::grammar-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection" target="_blank" rel="noopener"><code>::selection</code></a></td>
<td align="left">匹配文档中被选择的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error" target="_blank" rel="noopener"><code>::spelling-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td>
</tr>
</tbody></table>
<h3 id="书写模式、块级布局和内联布局"><a href="#书写模式、块级布局和内联布局" class="headerlink" title="书写模式、块级布局和内联布局"></a>书写模式、块级布局和内联布局</h3><p>设置 <code>writing-mode</code> 属性可以更改元素的布局方向。</p>
<p><code>writing-mode</code>的三个值分别是：</p>
<ul>
<li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li>
<li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li>
<li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li>
</ul>
<p>书写模式切换时，也在改变块布局和内联布局。</p>
<p>常见的网页是块布局在垂直方向，内联布局在水平方向。</p>
<p>纵向书写模式下块布局在水平方向，内联布局在垂直方向。</p>
<p><img src="https://mdn.mozillademos.org/files/17148/horizontal-tb-zh.png" alt="img"></p>
<p><img src="https://mdn.mozillademos.org/files/17149/vertical-zh.png" alt="img"></p>
<blockquote>
<p>以上图片来源于 MDN</p>
</blockquote>
<h3 id="逻辑属性和逻辑值"><a href="#逻辑属性和逻辑值" class="headerlink" title="逻辑属性和逻辑值"></a>逻辑属性和逻辑值</h3><p>在不同书写模式下， <code>width</code> 和 <code>height</code> 失去了原本的意义，会导致错误的宽高显示。于是诞生了新的概念属性，叫做 <code>inline-size</code> 和 <code>block-size</code> 。分别对应块布局的长度和内联布局的长度。</p>
<p>而外边距、内边距也有了对应的映射属性：</p>
<p><code>margin-top</code> 属性的映射是 <code>margin-block-start</code> ——总是指向块级维度开始处的边距。</p>
<p><code>padding-left</code> 属性映射到 <code>padding-inline-start</code> ，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。</p>
<p><code>border-bottom</code> 属性映射到的是 <code>border-block-end</code> ，也就是块级维度结尾处的边框。</p>
<p>属性中的 <code>top</code> 等值也有逻辑映射值：</p>
<p><code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code> 对应 <code>block-start</code>、<code>inline-end</code>、<code>block-end</code>和<code>inline-start</code>。</p>
<h3 id="HSL-和-HSLA-的值"><a href="#HSL-和-HSLA-的值" class="headerlink" title="HSL 和 HSLA 的值"></a>HSL 和 HSLA 的值</h3><p><code>hsl()</code> 接受色调、饱和度和亮度作为参数。</p>
<ul>
<li><strong>色调</strong>： 颜色的底色。这个值在0和360之间，表示色轮周围的角度。</li>
<li><strong>饱和度</strong>： 颜色有多饱和？ 它的值为0 - 100%，其中0为无颜色(它将显示为灰色阴影)，100%为全色饱和度</li>
<li><strong>亮度</strong>：颜色有多亮？ 它从0 - 100%中获取一个值，其中0表示没有光(它将完全显示为黑色)，100%表示完全亮(它将完全显示为白色)</li>
</ul>
<p><code>hsla()</code> 额外接受一个不透明度通道。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 21</title>
    <url>/2020/10/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-21/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-21"><a href="#学习笔记-2020-10-21" class="headerlink" title="学习笔记 2020-10-21"></a>学习笔记 2020-10-21</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h5><p>原型式继承的方式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// "Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>

<p>继承时创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，返回这个临时类型的一个实例。</p>
<p>这种继承方式适用于你在一个对象的基础上再创建一个新对象的情况。</p>
<p>这种方式已经有了规范化的方法，即 <code>Object.create()</code> 。</p>
<p>这个方法接收两个参数，第一个参数为作为新对象原型的对象，第二个可选参数为给新对象定义额外属性的对象，以这种方式添加的属性会遮蔽原型对象上的同名属性。</p>
<p>原型式继承跟使用原型模式是一样的。</p>
<h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h5><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h5><p>组合继承的效率问题是父类构造函数始终会被调用两次：一次是在创建子类原型时调用，另一次是在子类构造函数中调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p>
<p>即使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">// 增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只调用了一次 <code>SuperType</code> 构造函数，避免了 <code>SubType.prototype</code> 上不必要也用不到的属性。原型链保持不变， <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code> 方法正常有效。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p><code>ES6</code> 新引入了 <code>class</code> 关键字来正式定义类。</p>
<h5 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h5><p>类可以使用声明或是表达式来定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>并且类定义无法提升，且受块作用域限制。</p>
<p>类表达式有可选的名称，在类表达式作用域内部可以使用 <code>name</code> 属性取得名称字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Person.name, PersonName.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.identify(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName); <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>

<h5 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h5><p><code>constructor</code> 关键字用于定义类的构造函数。构造函数的定义是可选的，不创建相当于定义为空函数。</p>
<p>使用 <code>new</code> 操作符实例化相当于调用了其构造函数。</p>
<p>使用 <code>new</code> 调用类的构造函数会执行如下操作：</p>
<ol>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的 <code>[[Prototype]]</code> 指针被赋值为构造函数的 <code>prototype</code> 属性。</li>
<li>构造函数内部的 <code>this</code> 被赋值为这个新对象。</li>
<li>执行构造函数内部的代码。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象。</li>
</ol>
<p>调用类构造函数如果忘了使用 <code>new</code> 会抛出错误。</p>
<p>在 <code>ECMAScript</code> 中没有正式的类这个类型。可以把 <code>class</code> 理解为一种特殊函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person); <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>类标识符有 <code>prototype</code> 属性，而原型有一个 <code>constructor</code> 属性指向类本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person.constructor); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person.constructor();</span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类可以像其他对象或函数引用一样作为参数传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">  <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id_ = id;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`instance <span class="subst">$&#123;<span class="keyword">this</span>.id_&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classDefinition, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classDefinition(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = createInstance(classList[<span class="number">0</span>], <span class="number">3141</span>); <span class="comment">// instance 3141</span></span><br></pre></td></tr></table></figure>

<p>类也可以立即实例化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> (<span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'bar'</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h5><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<ol>
<li><p>实例成员</p>
<p>在构造函数内部可以定义实例成员。</p>
</li>
</ol>
<h2 id="MDN学习记录"><a href="#MDN学习记录" class="headerlink" title="MDN学习记录"></a>MDN学习记录</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格标签：</p>
<ul>
<li><code>table</code></li>
<li><code>tr</code> table row</li>
<li><code>td</code> table description</li>
<li><code>th</code> table header</li>
<li><code>caption</code> 标题</li>
<li><code>thead</code> 表格头部结构</li>
<li><code>tfoot</code> 表格尾部结构</li>
<li><code>tbody</code> 表格主体结构</li>
</ul>
<p>最后三个标签不需要按顺序放置。</p>
<p>单元格跨越多行和列的方法是在需要变长或变高的单元格 <code>td</code> 标签上设置 <code>colspan</code> 和 <code>rowspan</code> 属性。</p>
<h4 id="为表格中的列提供相同样式"><a href="#为表格中的列提供相同样式" class="headerlink" title="为表格中的列提供相同样式"></a>为表格中的列提供相同样式</h4><p>设置 <code>col</code> 和 <code>colgroup</code> 标签可以给表格的列设置相同的属性。会作用在对应的那一列上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">"background-color: yellow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Calcutta<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Robots<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jazz<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-21/image-20201021144251069.png" alt="表格演示"></p>
<h4 id="scope-属性"><a href="#scope-属性" class="headerlink" title="scope 属性"></a><code>scope</code> 属性</h4><p>可以在 <code>th</code> 元素中添加 <code>scope</code> 属性来帮助屏幕阅读设备更好地理解那些标题单元格。</p>
<p>例如，可以表示当前的 <code>th</code> 标签到底是行标题还是列标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"col"</span>&gt;</span>Purchase<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"col"</span>&gt;</span>Location<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"col"</span>&gt;</span>Date<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"col"</span>&gt;</span>Evaluation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"col"</span>&gt;</span>Cost (€)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">"row"</span>&gt;</span>Haircut<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>Hairdresser<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>12/09<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>Great idea<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>scope</code> 还有两个可选的值： <code>colgroup</code> <code>rowgroup</code> 。</p>
<p>还可以使用 <code>id</code> 和 <code>headers</code> 来创建标题与单元格之间的联系。</p>
<ol>
<li>为每个 <code>&lt;th&gt;</code> 元素添加一个唯一的 <code>id</code> 。</li>
<li>为每个 <code>&lt;td&gt;</code> 元素添加一个 <code>headers</code> 属性。需要包含它从属于的所有标题的 <code>id</code> 。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"purchase"</span>&gt;</span>Purchase<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"location"</span>&gt;</span>Location<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"date"</span>&gt;</span>Date<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"evaluation"</span>&gt;</span>Evaluation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"cost"</span>&gt;</span>Cost (€)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">"haircut"</span>&gt;</span>Haircut<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">"location haircut"</span>&gt;</span>Hairdresser<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">"date haircut"</span>&gt;</span>12/09<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">"evaluation haircut"</span>&gt;</span>Great idea<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">"cost haircut"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 20</title>
    <url>/2020/10/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-20/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-20"><a href="#学习笔记-2020-10-20" class="headerlink" title="学习笔记 2020-10-20"></a>学习笔记 2020-10-20</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><ol>
<li><h5 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h5><p>可以通过使用一个包含所有属性和方法的对象字面量来重写原型。</p>
<p>重写后，构造函数原型的 <code>constructor</code> 便不再指向构造函数。必要时可以专门设置，如果选择直接在重写原型对象时写入 <code>constructor</code> ，那么这个属性会被设置为可枚举的。最好选择 <code>Object.defineProperty</code> 来定义这个属性。</p>
</li>
<li><h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>从原型上搜索值的过程是动态的。对原型做了修改，即使是已经被创建出来的实例也可以反映出这个变化。但是如果是重写了构造函数的原型对象的话，原本的实例依然指向最初的原型，而无法反映这个改写的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'Nicholas',</span><br><span class="line">  age: 29,</span><br><span class="line">  job: 'Software Engineer',</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); <span class="comment">// Uncaught TypeError: friend.sayName is not a function</span></span><br></pre></td></tr></table></figure>

<p>原因是对原型做赋值操作，是直接修改了指针指向，但无法修改到已创建实例的原型指针。</p>
</li>
<li><h5 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h5><p>所有原生引用类型都采用原型模式实现。所有原生引用类型的构造函数都在原型上定义了实例方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">'Hello world!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'Hello'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也可以自定义原型对象上的方法。</p>
</li>
<li><h5 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h5><p>原型模式弱化了向构造函数传递初始化参数的能力，会导致所有实例都取得相同的属性值。</p>
<p>原型最大的问题是它的共享特性，原型对象上存在的属性会被所有实例共享，也能被所有实例修改。而不同的实例应该有自己单独的属性副本。</p>
</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承一般分为两种：接口继承和实现继承。<code>ECMAScript</code> 中不存在接口继承，函数没有签名。因此，<code>ECMAScript</code> 支持实现继承，通过原型链实现。</p>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>示例中重写了 <code>SubType</code> 的原型，替换为了 <code>SuperType</code> 的实例。构成了一条原型链。</p>
<ol>
<li><h5 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h5><p>默认情况下，所有引用类型都继承自 <code>Object</code> 。任何函数的默认原型都是一个 <code>Object</code> 的实例。</p>
</li>
<li><h5 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h5><p>原型与实例的关系可以通过 <code>instanceof</code> 操作符确定，只要一个实例的原型链中出现过相应的构造函数，该操作符就会返回 <code>true</code> 。</p>
<p>第二种方法是通过 <code>isPrototypeOf()</code> 方法。由原型链上的原型来调用这个方法，只要被传入的实例参数原型链中包含这个原型，就会返回 <code>true</code> 。</p>
</li>
<li><h5 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h5><p>使用对象字面量的方式创建原型方法会破坏之前的原型链。</p>
</li>
<li><h5 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h5><p>原型链的问题在于原型中包含引用值得时候，该引用值会在所有实例间共享。虽然我们原先是在对象实例上定义属性，但这个类型一旦被继承，它的实例属性就成了子类的原型属性。在这种模式下，我们不能在子类实例化的时候给父类型的构造函数传参。</p>
</li>
</ol>
<h5 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h5><p>为了解决上面提到的问题，引用了一种叫盗用构造函数的技术，也称对象伪装或经典继承。思路为：在子类构造函数中调用父类构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// "red,blue,green,black"</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// "red,blue,green"</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>使用 <code>call</code> 或是 <code>apply</code> 的好处就在于我们可以传参，就实现了子类构造函数给父类构造函数传参。</p>
</li>
<li><h5 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h5><p>问题在于，必须在构造函数中定义方法，函数不能被重用。</p>
</li>
</ol>
<h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>组合继承综合了原型链和盗用构造函数，思路为使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Nicholas'</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// "red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">// "Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Greg'</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// "red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">// "Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p>这样，各个实例有自己的实例属性，也可以共享父类的方法。</p>
<h2 id="MDN学习记录"><a href="#MDN学习记录" class="headerlink" title="MDN学习记录"></a>MDN学习记录</h2><h3 id="lt-video-gt-与-lt-audio-gt"><a href="#lt-video-gt-与-lt-audio-gt" class="headerlink" title="&lt;video&gt; 与 &lt;audio&gt;"></a>&lt;video&gt; 与 &lt;audio&gt;</h3><p>在网页中添加视频或音频可以用 <code>html5</code> 新增的标签，可以直接指定单独的 <code>video</code> 或 <code>audio</code> 标签使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"./friday.mp4"</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>src</code> 属性指定视频源， <code>controls</code>  指定是否展示控制条。</p>
<p>但因为视频格式多种多样，不同浏览器采用的编码器不一样，所以我们要尽可能兼容各种格式的视频。可以在 <code>video</code> 标签内部放入 <code>source</code> 标签来指定不同的视频源。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"./friday.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"friday.mp4"</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当浏览器解析时会寻找匹配的视频格式来解码。同时可以在内部放入一个后备内容用于视频不可用时的展示。</p>
<p><code>video</code> 标签的其余属性：</p>
<ul>
<li><p><code>width</code> <code>height</code> </p>
<p>可以手动设定视频的宽高。</p>
</li>
<li><p><code>autoplay</code></p>
<p>视频加载完后自动播放。</p>
</li>
<li><p><code>loop</code></p>
<p>视频循环播放。</p>
</li>
<li><p><code>muted</code></p>
<p>视频默认关闭声音。</p>
</li>
<li><p><code>poster</code></p>
<p>指定视频播放前的视频封面。</p>
</li>
<li><p><code>preload</code></p>
<p>用于缓冲较大的文件：</p>
<ul>
<li><code>none</code> 不缓冲。</li>
<li><code>auto</code> 页面加载后缓冲媒体文件。</li>
<li><code>metadata</code> 仅缓冲文件的元数据。</li>
</ul>
</li>
</ul>
<p><code>audio</code> 标签与 <code>video</code> 类似，但没有 <code>width/height</code> 属性，不支持 <code>poster</code> 属性。</p>
<p>两个标签对应的 <code>dom</code> 元素都可以调用 <code>load()</code> 方法来重置播放。</p>
<p>可以通过监听 <code>addtrack</code> 事件来监听音频轨道的增删。</p>
<p><code>video</code> 标签支持显示音轨文本，配置一个音轨文本的 <code>vtt</code> 文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">WEBVTT</span><br><span class="line"></span><br><span class="line">00:00:00.000 --&gt; 00:00:00.999  line:80<span class="comment">%</span></span><br><span class="line">Hildy!</span><br><span class="line"></span><br><span class="line">00:00:01.000 --&gt; 00:00:01.499 line:80<span class="comment">%</span></span><br><span class="line">How are you?</span><br><span class="line"></span><br><span class="line">00:00:01.500 --&gt; 00:00:02.999 line:80<span class="comment">%</span></span><br><span class="line">Tell me, is the lord of the universe in?</span><br><span class="line"></span><br><span class="line">00:00:03.000 --&gt; 00:00:04.299 line:80<span class="comment">%</span></span><br><span class="line">Yes, he's in - in a bad humor</span><br><span class="line"></span><br><span class="line">00:00:04.300 --&gt; 00:00:06.000 line:80<span class="comment">%</span></span><br><span class="line">Somebody must've stolen the crown jewels</span><br></pre></td></tr></table></figure>

<p>然后在 <code>video</code> 中配置 <code>track</code> 标签指明音轨文本来源。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">muted</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"./friday.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">default</span> <span class="attr">kind</span>=<span class="string">"captions"</span> <span class="attr">srclang</span>=<span class="string">"en"</span> <span class="attr">src</span>=<span class="string">"friday.vtt"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"rabbit320.mp4"</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-20/20201020_181134.gif" alt="视频预览"></p>
<h3 id="lt-picture-gt"><a href="#lt-picture-gt" class="headerlink" title="&lt;picture&gt;"></a>&lt;picture&gt;</h3><p><code>picture</code> 标签可用于响应式图片。但 <code>img</code> 本身也支持这个功能，先看一下 <code>img</code> 的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"elva-480w.jpg 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-800w.jpg 800w"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">"(max-width: 320px) 280px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            (max-width: 480px) 440px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            800px"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">"elva-800w.jpg"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>srcset</code> 指定了图像集以及每张图片的大小，此处的 <code>480w</code> 指的是图片真实宽度为 <code>480px</code> 。</p>
<p><code>sizes</code> 指定了一组媒体条件，当某个媒体条件为真时，它对应的宽度会赋给该 <code>img</code> 标签。</p>
<p>在多次测试这个功能后，我发现 <code>img</code> 的标签的响应式选择图片仅在<strong>初次加载</strong>时执行。</p>
<p>也就是说，浏览器只会在第一次加载时来根据设备宽度选择图片，在此之后无论设备宽度如何变化，它只会根据我们设定好的条件来改变图片的大小而不会更换图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述这个元数据标签指定了浏览器采用真实可视宽度来加载网页。</p>
<p>也可以实现相同尺寸不同分辨率的情况。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"elva-480w.jpg,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-800w.jpg 2x"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">"elva-800w.jpg"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子去掉了 <code>sizes</code> 。我们不修改 <code>img</code> 标签的大小。在不同尺寸下加载不同图片，以适应不同分辨率的设备更好的显示。</p>
<h4 id="响应式切换"><a href="#响应式切换" class="headerlink" title="响应式切换"></a>响应式切换</h4><p>如果需要完成响应式切换图片的话，需要使用 <code>picture</code> 标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width: 799px)"</span> <span class="attr">srcset</span>=<span class="string">"elva-480w.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(min-width: 800px)"</span> <span class="attr">srcset</span>=<span class="string">"elva-800w.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"elva-800w.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>picture</code> 标签内部使用 <code>source</code> 标签指定图片， <code>media</code> 属性设置激活的媒体条件， <code>srcset</code> 指定生效的图片。</p>
<p>最后的 <code>img</code> 标签作为后备内容。</p>
<h3 id="Mozilla醒目页面"><a href="#Mozilla醒目页面" class="headerlink" title="Mozilla醒目页面"></a>Mozilla醒目页面</h3><p>实现一个网页，在设备宽度不同的情况下，加载不同的图片。</p>
<p><img src="/2020/10/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-20/image-20201020193827564.png" alt="设备宽度大于 600px"></p>
<p><img src="/2020/10/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-20/image-20201020193841095.png" alt="图片小于 480px"></p>
<p>在设备宽度小于 <code>480px</code> 时，四个导航的图片加载 <code>120px</code> 版本。</p>
<p>大于 <code>480px</code> 时，加载 <code>400px</code> 版本。</p>
<p>宽度小于 <code>600px</code> 时，加载 <code>600px</code> 版本的小熊猫图片，否则加载 <code>1200px</code> 版本。</p>
<p>列出主要代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"./images/firefoxlogo120.png 120w, ./images/firefoxlogo400.png 400w"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">"(max-width: 480px) 120px,</span></span></span><br><span class="line"><span class="tag"><span class="string">         (min-width: 481px) 400px"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"./images/firefoxlogo400.png"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"./images/redpanda600.jpg"</span> <span class="attr">media</span>=<span class="string">"(max-width: 600px)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"./images/redpanda1200.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 601px)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/redpanda1200.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 19</title>
    <url>/2020/10/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-19/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-19"><a href="#学习笔记-2020-10-19" class="headerlink" title="学习笔记 2020-10-19"></a>学习笔记 2020-10-19</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>每个函数都有一个 <code>prototype</code> 属性。这个属性是一个包含应该由特定引用类型的实例共享的属性和方法的对象。这个对象就是通过调用构造函数创建的对象的原型。在原型对象上定义的属性和方法可以被对象实例共享。</p>
<ol>
<li><h5 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h5><p>创建一个函数，按照特定的规则为这个函数创建一个 <code>prototype</code> 的属性。默认情况下，所有原型对象自动获得一个 <code>constructor</code> 属性，指回与之关联的构造函数。如，<code>Person.prototype.constructor</code> 指向 <code>Person</code> 。</p>
<p>自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其他的所有方法都继承自 <code>Object</code> 。调用构造函数创建的新实例，这个实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象。<code>Firefox</code> 、<code>Safari</code> 和 <code>Chrome</code> 会在对象上暴露 <code>__proto__</code> 属性来访问原型对象。</p>
<p>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数可以是函数表达式</span></span><br><span class="line"><span class="comment"> * 也可以是函数声明，因此以下两种形式都可以：</span></span><br><span class="line"><span class="comment"> * function Person() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * let Person = function() &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个</span></span><br><span class="line"><span class="comment"> * 与之关联的原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// constructor: f Person(),</span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如前所述，构造函数有一个 prototype 属性</span></span><br><span class="line"><span class="comment"> * 引用其原型对象，而这个原型对象也有一个</span></span><br><span class="line"><span class="comment"> * constructor 属性，引用这个构造函数</span></span><br><span class="line"><span class="comment"> * 换句话说，两者循环引用：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于 Object 的原型对象</span></span><br><span class="line"><span class="comment"> * Object 原型的原型是 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// constructor: f Object(),</span></span><br><span class="line"><span class="comment">// toString: ...</span></span><br><span class="line"><span class="comment">// hasOwnProperty: ...</span></span><br><span class="line"><span class="comment">// isPrototypeOf: ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(),</span><br><span class="line">  person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是 3 个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype !== Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment"> * 它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造函数通过 prototype 属性链接到原型对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * instanceof 检查实例的原型链中</span></span><br><span class="line"><span class="comment"> * 是否包含指定构造函数的原型：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>isPrototypeOf()</code> 方法检查是否是该构造函数的实例对象。</p>
<p>可以使用 <code>Object.getPrototypeOf()</code> 方法返回参数的内部特性 <code>[[Prototype]]</code> 的值。</p>
<p>可以使用 <code>setPrototypeOf()</code> 方法来写入原型对象。但该方法可能会严重影响代码性能。可以选择使用 <code>Object.create()</code> 来创建一个新对象，为其指定原型。</p>
</li>
<li><h5 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h5><p>在通过对象访问属性时，会按照这个属性的名称开始搜索，首先开始于对象实例本身。如果没有找到，则沿着指针进入原型对象搜索。</p>
<p>通过实例无法重写原型的值。在实例上添加了同名的属性，会在实例自身上创建这个属性，掩盖住原型对象上对应的属性。</p>
<p>当实例上遮蔽了原型对象上的同名属性时，除非使用 <code>delete</code> 删除这个实例上的属性，否则无法再访问到原型对象上的同名属性。</p>
<p>可以使用 <code>hasOwnProperty</code> 来确定某个属性存在于实例还是原型对象。这个方法继承于 <code>Object</code> 。该方法只对实例属性有效，要取得原型属性的描述符，就必须直接在原型对象上调用 <code>Object.getOwnPropertyDescriptor()</code> 。</p>
</li>
<li><h5 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 <code>in</code> 操作符</h5><p><code>in</code> 操作符可以单独使用或是在 <code>for-in</code> 循环中使用。</p>
<p>单独使用时， <code>in</code> 操作符会在可以通过对象访问指定属性时返回 <code>true</code> ，无论该属性是在实例上还是在原型上。</p>
<p>在 <code>for-in</code> 循环中使用 <code>in</code> 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。</p>
<p>可以使用 <code>Object.keys()</code> 方法来获得对象上所有可枚举的实例属性。接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p>
<p>可以使用 <code>Object.getOwnPropertyNames()</code> 来获得所有实例属性，无论是否可以枚举。</p>
<p><code>ES6</code> 新增了一个 <code>Object.getOwnPropertySymbols()</code> 方法来获取符号为键的属性。</p>
</li>
<li><h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序是不确定的。</p>
<p><code>Object.getOwnpropertyNames()</code> 、 <code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，再以插入顺序枚举字符串和符号键。</p>
</li>
</ol>
<h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>ES8</code> 新增了两个静态方法，用于将对象内容转换为序列化的、可迭代的格式。分别是 <code>Object.values()</code> 和 <code>Object.entries()</code> ，都接收一个对象，返回相应内容的数组。</p>
<p><code>Object.values()</code> 返回对象值的数组， <code>Object.entries()</code> 返回键值对的数组。</p>
<p>非字符串属性会被转换为字符串输出。两个方法都执行对象的浅复制。符号属性会被忽略。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 18</title>
    <url>/2020/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-18/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-18"><a href="#学习笔记-2020-10-18" class="headerlink" title="学习笔记 2020-10-18"></a>学习笔记 2020-10-18</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><p><code>ES6</code> 新增了很多极其有用的语法糖特性。</p>
<ol>
<li><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Sirine'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Sirine"&#125;</span></span><br></pre></td></tr></table></figure>

<p>简写属性名只要使用变量名就会自动解释为同名的属性键，如果没有找到同名变量，则会抛出 <code>ReferenceError</code> 。</p>
</li>
<li><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>以前，想使用变量的值作为属性，必须先声明对象，使用中括号语法来添加属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[nameKey] = <span class="string">'Sirine'</span>;</span><br><span class="line">person[ageKey] = <span class="number">27</span>;</span><br><span class="line">person[jobKey] = <span class="string">'student'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Sirine", age: 27, job: "student"&#125;</span></span><br></pre></td></tr></table></figure>

<p>可计算属性的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [nameKey]: <span class="string">'Sirine'</span>,</span><br><span class="line">  [ageKey]: <span class="number">27</span>,</span><br><span class="line">  [jobKey]: <span class="string">'student'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "Sirine", age: 27, job: "student"&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以在对象字面量中完成动态属性赋值。也可以使用复杂的表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [getUniqueKey(nameKey)]: <span class="string">'Sirine'</span>,</span><br><span class="line">  [getUniqueKey(ageKey)]: <span class="number">27</span>,</span><br><span class="line">  [getUniqueKey(jobKey)]: <span class="string">'Student'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name_0: 'Sirine', age_1: 27, job_2: 'Student' &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><p>旧的方法定义方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">'Sirine'</span>); <span class="comment">// My name is Sirine</span></span><br></pre></td></tr></table></figure>

<p>新的方法定义方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  sayName(name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">'Sirine'</span>); <span class="comment">// My name is Sirine</span></span><br><span class="line"><span class="comment">// 对获取函数和设置函数同样适用。</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name_: <span class="string">''</span>,</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name_ = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name_&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">'Sirine'</span>;</span><br><span class="line">person.sayName(); <span class="comment">// My name is Sirine</span></span><br></pre></td></tr></table></figure>

<p>同时，简写方法名与可计算属性键相互兼容</p>
</li>
</ol>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName = person.name,</span><br><span class="line">  personAge = person.age;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Sirine</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge); <span class="comment">// 27</span></span><br><span class="line"><span class="comment">// 使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Sirine</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p>也可以使用简写语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Sirine</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p>若引用的属性不存在，该变量的值就是 <code>undefined</code> 。</p>
<p>也可以自定义默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job = <span class="string">'Student'</span> &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Sirine</span></span><br><span class="line"><span class="built_in">console</span>.log(job); <span class="comment">// Student</span></span><br></pre></td></tr></table></figure>

<p>解构在内部使用函数 <code>ToObject()</code> 把源数据结构转换为对象。这意味着，原始值会被当成对象。 <code>null</code>  和 <code>undefined</code> 不能解构。否则会抛出 <code>TypeError</code> 。</p>
<p>如果是给事先声明的变量赋值，则赋值表达式需要包含在一对括号中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person);</span><br><span class="line"><span class="built_in">console</span>.log(personName, personAge); <span class="comment">// Sirine, 27</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">'Student'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line">(&#123; <span class="attr">name</span>: personCopy.name, <span class="attr">age</span>: personCopy.age, <span class="attr">job</span>: personCopy.job &#125; = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.age = <span class="number">21</span>;</span><br><span class="line">person.job.title = <span class="string">'Hacker'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">// &#123; name: 'Sirine', age: 21, job: &#123; title: 'Hacker' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy);</span><br><span class="line"><span class="comment">// &#123; name: 'Sirine', age: 27, job: &#123; title: 'Hacker' &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">'Student'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  job: &#123; title &#125;</span><br><span class="line">&#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(title); <span class="comment">// Student</span></span><br></pre></td></tr></table></figure>

<p>外层属性没有定义的情况下不能使用嵌套解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">'Student'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"><span class="comment">// foo 在源对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  foo: &#123; <span class="attr">bar</span>: personCopy.bar &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'.</span></span><br><span class="line"><span class="comment">// job 在目标对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  job: &#123; <span class="attr">title</span>: personCopy.job.title &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot set property 'title' of undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="部分解构"><a href="#部分解构" class="headerlink" title="部分解构"></a>部分解构</h5><p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果开始赋值成功而后面赋值出错，解构赋值只能完成一部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// person.foo 是 undefined，因此会抛出错误</span></span><br><span class="line">  (&#123;</span><br><span class="line">    name: personName,</span><br><span class="line">    foo: &#123; <span class="attr">bar</span>: personBar &#125;,</span><br><span class="line">    age: personAge</span><br><span class="line">  &#125; = person);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge);</span><br><span class="line"><span class="comment">// Sirine, undefined, undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="参数上下文匹配"><a href="#参数上下文匹配" class="headerlink" title="参数上下文匹配"></a>参数上下文匹配</h5><p>在函数参数列表中可以进行解构赋值，不会影响 <code>arguments</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo, &#123; name, age &#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo, &#123; name: personName, age: personAge &#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(personName, personAge);</span><br><span class="line">&#125;</span><br><span class="line">printPerson(<span class="string">'1st'</span>, person, <span class="string">'2nd'</span>);</span><br><span class="line"><span class="comment">// ['1st', &#123; name: 'Sirine', age: 27 &#125;, '2nd']</span></span><br><span class="line"><span class="comment">// 'Sirine', 27</span></span><br><span class="line">printPerson2(<span class="string">'1st'</span>, person, <span class="string">'2nd'</span>);</span><br><span class="line"><span class="comment">// ['1st', &#123; name: 'Sirine', age: 27 &#125;, '2nd']</span></span><br><span class="line"><span class="comment">// 'Sirine', 27</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">'Sirine'</span>, <span class="number">29</span>, <span class="string">'Student'</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">'Severus'</span>, <span class="number">27</span>, <span class="string">'Teacher'</span>);</span><br></pre></td></tr></table></figure>

<p>此处，可以通过多次调用不同参数的 <code>createPerson</code> 来创建不同的对象。但没有解决对象标识问题，即新创建的对象是什么类型。在这个例子中，创建的对象全部为 <code>object</code> 类型。</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>在 <code>js</code> 中，我们可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Sirine'</span>, <span class="number">29</span>, <span class="string">'Student'</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Severus'</span>, <span class="number">27</span>, <span class="string">'Teacher'</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// Sirine</span></span><br><span class="line">person2.sayName(); <span class="comment">// Severus</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>构造函数和工厂函数的区别是：</p>
<ul>
<li>没有显式地创建对象。</li>
<li>属性和方法直接赋值给了 <code>this</code> 。</li>
<li>没有 <code>return</code>  。</li>
<li>函数名首字母大写。借鉴于面向对象编程语言。</li>
</ul>
<p>创建实例使用 <code>new</code> 操作符。会执行以下操作：</p>
<ol>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的 <code>[[Prototype]]</code> 特性被赋值为构造函数的 <code>prototype</code> 属性。</li>
<li>构造函数内部的 <code>this</code> 被赋值为这个新对象。</li>
<li>执行构造函数内部的代码。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
<p>定义自定义构造函数可以确保实例被标识为特定类型。</p>
<p>构造函数也可以是被赋值给变量的函数表达式。</p>
<p>在实例化时，构造函数后的括号不加也可以。只要有 <code>new</code> 操作符，就可以调用相应的构造函数。</p>
<ol>
<li><h5 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h5><p>任何函数只要使用 <code>new</code> 操作符调用就是构造函数，不使用 <code>new</code> 操作符调用就是普通函数。</p>
</li>
<li><h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>构造函数的问题是定义的方法会在每个实例上创建一遍。每个实例都会有自己的方法，而这些方法实际上是一样的，却指向不同的引用，这是没有必要的。如果我们选择把方法抽离到全局，让每个实例的方法都指向这个全局方法，可以保证不会重复声明函数，但这样污染了全局作用域，当构造函数的方法较多时，全局上就会多出很多不必要的函数，这些函数明明只是属于我们的实例对象，却定义在了全局。</p>
</li>
</ol>
<h2 id="CSS-知识点"><a href="#CSS-知识点" class="headerlink" title="CSS 知识点"></a>CSS 知识点</h2><p>又回顾到了浮动与清除浮动的知识，对于 <code>clearfix</code> 这种清除方法不是特别理解。自己写了写来尝试加深理解。</p>
<p>首先查阅了 <code>MDN</code> 关于 <code>clear</code> 的文档： 👉<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p><strong><code>clear</code></strong> <a href="https://developer.mozilla.org/en-US/docs/CSS" target="_blank" rel="noopener">CSS</a> 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。<code>clear</code> 属性适用于浮动和非浮动元素。</p>
</blockquote>
<p>文档中指出， <code>clear</code> 属性同时适用于浮动与非浮动元素。</p>
<blockquote>
<p>当应用于非浮动块时，它将非浮动块的<a href="https://developer.mozilla.org/en-US/docs/CSS/box_model" target="_blank" rel="noopener">边框边界</a>移动到所有相关浮动元素<a href="https://developer.mozilla.org/en-US/docs/CSS/box_model" target="_blank" rel="noopener">外边界</a>的下方。这个非浮动块的<a href="https://developer.mozilla.org/en-US/docs/CSS/margin_collapsing" target="_blank" rel="noopener">垂直外边距</a>会折叠。</p>
</blockquote>
<p>这个特性给了解决浮动导致父元素高度塌陷的方法。</p>
<p>当父元素内的所有子元素都浮动，导致父元素内部高度无法被自动撑开。</p>
<p>此时，我们可以给父元素内部最后添加一个元素(经验证，此元素需要为块级元素)，然后设置 <code>clear: both</code> ，表示当左右有浮动元素时需要移动到下面。该伪元素会自动移动到左右浮动元素最长的那个底下。</p>
<p>于是，父元素内部有了一个块级元素，且有位置要求，父元素就被撑开了。</p>
<p>为了简便，可以直接将该元素定义为父元素的伪元素 <code>:after</code> 。</p>
<p>且文档中提到一点，移动元素的垂直外边距会被折叠。</p>
<p>简单验证了一下，该元素的顶部外边距会被折叠，但底部外边距不会。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>to clearfix<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>another right container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-18/image-20201018112427598.png" alt="image-20201018112427598"></p>
<p>另外，测试了一下浮动元素应用 <code>clear</code> 属性的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>to clearfix<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>another left container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-18/image-20201018111957887.png" alt="image-20201018111957887"></p>
<p>可以看出来，浮动元素清除浮动后会影响到后续的元素，后续的元素只会跟着它进行排列。不会高于它。</p>
<p>将 <code>.bottom</code> 的 <code>clear</code> 修改为 <code>left</code> 。</p>
<p><img src="/2020/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-18/image-20201018112058725.png" alt="image-20201018112058725"></p>
<p>将底部的最后那个元素修改为右浮动。</p>
<p><img src="/2020/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-18/image-20201018112132997.png" alt="image-20201018112132997"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>手写 Promise</title>
    <url>/2020/10/17/%E6%89%8B%E5%86%99-Promise/</url>
    <content><![CDATA[<p>尝试使用 <code>js</code> 手写 <code>Promise</code> 类，实现部分功能，遵守 <code>Promises/A+</code> 规范，例如 <code>then, catch, all, race, resolve, reject</code> 等。</p>
<h2 id="使用原生-Promise-查看效果"><a href="#使用原生-Promise-查看效果" class="headerlink" title="使用原生 Promise 查看效果"></a>使用原生 <code>Promise</code> 查看效果</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出 <code>promise</code> 的几个性质，首先它是一个类，可以被实例化，参数为一个函数，有 <code>resolve</code> 和 <code>reject</code> 两个参数。当期望的事情完成后，调用 <code>resolve</code> 表明成功，调用 <code>reject</code> 表明失败。成功后可以调用 <code>.then</code> 来进行后续操作，默认参数为 <code>resolve</code> 函数的参数。返回值可以是一个新的 <code>promise</code> ，后续操作会等待这个 <code>promise</code> 的完成。抛出错误时或是手动调用 <code>reject</code> 都会进入 <code>catch</code> 回调，或是 <code>.then</code> 方法的第二个参数。</p>
<p>接下来，我们一步步实现。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li><h3 id="定义-promise-构造函数"><a href="#定义-promise-构造函数" class="headerlink" title="定义 promise 构造函数"></a>定义 <code>promise</code> 构造函数</h3><p>首先定义三个常量用于表示状态，<code>Promises/A+</code> 规范中提到：</p>
<blockquote>
<p>A promise must be in one of three states: pending, fulfilled, or rejected.</p>
<ol>
<li><p>When pending, a promise:</p>
<ol>
<li>may transition to either the fulfilled or rejected state.</li>
</ol>
</li>
<li><p>When fulfilled, a promise:</p>
<ol>
<li>must not transition to any other state.</li>
<li>must have a value, which must not change.</li>
</ol>
</li>
<li><p>When rejected, a promise:</p>
<ol>
<li>must not transition to any other state.</li>
<li>must have a reason, which must not change.</li>
</ol>
</li>
</ol>
<p>Here, “must not change” means immutable identity (i.e. <code>===</code>), but does not imply deep immutability.</p>
</blockquote>
<p><code>promise</code> 仅有三种状态，表示还未完成，已成功或是已失败。当处于 <code>pending</code> 状态时，可能会转换为另外两种状态。当处于 <code>fulfilled</code> 状态时，不会再转为其余状态，必须拥有一个 <code>value</code> 属性且不再变化。当处于 <code>rejected</code> 状态时，同样不会再转变，且必须拥有一个 <code>reason</code> 属性不再变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>,</span><br><span class="line">  FULFILLED = <span class="string">'fulfilled'</span>,</span><br><span class="line">  REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在构造函数中，我们定义三个变量，初始化此时的状态为 <code>pending</code> ，并且传入的 <code>executor</code> 函数我们需要进行调用，传入定义的两个函数作为参数。</p>
<p>然后定义 <code>resolve</code> 和 <code>reject</code> 的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.status === FULFILLED;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.status === REJECTED;</span><br><span class="line">  <span class="keyword">this</span>.reason = reason;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>遵循规范，若当前状态不是 <code>pending</code> ，不执行后续操作。</p>
</li>
<li><h3 id="定义-then-方法"><a href="#定义-then-方法" class="headerlink" title="定义 then 方法"></a>定义 <code>then</code> 方法</h3><p>首先查看规范：</p>
<blockquote>
<p>A promise’s <code>then</code> method accepts two arguments:</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="keyword">on</span>Fulfilled, <span class="keyword">on</span>Rejected)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Both <code>onFulfilled</code>  and <code>onRejected</code>  are optional arguments:</p>
<ol>
<li>If <code>onFulfilled</code> is not a function, it must be ignored.</li>
<li>If <code>onRejected</code> is not a function, it must be ignored.</li>
</ol>
</li>
<li><p>If <code>onFulfilled</code> is a function:</p>
<ol>
<li>it must be called after <code>promise</code> is fulfilled, with <code>promise</code>’s value as its first argument.</li>
<li>it must not be called before <code>promise</code> is fulfilled.</li>
<li>it must not be called more than once.</li>
</ol>
</li>
<li><p>If <code>onRejected</code> is a function,</p>
<ol>
<li>it must be called after <code>promise</code> is rejected, with <code>promise</code>’s reason as its first argument.</li>
<li>it must not be called before <code>promise</code> is rejected.</li>
<li>it must not be called more than once.</li>
</ol>
</li>
<li><p><code>onFulfilled</code> or <code>onRejected</code> must not be called until the <a href="https://es5.github.io/#x10.3" target="_blank" rel="noopener">execution context</a> stack contains only platform code. [<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.1</a>].</p>
</li>
<li><p><code>onFulfilled</code> and <code>onRejected</code> must be called as functions (i.e. with no <code>this</code> value). [<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.2</a>]</p>
</li>
<li><p><code>then</code>may be called multiple times on the same promise.</p>
<ol>
<li>If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.</li>
<li>If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.</li>
</ol>
</li>
<li><p><code>then</code> must return a promise [<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.3</a>].</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">promise2</span> = promise1.then(<span class="literal">on</span>Fulfilled, <span class="literal">on</span>Rejected)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>.</li>
<li>If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</li>
<li>If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.</li>
<li>If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</li>
</ol>
</li>
</ol>
</blockquote>
<p>规范提到，<code>then</code> 方法的两个参数是可选的，但必须是函数，不是函数的话将被忽略。</p>
<p> <code>onFulfilled</code> 将在 <code>promise</code> 状态为 <code>fulfilled</code> 之后调用，<code>promise</code> 的 <code>value</code> 作为它的参数，在 <code>promise</code> 转为 <code>fulfilled</code> 之前不允许调用，且只能被调用一次。 <code>onRejected</code> 类似。</p>
<p>两个函数都只能在执行上下文调用栈仅包含 <code>platform code</code> 时调用，需要确保两个函数都是异步调用的。</p>
<p>两个函数都必须以函数形式调用，不允许包含 <code>this</code> 。</p>
<p>同一个 <code>promise</code> 可以多次调用 <code>then</code> 方法(此处不是指链式调用)，需要确保多次调用是按照顺序执行的。</p>
<p><code>then</code> 方法的返回值也是一个 <code>promise</code> 。</p>
<p><code>onFulfilled</code> 或是 <code>onRejected</code> 的返回值需要执行 <code>Promise Resolution Procedure</code> 。</p>
<p>两个函数若是抛出了错误，<code>promise2</code> 需要以该错误为参数被拒绝。</p>
<p>若没有传入两个函数，<code>promise</code> 值需要同样往后续传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先简单实现同步回调，判断当前的 <code>status</code> 来执行相应的回调。</p>
<p>接下来考虑异步执行，若是 <code>executor</code> 内部是一个异步执行，异步执行中才会调用 <code>resolve</code> 或是 <code>reject</code> ，那么我们在调用 <code>then</code> 时， <code>status</code> 还没有得到转换，此时无法正确执行，且需要在异步地更改 <code>status</code> 后再执行回调。</p>
<p>修改代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallList = [];</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallList = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallList.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallList.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的异步 <code>resolve</code> 已经可以正确执行。</p>
<p>再来考虑错误捕获的问题，我们的 <code>executor</code> 中可能会抛出错误，此时需要直接执行 <code>reject</code> 来拒绝。</p>
<p>修改代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行 <code>executor</code> 时就尝试捕获错误，若是捕获到了就直接 <code>reject</code> ，此时需要定义 <code>then</code> 的第二个参数来处理。</p>
<p>此时若是对 <code>promise</code> 实例多次调用 <code>then</code> 方法也可以正确且按序执行。</p>
<p>接下来处理两个参数为空的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来处理 <code>then</code> 的返回值问题，即实现链式调用。</p>
<p>参考原生 <code>promise</code> 的表现形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'10'</span>, res); <span class="comment">// 10 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'11'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'16'</span>, res); <span class="comment">// 16 11</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'18'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'24'</span>, res); <span class="comment">// 24 18</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>可以看出，每个 <code>then</code> 方法的参数都是前一次 <code>then</code> 的返回值，返回值若是 <code>promise</code> ，则是 <code>resolve</code> 的值。</p>
<p>于是我们需要处理两种状况，<code>return</code> 了原始值或是 <code>promise</code>  。</p>
<p>于是我们对 <code>onFulfilled</code> 和 <code>onRejected</code> 返回值进行一个处理。</p>
<p>在那之前，我们先注意若是 <code>onFulfilled</code> 和 <code>onRejected</code> 函数内部执行时抛出了错误，我们需要进行 <code>reject</code> 。所以代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseResolve</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise2, x, resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            promiseResolve(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            promiseResolve(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            promiseResolve(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            promiseResolve(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处做了较多修改，在 <code>then</code> 方法中定义了一个新的 <code>promise</code> 实例，然后进行状态判定，若是已完成，则进行相应操作。若是未完成，则把回调进行订阅，在完成时进行发布。调用回调时需要得到返回值，然后进行返回值的处理。于是定义了一个 <code>resolvePromise</code> 方法来处理，我们会在这个函数内部进行 <code>resolve</code> 或是 <code>reject</code> ，所以需要传入对应函数。同时传入 <code>promise</code> 本身和 <code>x</code> 这个返回值来自于规范内的规定。</p>
<p>但是，在调用 <code>promiseResolve</code> 时，我们的 <code>promise2</code> 还没有执行完毕，所以我们需要使用异步方法 <code>setTimeout</code> 来延迟这个函数的执行，确保可以正确得到 <code>promise2</code> 。同时，我们也要对回调函数的执行进行错误捕获，若是捕获到错误就 <code>reject</code> 。</p>
<p>为什么订阅回调时不需要异步来调用处理函数呢？因为订阅的回调发布时已经是异步状态。</p>
<p>然后开始处理 <code>promiseResolve</code> 函数。</p>
<p>首先看规范：</p>
<blockquote>
<p>The <strong>promise resolution procedure</strong> is an abstract operation taking as input a promise and a value, which we denote as  <code>[[Resolve]](promise, x)</code>. If  <code>x</code>  is a thenable, it attempts to make <code>promise</code> adopt the state of <code>x</code>, under the assumption that <code>x</code> behaves at least somewhat like a promise. Otherwise, it fulfills <code>promise</code> with the value <code>x</code>.</p>
<p>This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant <code>then</code> method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable <code>then</code> methods.</p>
<p>To run <code>[[Resolve]](promise, x)</code>, perform the following steps:</p>
<ol>
<li><p>If <code>promise</code> and <code>x</code> refer to the same object, reject <code>promise</code> with a <code>TypeError</code> as the reason.</p>
</li>
<li><p>If <code>x</code> is a promise, adopt its state :</p>
<ol>
<li>If <code>x</code> is pending, <code>promise</code> must remain pending until <code>x</code> is fulfilled or rejected.</li>
<li>If/when <code>x</code> is fulfilled, fulfill <code>promise</code> with the same value.</li>
<li>If/when <code>x</code> is rejected, reject <code>promise</code> with the same reason.</li>
</ol>
</li>
<li><p>Otherwise, if <code>x</code> is an object or function,</p>
<ol>
<li><p>Let <code>then</code> be <code>x.then</code>. [<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.5</a>]</p>
</li>
<li><p>If retrieving the property <code>x.then</code> results in a thrown exception <code>e</code>, reject <code>promise</code> with <code>e</code> as the reason.</p>
</li>
<li><p>If <code>then</code> is a function, call it with <code>x</code> as <code>this</code>, first argument <code>resolvePromise</code> , and second argument <code>rejectPromise</code> , where:</p>
<ol>
<li><p>If/when <code>resolvePromise</code> is called with a value <code>y</code>, run <code>[[Resolve]](promise, y)</code>.</p>
</li>
<li><p>If/when <code>rejectPromise</code> is called with a reason <code>r</code>, reject <code>promise</code> with <code>r</code>.</p>
</li>
<li><p>If both <code>resolvePromise</code> and <code>rejectPromise</code> are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</p>
</li>
<li><p>If calling <code>then</code> throws an exception <code>e</code> , </p>
<ol>
<li><p>If <code>resolvePromise</code> or <code>rejectPromise</code> have been called, ignore it.</p>
</li>
<li><p>Otherwise, reject <code>promise</code> with <code>e</code> as the reason.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>If <code>then</code> is not a function, fulfill <code>promise</code> with <code>x</code>.</p>
</li>
</ol>
</li>
<li><p>If <code>x</code> is not an object or function, fulfill <code>promise</code> with <code>x</code>.</p>
</li>
</ol>
<p>If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of <code>[[Resolve]](promise, thenable)</code> eventually causes <code>[[Resolve]](promise, thenable)</code> to be called again, following the above algorithm will lead to infinite recursion. Implementations are encouraged, but not required, to detect such recursion and reject <code>promise</code> with an informative <code>TypeError</code> as the reason. [<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">3.6</a>]</p>
</blockquote>
<p>简单翻译一下：</p>
<blockquote>
<p> 此处使用 <code>promise2</code> 指代第一个参数。</p>
</blockquote>
<ol>
<li><p>如果 <code>promise2</code> 和 <code>x</code> 引用的是同一个对象，直接以类型错误 <code>reject</code> 。</p>
</li>
<li><p>如果 <code>x</code> 是一个 <code>promise</code> ：</p>
<ol>
<li>如果 <code>x</code> 的状态是 <code>pending</code> ，那么 <code>promise2</code> 需要保持直到 <code>x</code> 转为 <code>fulfilled</code> 或者是 <code>rejected</code> 。</li>
<li>如果 <code>x</code> 的状态是 <code>fulfilled</code> ，使用 <code>x</code> 的 <code>value</code> 去转换 <code>promise2</code> 为 <code>fulfilled</code> 。</li>
<li><code>reject</code> 同上。</li>
</ol>
</li>
<li><p>如果 <code>x</code> 是一个对象或函数：</p>
<ol>
<li>将 <code>x.then</code> 赋值给 <code>then</code> 。</li>
<li>若是 <code>x.then</code> 的结果抛出了错误，使用这个错误来 <code>reject</code> <code>promise2</code> 。</li>
<li>如果 <code>then</code> 是一个函数就调用它，第一个参数为 <code>resolvePromise</code> ，第二个参数为 <code>rejectPromise</code> 。<ul>
<li><code>resolvePromise</code> 接收一个参数 <code>y</code> ，它的类型也可能是 <code>promise</code> ，所以调用 <code>promiseResolve</code> 来处理它。</li>
<li><code>rejectPromise</code> 接收一个参数 <code>r</code> ，使用它来 <code>reject</code> <code>promise2</code> 。</li>
<li>如果两个回调参数都被调用，或是多次使用相同参数重复调用，只有第一次调用生效，其余的会被忽略。</li>
<li>如果调用 <code>x.then</code> 抛出错误：<ul>
<li>如果回调参数已经被调用了，忽略。</li>
<li>其余情况，使用错误来 <code>reject</code> <code>promise2</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>then</code> 不是一个函数，使用 <code>x</code> 来 <code>fulfilled</code>  <code>promise2</code> 。</li>
</ol>
</li>
<li><p>如果 <code>x</code> 是其他类型，使用 <code>x</code> 来 <code>fulfilled</code> <code>promise2</code> 。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseResolve</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            promiseResolve(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          r =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处已经可以正确处理链式调用，返回新的 <code>promise</code> 实例的情况。且嵌套返回也没有问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = promise1.then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">promise2</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'19'</span>, res); <span class="comment">// 19 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(</span><br><span class="line">          <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'23'</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'34'</span>, res); <span class="comment">// 34 19</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'36'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'40'</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'45'</span>, res); <span class="comment">// 45 34</span></span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'48'</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>接下来实现 <code>catch</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，<code>catch</code> 的逻辑其实与 <code>then</code> 类似，只是没有传入 <code>onFulfilled</code> 回调而已。</p>
<p>接下来实现 <code>Promise.resolve</code> <code>Promise.reject</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">static</span> resolve(onResolved) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (onResolved <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        onResolved.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(onResolved);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(onRejected);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个函数都返回一个 <code>promise</code> 即可。 <code>resolve</code> 内部需要进行判断，如果传入的值为一个 <code>promise</code> ，那么我们就进行处理。</p>
<p>接下来实现 <code>Promise.all</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">let</span> resolvedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            values.push(res);</span><br><span class="line">            resolvedCount++;</span><br><span class="line">            <span class="keyword">if</span> (resolvedCount === len) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>all</code> 方法等待传入的参数全部执行完成，返回所有返回值的数组。</p>
<p>我们遍历参数列表，对每一个参数进行 <code>resolve</code> 。将结果加入 <code>value</code> 数组中，并计数。当返回值数量等于参数数量时，可以 <code>resolve</code> 返回值。</p>
<p>最后实现 <code>race</code> 方法，这个方法只需要 <code>resolve</code> 最先得到结果的值即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写完以后看了一下时间，完成时间是 <code>15:58</code> 。花了两个半小时，中间也有一些地方写乱了，然后又去查资料。感觉对 <code>promise</code> 理解加深了一些，但又好像还是很混乱。</p>
<p>总的来说， <code>promise</code> 改善了回调地狱的问题，我们可以在回调中将结果抛出，然后在后续链式调用获取结果。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 17</title>
    <url>/2020/10/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-17/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-17"><a href="#学习笔记-2020-10-17" class="headerlink" title="学习笔记 2020-10-17"></a>学习笔记 2020-10-17</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><p><code>ECMA-262</code> 将对象定义为一组属性的无序集合，使用一些内部特性来描述属性的特征，这些特性由两个中括号括起来。</p>
<ol>
<li><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul>
<li><p><code>[[Configurable]]</code></p>
<p>表示属性是否可以通过 <code>delete</code> 删除并重新定义，是否可以修改它的特性，是否可以把它改为访问器属性。默认值为 <code>true</code> 。</p>
</li>
<li><p><code>[[Enumerable]]</code></p>
<p>表示属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>true</code> 。</p>
</li>
<li><p><code>[[Writeble]]</code></p>
<p>表示属性的值是否可以被修改。默认值为 <code>true</code> 。</p>
</li>
<li><p><code>[[Value]]</code></p>
<p>包含属性实际的值。默认值为 <code>undefined</code> 。</p>
</li>
</ul>
<p>修改属性的默认特征，使用 <code>Object.defineProperty</code> 方法。这个方法接收三个参数，要添加属性的对象、属性的名称和一个描述符对象。描述符对象的属性可以包括上述四个属性名：<code>configurable</code> 、 <code>enumerable</code> 、· <code>writable</code> 和 <code>value</code> 。调用时，如果不指定属性值，则都默认为 <code>false</code> 。</p>
</li>
<li><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性包含一个 <code>getter</code> 和一个 <code>setter</code> 函数。有 4 个特性描述它们的行为。</p>
<ul>
<li><p><code>[[Configurable]]</code></p>
<p>表示属性是否可以通过 <code>delete</code> 删除并重新定义，是否可以修改它的特性，是否可以把它改为数据属性。默认值为 <code>true</code> 。</p>
</li>
<li><p><code>[[Enumerable]]</code></p>
<p>表示属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>true</code> 。</p>
</li>
<li><p><code>[[Get]]</code></p>
<p>获取函数，读取属性时调用，默认值为 <code>undefined</code> 。</p>
</li>
<li><p><code>[[Set]]</code></p>
<p>设置函数，写入属性时调用，默认值为 <code>undefined</code> 。</p>
</li>
</ul>
</li>
</ol>
<p>可以同时定义多个属性，只需要使用 <code>Object.defineProperties</code> 方法，接收两个参数，添加或修改属性的对象和另一个描述符对象。</p>
<h4 id="读取属性的特征"><a href="#读取属性的特征" class="headerlink" title="读取属性的特征"></a>读取属性的特征</h4><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符。接收两个参数，属性所在的对象和要取得其描述符的属性名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.year_ = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">'year_'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">'year'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>

<p><code>ES8</code> 新增了 <code>Object.getOwnpropertyDescriptors()</code> 静态方法。会在每个自有属性上调用 <code>Object.getOwnpeopertyDescriptor()</code> 并在一个新对象中返回它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.year_ = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// edition: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 1,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// get: f(),</span></span><br><span class="line"><span class="comment">// set: f(newValue),</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year_: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 2017,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h4><p><code>ES6</code> 专门为合并对象提供了 <code>Object.assign()</code> 方法。接收一个目标对象和一个或多个源对象作为参数，将每个源对象中可枚举( <code>Object.propertyIsEnumerable()</code> 返回 <code>true</code> ) 和自有 ( <code>Object.hasOwnProperty()</code> 返回 <code>true</code> ) 属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，会使用源对象上的 <code>[[Get]]</code> 取得属性的值，然后使用目标对象上的 <code>[[Set]]</code> 设置属性的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">'src'</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line">dest.id = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123;id: "123"&#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">a</span>: <span class="string">'foo'</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">'bar'</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> a(val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> a() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invoked src getter'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数"foo"</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>复制过程执行的是浅复制。多个源对象若存在相同的属性，最后一个会覆盖前面的值。</p>
<h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><p><code>ES6</code> 新增了 <code>Object.is()</code> ，接收两个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'2'</span>, <span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的 0、-0、+0 相等/不等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的 NaN 相等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 要检查超过两个值，递归地利用相等性传递即可：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.is(x, rest[<span class="number">0</span>]) &amp;&amp; (rest.length &lt; <span class="number">2</span> || recursivelyCheckEqual(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><h4 id="不好的风格"><a href="#不好的风格" class="headerlink" title="不好的风格"></a>不好的风格</h4><p>下面的代码风格有什么问题？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x,n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;result*=x;&#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x=prompt(<span class="string">"x?"</span>,<span class="string">''</span>), n=prompt(<span class="string">"n?"</span>,<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  alert(<span class="string">`Power <span class="subst">$&#123;n&#125;</span> is not supported, please enter an integer number greater than zero`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  alert(pow(x,n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result *= x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = prompt(<span class="string">"x?"</span>,<span class="string">''</span>),</span><br><span class="line">    n=prompt(<span class="string">"n?"</span>,<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  alert(<span class="string">`Power <span class="subst">$&#123;n&#125;</span> is not supported, please enter an integer number greater than zero`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(pow(x,n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h2><ol>
<li><p><code>vertical-align</code> 用于行内块元素和内联元素对齐。</p>
</li>
<li><p><code>table</code> 单元格默认垂直居中。</p>
</li>
<li><p>垂直居中的一种思路</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本这里是多行文本</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行内块元素排列时有 <code>4px</code> 的空格解决方案</p>
<ul>
<li>父级容器 <code>font-size: 0</code> ，子级容器中若存在文本，需要重设字体大小，不规范。</li>
<li>行内块元素设置 <code>margin-left: -4px</code> 或是其余数值，但文件压缩后会出现问题。因为空格来源于标签的换行或是空格符，压缩后这些东西不存在，左移的样式就会多余。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 16</title>
    <url>/2020/10/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-16/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-16"><a href="#学习笔记-2020-10-16" class="headerlink" title="学习笔记 2020-10-16"></a>学习笔记 2020-10-16</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p><code>yield</code> 关键字可以让生成器停止和开始执行。</p>
<p>生成器函数在遇到 <code>yield</code> 关键字之前会正常执行。遇到之后，执行会停止，保留函数作用域的状态。</p>
<p>在生成器对象上调用 <code>next()</code> 方法来恢复执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: false, value: 'foo' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: false, value: 'bar' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: 'baz' &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>yield</code> 关键字退出的生成器函数会处于 <code>done: false</code> 状态，通过 <code>return</code> 关键字退出的生成器函数会处于 <code>done: true</code> 状态。</p>
<p>生成器函数内部会针对每个生成器对象区分作用域。</p>
<p><code>yield</code> 关键字只能直接位于生成器函数内部，不能出现在嵌套的非生成器函数中。</p>
<ol>
<li><h5 id="生成器函数作为可迭代对象"><a href="#生成器函数作为可迭代对象" class="headerlink" title="生成器函数作为可迭代对象"></a>生成器函数作为可迭代对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="使用-yield-实现输入和输出"><a href="#使用-yield-实现输入和输出" class="headerlink" title="使用 yield 实现输入和输出"></a>使用 yield 实现输入和输出</h5><p><code>yield</code> 可以作为函数的中间参数使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(initial);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(<span class="string">'foo'</span>);</span><br><span class="line">generatorObject.next(<span class="string">'bar'</span>); <span class="comment">// foo</span></span><br><span class="line">generatorObject.next(<span class="string">'baz'</span>); <span class="comment">// baz</span></span><br><span class="line">generatorObject.next(<span class="string">'qux'</span>); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>

<p>上一次让生成器函数暂停的 <code>yield</code> 关键字会接收到传给 <code>next</code> 方法的第一个值。</p>
<p>但第一次调用传入的值不会被使用，这一次是为了开始执行生成器函数。</p>
</li>
<li><h5 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h5><p>可以使用星号增强 <code>yield</code> 的行为，让它迭代一个可迭代对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>yield*</code> 的值是关联迭代器返回 <code>done: true</code> 时的 <code>value</code> 属性。</p>
</li>
<li><h5 id="使用-yield-实现递归算法"><a href="#使用-yield-实现递归算法" class="headerlink" title="使用 yield* 实现递归算法"></a>使用 yield* 实现递归算法</h5><p><code>yield*</code> 最有用的地方是实现递归操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>每个生成器首先会从新创建的生成器对象产出每个值，再产出一个整数。</p>
<p>下面是一个图的例子，用于生成随机的双向图。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.neighbors = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  connect(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.neighbors.add(node);</span><br><span class="line">      node.neighbors.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomGraph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">this</span>.nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机连接节点</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">1</span> / size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="keyword">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> y <span class="keyword">of</span> <span class="keyword">this</span>.nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; threshold) &#123;</span><br><span class="line">          x.connect(y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个方法仅用于调试</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="keyword">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">const</span> ids = [...node.neighbors].map(<span class="function"><span class="params">n</span> =&gt;</span> n.id).join(<span class="string">','</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;node.id&#125;</span>: <span class="subst">$&#123;ids&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  isConnected() &#123;</span><br><span class="line">    <span class="keyword">const</span> visitedNodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">traverse</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visitedNodes.has(node)) &#123;</span><br><span class="line">          <span class="keyword">yield</span> node;</span><br><span class="line">          <span class="keyword">yield</span>* traverse(node.neighbors);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得集合中的第一个节点</span></span><br><span class="line">    <span class="keyword">const</span> firstNode = <span class="keyword">this</span>.nodes[<span class="built_in">Symbol</span>.iterator]().next().value;</span><br><span class="line">    <span class="comment">// 使用递归生成器迭代每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> traverse([firstNode])) &#123;</span><br><span class="line">      visitedNodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitedNodes.size === <span class="keyword">this</span>.nodes.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> RandomGraph(<span class="number">6</span>);</span><br><span class="line">g.print();</span><br><span class="line"><span class="comment">// 示例输出：</span></span><br><span class="line"><span class="comment">// 0: 2,3,5</span></span><br><span class="line"><span class="comment">// 1: 2,3,4,5</span></span><br><span class="line"><span class="comment">// 2: 1,3</span></span><br><span class="line"><span class="comment">// 3: 0,1,2,4</span></span><br><span class="line"><span class="comment">// 4: 2,3</span></span><br><span class="line"><span class="comment">// 5: 0,4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="keyword">this</span>.values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h4><p>一个实现 <code>Iterator</code> 接口的对象一定有 <code>next()</code> 方法，还有一个可选的 <code>return()</code> 方法用于提前终止迭代器。生成器对象还有第三个方法，<code>throw()</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next); <span class="comment">// f next() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return); <span class="comment">// f return() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.throw); <span class="comment">// f throw() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>return</code> 和 <code>throw</code> 都强制生成器进入关闭状态。</p>
<p><code>throw</code> 方法会在暂停的时候将一个提供的错误注入到生成器对象。如果错误未被处理，生成器就会被关闭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw(<span class="string">'foo'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果生成器函数内部处理了错误，生成器就不会被关闭，可以恢复执行。错误处理会跳过对应的 <code>yield</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 1&#125;</span></span><br><span class="line">g.throw(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 3&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 15</title>
    <url>/2020/10/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-15/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-15"><a href="#学习笔记-2020-10-15" class="headerlink" title="学习笔记 2020-10-15"></a>学习笔记 2020-10-15</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>一些结构可以称为 <code>可迭代对象</code> ，因为它们实现了正式的 <code>Iterable</code> 接口。</p>
<p>可迭代对象包含有限的元素，且具有无歧义的遍历顺序。</p>
<p>任何实现了 <code>Iterable</code> 接口的数据结构都可以被实现 <code>Iterator</code> 接口的结构消费。</p>
<p>迭代器是按需创建的一次性对象，关联一个可迭代对象，迭代器会暴露迭代其关联的可迭代对象的 <code>API</code> ，无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。</p>
<ol>
<li><h5 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h5><p>实现 <code>Iterable</code> 接口要求同时具备两种能力：支持迭代的自我识别能力和创建实现 <code>Iterator</code> 接口的对象的能力。在 <code>ECMAScript</code> 中，必须暴露一个属性作为 <code>默认迭代器</code> ，必须使用 <code>Symbol.iterator</code> 作为键，必须引用一个迭代器工厂函数，必须返回一个新迭代器。</p>
<p>实现了 <code>Iterable</code> 接口的内置类型：</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li><code>arguments</code> 对象</li>
<li><code>NodeList</code> 等 <code>DOM</code> 集合类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>[Symbol.iterator]); // f values() &#123; [native code] &#125;</span><br><span class="line"><span class="built_in">console</span>.log(els[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// MapIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>[Symbol.iterator]()); // SetIterator &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(els[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们不需要显式调用这个工厂函数来生成迭代器，实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。例如：</p>
<ul>
<li><code>for-of</code> 循环</li>
<li>数组解构</li>
<li>拓展操作符</li>
<li><code>Array.from()</code></li>
<li>创建集合</li>
<li>创建映射</li>
<li><code>Promise.all()</code> </li>
<li><code>Promise.race()</code></li>
<li><code>yield*</code></li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的工厂函数来创建一个迭代器。</p>
<p>如果对象原型链上的父类实现了 <code>Iterable</code> 接口，那么这个对象也就实现了这个接口。</p>
</li>
<li><h5 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h5><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。</p>
<p>使用 <code>next()</code> 方法在可迭代对象中遍历数据。每次成功调用 <code>next()</code> ，都会返回一个 <code>IteratorResult</code> 对象，包含迭代器返回的 下一个值。</p>
<p><code>IteratorResult</code> 包含两个属性， <code>done</code> 和 <code>value</code> 。</p>
<p><code>done</code> 表示是否还可以再次调用 <code>next()</code> 。</p>
<p><code>value</code> 表示包含可迭代对象的下一个值。</p>
<p><code>done</code> 为 <code>false</code> 时可以取得 <code>value</code> ，<code>done</code> 为 <code>true</code> 时 <code>value</code> 返回 <code>undefined</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'foo'</span>, <span class="string">'bar'</span>];</span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: 'foo' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: 'bar' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>迭代器到达 <code>done: true</code> 状态后，再次调用 <code>next()</code> 会一直返回相同的值，即 <code>undefined</code> 。</p>
<p>如果可迭代对象在迭代期间被修改，迭代器也会反映相同的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'foo'</span>, <span class="string">'baz'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: 'foo' &#125;</span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: 'bar' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: 'baz' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>迭代器维护着一个指向可迭代对象的引用，会阻止垃圾回收程序回收可迭代对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用默认的迭代器工厂函数会返回</span></span><br><span class="line"><span class="comment">// 一个实现迭代器接口（Iterator）的迭代器对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> h = f[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="comment">// 打印出实现了迭代器接口的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(h); <span class="comment">// &#123; next: f() &#123;&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next()); <span class="comment">// &#123;done: false, value: "foo"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next()); <span class="comment">// &#123;done: false, value: "foo"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next()); <span class="comment">// &#123;done: false, value: "foo"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h.next()); <span class="comment">// &#123;done: false, value: "foo"&#125;</span></span><br><span class="line"><span class="comment">// Array 类型实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用 Array 类型的默认迭代器工厂函数</span></span><br><span class="line"><span class="comment">// 会创建一个 ArrayIterator 的实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 打印出 ArrayIterator 的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h5><p>任何实现 <code>Iterator</code> 接口的对象都可以作为迭代器使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Counter 的实例应该迭代 limit 次</span></span><br><span class="line">  <span class="keyword">constructor</span>(limit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt;= <span class="keyword">this</span>.limit) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.count++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// (nothing logged)</span></span><br></pre></td></tr></table></figure>

<p>以上例子创建了一个自定义迭代次数的迭代器，但它的每个实例只能被迭代一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(limit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="keyword">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.iterator</code> 属性引用的工厂函数返回相同的迭代器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">let</span> iter2 = iter1[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1 === iter2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h5><p>可以使用一个可选的 <code>return</code> 方法来指定迭代器提前关闭时的执行逻辑。</p>
<p>以下情况可以触发 <code>return</code> ：</p>
<ul>
<li><code>for-of</code> 循环通过 <code>break</code> 、 <code>continue</code> 、 <code>return</code> 、 <code>throw</code> </li>
<li>解构操作并未消费所有值</li>
</ul>
<p><code>return</code> 方法必须返回一个有效的 <code>IteratorResult</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(limit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="keyword">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">return</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Exiting early'</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'err'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3;</span><br><span class="line"><span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure>

<p>数组的迭代器不能关闭，可以继续从上次离开的地方继续迭代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>手动给不可关闭的迭代器添加 <code>return</code> 方法可行，在迭代器提前终止时会调用这个方法，但并不能让这个迭代器进入关闭状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter.return = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Exiting early'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是 <code>ES6</code> 新增的结构，拥有在一个函数块内暂停和恢复代码执行的能力。</p>
<ol>
<li><h5 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h5><p>生成器的形式是一个函数，在函数名称前加一个星号表示它是一个生成器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  *generatorFn() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *generatorFn() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> *generatorFn() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价的生成器函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFnA</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorFnB</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFnC</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等价的生成器方法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *generatorFnD() &#123;&#125;</span><br><span class="line">  * generatorFnE() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数不能用于定义生成器函数。</p>
<p>调用生成器函数会产生一个生成器对象，一开始处于暂停执行的状态。</p>
<p>生成器对象也实现了 <code>Iterator</code> 接口，具有 <code>next()</code> 方法。</p>
<p><code>next</code> 方法返回值类似于迭代器，有一个 <code>done</code> 属性和一个 <code>value</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: 'foo' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>生成器函数只会在初次调用 <code>next</code> 方法后开始执行。</p>
</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li><h5 id="请写函数实现，利用对象中的数据渲染模板，并返回最终结果。"><a href="#请写函数实现，利用对象中的数据渲染模板，并返回最终结果。" class="headerlink" title="请写函数实现，利用对象中的数据渲染模板，并返回最终结果。"></a>请写函数实现，利用对象中的数据渲染模板，并返回最终结果。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template =</span><br><span class="line">  <span class="string">'我们的公司是&#123;&#123;company&#125;&#125;,我们属于&#123;&#123;group.name&#125;&#125;,我们主要业务包括&#123;&#123;group.job[0]&#125;&#125;、&#123;&#123;group["job"][1]&#125;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  company: <span class="string">'xxxx股份有限公司'</span>,</span><br><span class="line">  group: &#123;</span><br><span class="line">    name: <span class="string">'xx研发部'</span>,</span><br><span class="line">    job: [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tmpReplace</span>(<span class="params">tmp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp.replace(<span class="regexp">/&#123;&#123;(.*?)&#125;&#125;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = [];</span><br><span class="line">    <span class="keyword">let</span> res = obj[key] || obj;</span><br><span class="line">    keys = key.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">      keys.forEach(<span class="function">(<span class="params">i, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        keys.splice(idx, <span class="number">1</span>, ...i.split(<span class="regexp">/[\[|\]]/</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> keys = key.split(<span class="regexp">/[\[|\]]/</span>);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      i = i.replace(<span class="regexp">/\"/g</span>, <span class="string">''</span>);</span><br><span class="line">      <span class="keyword">let</span> j = res[i];</span><br><span class="line">      <span class="keyword">if</span> (j) res = j;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpReplace(template));</span><br><span class="line"><span class="comment">// 我们的公司是xxxx股份有限公司,我们属于xx研发部,我们主要业务包括aaa、bbb</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="请写出上述代码浏览器执行后，控制台的打印顺序。"><a href="#请写出上述代码浏览器执行后，控制台的打印顺序。" class="headerlink" title="请写出上述代码浏览器执行后，控制台的打印顺序。"></a>请写出上述代码浏览器执行后，控制台的打印顺序。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>此题需要理解宏任务微任务的概念，第一行和第十五行的打印都是同步任务，所以直接打引。第三行的定时器是宏任务，执行到此处会将回调函数放入宏任务队列，<code>Promise</code> 是微任务，第八行的 <code>.then</code> 的回调属于异步，先放入微任务队列，然后继续执行同步代码，所以第十五行先于 <code>promise</code> 打印。执行完同步任务，开始确认微任务队列，先打印 <code>promise1</code> ，然后执行第二个 <code>.then</code> ，再次增加一个微任务，继续执行微任务，最后再去确认宏任务队列，打印定时器的输出。</p>
</li>
<li><h5 id="用-css-实现如下三栏布局，要求两边各-150px-，中间自适应。写两种方法。"><a href="#用-css-实现如下三栏布局，要求两边各-150px-，中间自适应。写两种方法。" class="headerlink" title="用 css 实现如下三栏布局，要求两边各 150px ，中间自适应。写两种方法。"></a>用 <code>css</code> 实现如下三栏布局，要求两边各 <code>150px</code> ，中间自适应。写两种方法。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 使用 flex 布局</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgoldenrodyellow;</span><br><span class="line">&#125;</span><br><span class="line">// 使用绝对定位</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgoldenrodyellow;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 table 布局</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgoldenrodyellow;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 grid 布局</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">150px</span> auto <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgoldenrodyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-15/image-20201015111101303.png" alt="image-20201015111101303"></p>
</li>
<li><h5 id="请用-promise-实现函数，要求每5秒获取一个随机数，如果小于-5-，立即结束函数，如果大于-5-，则-60-秒后函数运行结束。"><a href="#请用-promise-实现函数，要求每5秒获取一个随机数，如果小于-5-，立即结束函数，如果大于-5-，则-60-秒后函数运行结束。" class="headerlink" title="请用 promise 实现函数，要求每5秒获取一个随机数，如果小于 5 ，立即结束函数，如果大于 5 ，则 60 秒后函数运行结束。"></a>请用 promise 实现函数，要求每5秒获取一个随机数，如果小于 5 ，立即结束函数，如果大于 5 ，则 60 秒后函数运行结束。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    _fx();</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fx</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> r = <span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (r &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'函数立即结束'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve();</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'函数 60s 后结束'</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myRandom();</span><br></pre></td></tr></table></figure>

<p>其实这道题没太看懂题目要求，不太懂这个逻辑，好像这个函数的随机数只会获取一次，一次后这个数必定会有个结束，要么是立即要么是延时。又或者是只是单纯延迟这一次的随即调用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 14</title>
    <url>/2020/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-14/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-14"><a href="#学习笔记-2020-10-14" class="headerlink" title="学习笔记 2020-10-14"></a>学习笔记 2020-10-14</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol>
<li><h5 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><p><code>Set</code> 会维护值插入时的顺序，支持按顺序迭代。可以通过 <code>values()</code> <code>keys()</code> 方法或是 <code>Symbol.iterator</code> 取得这个迭代器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.keys === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1 val2 val3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1 val2 val3</span></span><br></pre></td></tr></table></figure>

<p><code>values</code> 是默认迭代器，可以通过拓展操作将集合转换为数组。</p>
<p><code>entries</code> 方法返回一个迭代器，按照插入顺序产生包含两个元素的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["val1", "val1"]</span></span><br><span class="line"><span class="comment">// ["val2", "val2"]</span></span><br><span class="line"><span class="comment">// ["val3", "val3"]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Set</span>.prototype);</span><br><span class="line"><span class="comment">// add: ƒ add()</span></span><br><span class="line"><span class="comment">// clear: ƒ clear()</span></span><br><span class="line"><span class="comment">// constructor: ƒ Set()</span></span><br><span class="line"><span class="comment">// delete: ƒ delete()</span></span><br><span class="line"><span class="comment">// entries: ƒ entries()</span></span><br><span class="line"><span class="comment">// forEach: ƒ forEach()</span></span><br><span class="line"><span class="comment">// has: ƒ has()</span></span><br><span class="line"><span class="comment">// keys: ƒ values()</span></span><br><span class="line"><span class="comment">// size: (...)</span></span><br><span class="line"><span class="comment">// values: ƒ values()</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.iterator): ƒ values()</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.toStringTag): "Set"</span></span><br><span class="line"><span class="comment">// get size: ƒ size()</span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br></pre></td></tr></table></figure>

<p><code>Set</code> 的 <code>forEach</code> 方法与数组的类似，传入回调参数以及可选的 <code>this</code> 值。</p>
</li>
<li><h5 id="定义正式集合操作"><a href="#定义正式集合操作" class="headerlink" title="定义正式集合操作"></a>定义正式集合操作</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSet</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  union(...sets) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.union(<span class="keyword">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  intersection(...sets) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.intersection(<span class="keyword">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  difference(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.difference(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  symmetricDifference(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.symmetricDifference(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cartesianProduct(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.cartesianProduct(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  powerSet() &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.powerSet(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> union(a, ...bSets) &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.add(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> intersection(a, ...bSets) &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.has(aValue)) &#123;</span><br><span class="line">          intersectionSet.delete(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> difference(a, b) &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.has(bValue)) &#123;</span><br><span class="line">        differenceSet.delete(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> symmetricDifference(a, b) &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.union(b).difference(a.intersection(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> cartesianProduct(a, b) &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.add([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> powerSet(a) &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">set</span> of new XSet(powerSet)) &#123;</span><br><span class="line">        powerSet.add(<span class="keyword">new</span> XSet(<span class="keyword">set</span>).add(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p><code>ES6</code> 新增的弱集合类型，其 <code>API</code> 是 <code>Set</code> 的子集。</p>
<p>弱集合的值只能是 <code>Object</code> 或是继承自 <code>Object</code> 的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  val2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  val3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, val2, val3]);</span><br><span class="line"><span class="built_in">console</span>.log(ws1.has(val1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ws1.has(val2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ws1.has(val3)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">'BADVAL'</span>, val3]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet</span></span><br><span class="line"><span class="keyword">typeof</span> ws2;</span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined</span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作值</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'val1'</span>);</span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([stringVal]);</span><br><span class="line"><span class="built_in">console</span>.log(ws3.has(stringVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可用的方法：</p>
<ul>
<li><code>add()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ul>
<p><code>WeakSet</code> 同样可以链式调用，其值不属于正式引用，不会影响垃圾回收，没有迭代能力。可以用于标记 <code>DOM</code> 元素是否处于某种状态。</p>
<h4 id="迭代与拓展操作"><a href="#迭代与拓展操作" class="headerlink" title="迭代与拓展操作"></a>迭代与拓展操作</h4><p><code>ES6</code> 中新增了迭代器与拓展操作符。</p>
<p><code>Array</code> 、定型数组、<code>Map</code> 、<code>Set</code> 定义了默认迭代器，可以传入 <code>for-of</code> 循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [</span><br><span class="line">  <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">  (typedArr = <span class="built_in">Int16Array</span>.of(<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">  ]),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// [5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8]</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>同样的，这些类型都兼容拓展操作符。</p>
<p>拓展操作符可用于可迭代对象执行浅复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: 'bar' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="built_in">Int16Array</span>.of(...arr1);</span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="built_in">Int16Array</span>.from(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(typedArr1); <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(typedArr2); <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x, <span class="string">'val'</span> + x]));</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;1 =&gt; 'val 1', 2 =&gt; 'val 2', 3 =&gt; 'val 3'&#125;</span></span><br><span class="line"><span class="comment">// 把数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(typedArr2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><p>循环是迭代机制的基础，可以指定迭代次数以及每次迭代的操作。</p>
<p>迭代会在一个有序集合上进行。此处有序理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。</p>
<p>循环迭代不是理想的机制，我们需要事先知道如何使用数据结构，通过递增索引来访问数据是数组独有的方式，并不通用。</p>
<p><code>ES5</code> 新增了 <code>Array.prototype.forEach</code> 方法，解决了单独记录索引来取值的问题，但没有办法标识迭代何时终止。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><h4 id="用箭头函数重写"><a href="#用箭头函数重写" class="headerlink" title="用箭头函数重写"></a>用箭头函数重写</h4><p>用箭头函数重写下面的函数表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question, yes, no</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (confirm(question)) yes()</span><br><span class="line">  <span class="keyword">else</span> no();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ask(</span><br><span class="line">  &amp;quot;Do you agree?&amp;quot;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(&amp;quot;You agreed.&amp;quot;); &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(&amp;quot;You canceled the execution.&amp;quot;); &#125;</span><br><span class="line">);<span class="string">`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ask = <span class="function">(<span class="params">question, yes, no</span>) =&gt;</span> confirm(question) ? yes() : no();</span><br><span class="line"></span><br><span class="line">ask(</span><br><span class="line">  &amp;quot;Do you agree?&amp;quot;,</span><br><span class="line">  () =&gt; alert(<span class="string">"You agreed."</span>),</span><br><span class="line">  () =&gt; alert(<span class="string">"You canceled the execution."</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 13</title>
    <url>/2020/10/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-13/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-13"><a href="#学习笔记-2020-10-13" class="headerlink" title="学习笔记 2020-10-13"></a>学习笔记 2020-10-13</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>set</code> 方法返回映射实例，因此可以链式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"key1"</span>, <span class="string">"val1"</span>);</span><br><span class="line">m.set(<span class="string">"key2"</span>, <span class="string">"val2"</span>)</span><br><span class="line"> .set(<span class="string">"key3"</span>, <span class="string">"val3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>Map</code> 可以使用任何数据类型作为键，使用严格相等来匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">"functionValue"</span>);</span><br><span class="line">m.set(symbolKey, <span class="string">"symbolValue"</span>);</span><br><span class="line">m.set(objectKey, <span class="string">"objectValue"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(functionKey)); <span class="comment">// functionValue</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>Map</code> 保持插入顺序不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>

<p><code>Map</code> 的 <code>keys()</code> <code>values()</code> 方法分别返回插入顺序生成的键和值的迭代器。</p>
<h4 id="选择-Object-还是-Map"><a href="#选择-Object-还是-Map" class="headerlink" title="选择 Object 还是 Map"></a>选择 Object 还是 Map</h4><p>在内存占用方面，两种类型都会随键的数量线性增加。但给定固定大小的内存， <code>Map</code> 可以多存储 <code>50%</code> 的键值对。</p>
<p>在插入性能方面，消耗相当。但插入 <code>Map</code> 会稍快。</p>
<p>在查找速度方面，性能差异极小，涉及大量查找时，<code>Object</code> 会更好。</p>
<p>在删除性能方面，<code>Map</code> 表现更好。</p>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>ES6</code> 新增的集合类型，弱映射。其 <code>Api</code> 是 <code>Map</code> 的子集。</p>
<p>弱映射的键只能是 <code>Object</code> 或是继承自 <code>Object</code> 的类型。值的类型没有限制。</p>
<p>可以将原始值包装成对象用作键。</p>
<p><code>WeakMap</code> 的键不属于正式引用，不会阻止垃圾回收。当键没有其余指向它的引用时，在代码执行完成后，就会被垃圾回收，键值对就会从弱映射中消失。</p>
<p><code>WeakMap</code> 没有迭代方法，没有一次性销毁所有键值的方法。</p>
<p>弱映射的用处：</p>
<ul>
<li><p>私有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">'id'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setId(id);</span><br><span class="line">  &#125;</span><br><span class="line">  setPrivate(property, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> privateMembers = wm.get(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">    privateMembers[property] = value;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, privateMembers);</span><br><span class="line">  &#125;</span><br><span class="line">  getPrivate(property) &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="keyword">this</span>)[property];</span><br><span class="line">  &#125;</span><br><span class="line">  setId(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPrivate(<span class="keyword">this</span>.idProperty, id);</span><br><span class="line">  &#125;</span><br><span class="line">  getId() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getPrivate(<span class="keyword">this</span>.idProperty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getId()); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(wm.get(user)[user.idProperty]); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>为了防止外部获取到弱映射而破坏了私有性。我们可以使用闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">      <span class="keyword">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">'id'</span>);</span><br><span class="line">      <span class="keyword">this</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    setPrivate(property, value) &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMembers = wm.get(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMembers[property] = value;</span><br><span class="line">      wm.set(<span class="keyword">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line">    getPrivate(property) &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.get(<span class="keyword">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line">    setId(id) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setPrivate(<span class="keyword">this</span>.idProperty, id);</span><br><span class="line">    &#125;</span><br><span class="line">    getId(id) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getPrivate(<span class="keyword">this</span>.idProperty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getId()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DOM</code> 节点元数据</p>
<p>如果使用常规的 <code>Map</code> 来保存 <code>DOM</code> 节点，当 <code>DOM</code> 节点在 <code>DOM</code> 树中被销毁，我们依然保存着它的引用，<code>DOM</code> 节点依然保存在内存中。若是采用弱映射，就不会发生这种状况。</p>
</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>ES6</code> 新增的集合类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"val1"</span>, <span class="string">"val2"</span>, <span class="string">"val3"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"val1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"val2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"val3"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(s2.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>基本 <code>API</code> :</p>
<ul>
<li><p><code>add()</code></p>
</li>
<li><p><code>has()</code></p>
</li>
<li><p><code>size</code></p>
</li>
<li><p><code>delete()</code></p>
<p>返回集合中是否存在要删除的值。</p>
</li>
<li><p><code>clear()</code></p>
</li>
</ul>
<p><code>add</code> 方法同样返回集合实例，可以链式调用。使用严格相等来进行匹配。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="函数表达式与函数声明的区别"><a href="#函数表达式与函数声明的区别" class="headerlink" title="函数表达式与函数声明的区别"></a>函数表达式与函数声明的区别</h3><ol>
<li>函数声明是一段代码块，函数表达式是一个赋值语句。</li>
<li>函数表达式仅在代码执行到达时才会创建该函数，且从此刻开始可用。函数声明会在脚本开始运行时被创建，在声明语句之前也可以调用该函数。</li>
</ol>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO-LIST"></a>TODO-LIST</h2><ul>
<li><input disabled type="checkbox"> 想尝试一下 <code>hugo</code> 作为博客。</li>
<li><input checked disabled type="checkbox"> 整理 18 年的笔记。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码 数据劫持</title>
    <url>/2020/10/12/Vue%E6%BA%90%E7%A0%81-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<p>双向数据绑定是 <code>Vue</code> 的一大亮点和重点，这里讲解一下原理并且重写一遍。版本为 <code>2.x</code> 。</p>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>Vue 2.x</code> 中的双向数据绑定原理来源于一个对象方法， <code>Object.defineProperty</code> ， 通过这个方法我们可以定义对象属性的 <code>getter</code> 和 <code>setter</code> ，于是我们可以在数据被重新设置(即调用 <code>setter</code> 时)进行视图更新等操作。</p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>使用 <code>Vue</code> 时我们会引入 <code>vue</code> 的默认导出，这个默认导出是一个构造函数，我们利用这个构造函数创建一个 <code>vue</code> 实例，并传入我们的配置参数，例如管理的 <code>dom</code> 元素以及 <code>data</code> 等参数，虽然在一般开发中我们不会在根实例上挂载数据，但此处仅做一个简单还原。</p>
<p>传入参数后，我们在构造函数内调用初始化函数，初始化操作一般为挂载配置项，初始化各种数据，例如 <code>data</code> , <code>computed</code> <code>props</code> 等。</p>
<p>我们首先需要对<code>data</code> 做一层代理，因为在配置项中传入的 <code>data</code> 一般为函数，以防止组件复用时因为引用相同而数据混乱。并且在 <code>vue</code> 实例中无法直接访问到数据，我们把 <code>data</code> 挂载到实例上，并使用 <code>Object.defineProperty</code> 使得我们可以使用 <code>this</code> 直接访问到各项 <code>data</code> 。</p>
<p>做完代理，我们需要对数据进行响应式处理，即观察数据项的修改。首先是 <code>data</code> 本身，我们抽出一个 <code>observe</code> 函数来进行观察操作，首先判断传入的观察对象的类型，如果不是引用类型其实没有观察的必要，因为普通类型的修改已经在父级做了观察，我们需要深层观察的是子对象、子数组、子对象子数组内部的引用类型等。</p>
<p>如果是引用类型，我们初始化一个观察者来进行观察。在观察者内部，我们迭代传入的引用类型，对每个 <code>key</code> 和 <code>value</code> 做一个响应式处理，当访问当前对象的 <code>key</code> 属性时，我们返回 <code>value</code> 。此处可以做一些操作，例如收集依赖。当设置当前对象的时候，我们去修改 <code>value</code> 的值。需要注意的是，此处不能够直接去获取或者修改 <code>obj[key]</code> ( <code>obj</code> 指代做响应式处理的对象或数组)，因为我们正是对 <code>obj[key]</code> 做了观察，当我们观察到需要获取 <code>key</code> 属性时，<code>getter</code> 内部又是获取 <code>key</code> 属性，会造成死循环。<code>setter</code> 同理。</p>
<p>数组无法直接做响应式处理，我们选择遍历数组，对每个元素单独观察。但此处又有一个问题，因为 <code>Object.defineProperty</code> 无法响应数组的变化，当我们修改了数组，例如增加了新的元素，新增的元素没有被观察，数组的修改也没有被观察到。那么我们就需要重新定义数组的修改方法，就是 <code>push</code> <code>pop</code> <code>sort</code> <code>splice</code> <code>shift</code> <code>unshift</code> <code>reverse</code> ，我们使用数组原型创建一个新的数组对象，重写这个数组对象上的七个方法，在方法内部还是依然执行原本的函数内容，但此处我们就可以增加一些自己的操作，例如视图刷新等。定义完这个数组对象后，我们将它赋值给需要被响应式处理的数组的原型，那么就单独影响了我们响应式的数组，而不对其余的普通数组产生影响。</p>
<p>在这个过程中还有一些小点，就是每次对对象的值或是数组的元素观察时，我们需要注意这个元素是否也是一个引用类型，如果是的话，我们需要再对这个元素进行观察。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先配置一个 <code>webpack</code> 环境，下载 <code>webpack</code> <code>webpack-cli</code> <code>webpack-dev-server</code> 以及 <code>html-webpack-plugin</code> 。在项目根目录配置 <code>webpack.config.js</code> 。我们需要配置项目的入口，出口，插件，以及模块引入的规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 定义入口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>, <span class="comment">// 定义出口的文件名</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>) <span class="comment">// 定义出口路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'public/index.html'</span>) <span class="comment">// 定义文件模板位置</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 配置模块引入的规则，首先从 src 目录寻找，再去 node_modules 中寻找。</span></span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'src'</span>), path.resolve(__dirname, <span class="string">'node_modules'</span>)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看入口文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="comment">// 实例化 Vue</span></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">"Sirine' working time"</span>,</span><br><span class="line">      time: <span class="string">'2020-10-11'</span>,</span><br><span class="line">      info: &#123;</span><br><span class="line">        name: <span class="string">'zhao'</span>,</span><br><span class="line">        age: <span class="number">21</span>,</span><br><span class="line">        isGood: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      say: [</span><br><span class="line">        <span class="number">123</span>,</span><br><span class="line">        <span class="string">'456'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          a: <span class="number">123</span>,</span><br><span class="line">          b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">          c: &#123;</span><br><span class="line">            today: <span class="string">'is'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此处只是简单创建了实例。</p>
<p>然后看 <code>vue</code> 文件夹。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/index.js</span></span><br><span class="line"><span class="keyword">import</span> initState <span class="keyword">from</span> <span class="string">'./init'</span>; <span class="comment">// 引入初始化数据的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// vue 的构造函数，初始化实例。</span></span><br><span class="line">  <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在原型上挂载初始化函数，将传入的参数挂载到实例上。</span></span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  vm.$options = options;</span><br><span class="line">  initState(vm); <span class="comment">// 调用初始化数据的函数。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure>

<p>接下来看 <code>initState</code> 这个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/init.js</span></span><br><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">'./observe'</span>;</span><br><span class="line"><span class="keyword">import</span> proxyData <span class="keyword">from</span> <span class="string">'./proxy'</span>;</span><br><span class="line"><span class="comment">// 引入观察函数和代理数据函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = vm.$options;</span><br><span class="line">  <span class="comment">// 首先取出 options</span></span><br><span class="line">  <span class="keyword">if</span> (options.data) &#123;</span><br><span class="line">    <span class="comment">// 判断参数中是否有 data ，有才执行初始化。</span></span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _data = vm.$options.data; <span class="comment">// 取出数据</span></span><br><span class="line">  _data = vm._data = <span class="keyword">typeof</span> _data === <span class="string">'function'</span> ? _data.call(vm) : _data || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将数据挂载到实例上，并且判断是否是函数，是的话调用它，否的话保持原样，并确保至少是一个对象。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> _data) &#123;</span><br><span class="line">    <span class="comment">// 遍历 data 做一层代理。</span></span><br><span class="line">    proxyData(vm, <span class="string">'_data'</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 观察这个 data</span></span><br><span class="line">  observe(_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initState;</span><br></pre></td></tr></table></figure>

<p>首先看 <code>proxyData</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/proxy.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyData</span>(<span class="params">data, target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传入的参数分别是做代理的对象，挂载的属性名，和当前的属性名</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="comment">// 当我们获取 data[key] 时，实际上是从 data[target][key] 中获取。</span></span><br><span class="line">      <span class="keyword">return</span> data[target][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">      <span class="comment">// 当我们设置 data[key] 时，实际上设置在了 data[target][key]。</span></span><br><span class="line">      data[target][key] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> proxyData;</span><br></pre></td></tr></table></figure>

<p>此处做一个解释，我们在 <code>initData</code> 中将 <code>options</code> 中的 <code>data</code> 挂载到了 <code>vm._data</code> 上，而我们想要直接调用 <code>vm.xxx</code> 来获取，但是 <code>vm</code> 上并没有这个属性，它实际上是在 <code>vm._data.xxx</code> 上，所以我们做一层代理，当访问 <code>vm.xxx</code> 时，我们返回 <code>vm._data.xxx</code> ，当设置 <code>vm.xxx = yyy</code> 时，实际上是执行了 <code>vm._data.xxx = yyy</code> 。</p>
<p>然后再看 <code>observe</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/observe.js</span></span><br><span class="line"><span class="keyword">import</span> Observer <span class="keyword">from</span> <span class="string">'./observer'</span>; <span class="comment">// 引入实际的观察者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'object'</span> || data === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 首先判断数据类型，如果不是引用类型，不需要再深入观察了。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data); <span class="comment">// 否则，返回一个观察者实例。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observe;</span><br></pre></td></tr></table></figure>

<p>当我们想要深入观察时，都会调用 <code>observe</code> 函数，所以我们需要判断类型，原始类型已经在父级中被观察了，不需要继续深入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/observer.js</span></span><br><span class="line"><span class="keyword">import</span> defineReactiveData <span class="keyword">from</span> <span class="string">'./reactive'</span>;</span><br><span class="line"><span class="keyword">import</span> observeArr <span class="keyword">from</span> <span class="string">'./observeArr'</span>;</span><br><span class="line"><span class="keyword">import</span> arrMethods <span class="keyword">from</span> <span class="string">'./array'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    <span class="comment">// 判断数据是否为数组，是数组的话，给它赋予变异数组方法，再观察这个数组。</span></span><br><span class="line">    data.__proto__ = arrMethods;</span><br><span class="line">    observeArr(data); <span class="comment">// 观察数组的方法。</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是对象的话。</span></span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data); <span class="comment">// 遍历对象的键值</span></span><br><span class="line">    keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> value = data[key]; <span class="comment">// 获取每个值</span></span><br><span class="line">      defineReactiveData(data, key, value);</span><br><span class="line">      <span class="comment">// 将对象，键名，键值传入响应式函数进行响应式绑定。</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer;</span><br></pre></td></tr></table></figure>

<p>此处引入的函数较多，一个个看。</p>
<p>先看对象部分，逻辑已经非常清晰，对这个对象的每个键值进行 <code>getter</code> <code>setter</code> 重写，我们需要先取出每个值形成闭包用来访问，否则会出现死循环问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/reactive.js</span></span><br><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">'./observe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactiveData</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">  observe(value); <span class="comment">// 继续观察这个传入的值，可能需要深入观察。</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'响应式 get'</span>, value);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'响应式 set'</span>, value, newVal);</span><br><span class="line">      <span class="keyword">if</span> (value === newVal) <span class="keyword">return</span>;</span><br><span class="line">      value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineReactiveData;</span><br></pre></td></tr></table></figure>

<p>依然是熟悉的自定义 <code>setter</code> 和 <code>getter</code> ，函数内部可以写入许多其余逻辑来进行其他操作。</p>
<p>此处调用 <code>observe(value)</code> 是因为，<code>data[key]</code> 的值可能是数组和对象，它们的值是一个引用地址，不是覆盖的情况下无法监听到变化， 我们需要再次观察它，使用 <code>observe</code> 来判断，如果是引用类型会深入观察，不是的话就直接返回。</p>
<p>谈完了对象，再来看数组。</p>
<p><code>Object.defineProperty</code> 无法监听到数组的变化，所以我们需要遍历数组，进行单独的监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/observeArr.js</span></span><br><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">'./observe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observeArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    observe(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observeArr;</span><br></pre></td></tr></table></figure>

<p>而数组对于自身变化的方法我们需要进行重写，否则数组的修改没有办法监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/vue/array.js</span></span><br><span class="line"><span class="keyword">import</span> ARRAY_METHODS <span class="keyword">from</span> <span class="string">'./config'</span>;</span><br><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">'./observe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayPrototype = <span class="built_in">Array</span>.prototype; <span class="comment">// 取出数组的原型对象</span></span><br><span class="line"><span class="keyword">var</span> arrMethods = <span class="built_in">Object</span>.create(arrayPrototype); <span class="comment">// 根据这个原型对象创建一个数组</span></span><br><span class="line"></span><br><span class="line">ARRAY_METHODS.forEach(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 遍历七个数组方法，对我们创建的这个数组上写入我们自定义的方法。</span></span><br><span class="line">  arrMethods[m] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = arrayPrototype.slice.call(<span class="built_in">arguments</span>); <span class="comment">// 转换传入的参数为数组。</span></span><br><span class="line">    <span class="keyword">var</span> result = arrayPrototype[m].apply(<span class="keyword">this</span>, args); <span class="comment">// 调用原本的方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动态修改数组'</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newItem; <span class="comment">// 此处用于监听新增的数据。</span></span><br><span class="line">    <span class="keyword">switch</span> (m) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        newItem = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是 push unshift 方法，只需要监听我们传入的参数即可。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        newItem = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 如果是 splice 方法，我们监听可能存在的第三个参数以及更多。</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newItem &amp;&amp; observe(newItem); <span class="comment">// 如果存在新的数据，我们进行监听。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 将原本数组的返回指返回。</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> arrMethods;</span><br></pre></td></tr></table></figure>

<p>到此差不多完成了简单的数据劫持，当我们动态修改这些数据的时候，会被监听到并且进行一些需要的操作。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 12</title>
    <url>/2020/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-12/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-12"><a href="#学习笔记-2020-10-12" class="headerlink" title="学习笔记 2020-10-12"></a>学习笔记 2020-10-12</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ol>
<li><h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><ul>
<li><p><code>reduce</code></p>
</li>
<li><p><code>reduceRight</code></p>
<p>两个方法都会迭代数组的所有项，构建一个最终返回值。区别是 <code>reduce</code> 从头遍历到尾， <code>reduceRight</code> 从尾遍历到头。</p>
<p>两个方法都接收两个参数，一个归并函数和归并起点的初始值。归并函数接收四个参数，上一个归并值，当前项，当前项的索引和数组本身。函数的返回值会作为下一次遍历的归并值即第一个参数。如果没有传入第二个参数，那么第一次迭代默认从数组第二项开始。</p>
</li>
</ul>
</li>
</ol>
<h4 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h4><p>人们期望开发一套 <code>JavaScript API</code> 来利用 <code>3D</code> 图形 <code>API</code> 和 <code>GPU</code> 加速，以便渲染运行复杂的 <code>3D</code> 应用程序。基于 <code>OpenGL ES 2.0</code> 规范开发了一个 <code>API</code> 名为 <code>WebGL</code> 。早期版本中，它与原生数组之间格式不匹配，出现了性能问题。在此基础上， <code>Mozilla</code> 实现了 <code>CanvasFloatArray</code> ，最终变成 <code>Float32Array</code> 。</p>
<ol>
<li><h5 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a><code>ArrayBuffer</code></h5><p><code>ArrayBuffer</code> 是所有定型数组及视图引用的基本单位，是一个普通的 <code>JavaScript</code> 构造函数，可用于在内存中分配特定数量的字节空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf.byteLength); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayBuffeer</code> 创建后无法改变大小，但可以利用 <code>slice</code> 方法复制部分成为一个新的实例。</p>
<p>查看 <code>ArrayBuffer</code> 的原型对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">ArrayBuffer</span>.prototype);</span><br><span class="line">&#123;</span><br><span class="line">  byteLength: (...)</span><br><span class="line">  <span class="keyword">constructor</span>: ƒ ArrayBuffer()</span><br><span class="line">  slice: ƒ slice()</span><br><span class="line">  Symbol(Symbol.toStringTag): "ArrayBuffer"</span><br><span class="line">  <span class="keyword">get</span> byteLength: ƒ byteLength()</span><br><span class="line">  __proto__: Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>ArrayBuffer</code> 其实和数组没有特别大的关系，只是原型对象上挂载了 <code>slice</code> 方法以及 <code>byteLength</code> 属性，它的原型指向了 <code>Object.prototype</code> 。</p>
<ul>
<li><code>ArrayBuffer</code> 分配失败时会抛出错误。</li>
<li>分配的内存不能超过 <code>Number.MAX_SAFE_INTEGER</code> 即 (2^53 - 1) 字节。</li>
<li>声明 <code>ArrayBuffer</code> 会将所有二进制位初始化为 <code>0</code> 。</li>
<li>分配的堆内存可以被垃圾回收，不需要手动释放。</li>
</ul>
</li>
<li><h5 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a><code>DataView</code></h5><p>允许读写 <code>ArrayBuffer</code> 的视图。专为文件 <code>I/O</code> 和网络 <code>I/O</code> 设计，支持对缓冲数据的高度控制，但性能较差，对缓冲内容没有任何预设，也不能迭代。</p>
<p>查看 <code>DataView</code> 的构造函数定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DataView</span>(buffer: <span class="built_in">ArrayBuffer</span>, byteOffset?: number, byteLength?: number): <span class="built_in">DataView</span></span><br></pre></td></tr></table></figure>

<p>可以看出，第一个参数是必填的 <code>ArrayBuffer</code> ，第二个参数为偏移量，第三个参数为字节长度。若不指定，偏移量默认从 <code>0</code> 开始，字节长度默认为剩余缓冲。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.byteOffset); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.byteLength); <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.buffer === buf); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.byteOffset); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.buffer === buf); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.byteOffset); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.buffer === buf); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ElementType</code></p>
<p>用于实现 <code>JavaScript</code> 中的 <code>Number</code> 类型到缓冲内二进制格式的转换。有以下几种类型：</p>
<ul>
<li><code>Int8</code></li>
<li><code>Uint8</code></li>
<li><code>Int16</code></li>
<li><code>Uint16</code></li>
<li><code>Int32</code></li>
<li><code>Uint32</code></li>
<li><code>Float32</code></li>
<li><code>Float64</code></li>
</ul>
<p>每种类型都有 <code>get</code> 和 <code>set</code> 方法，使用 <code>byteOffset</code> 定位位置进行读写。类型间可以相互转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>); <span class="comment">// 分配了两个字节</span></span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf); <span class="comment">// 定义一个视图</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>)); <span class="comment">// -256</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xff</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字节序</p>
<p>字节序指计算系统维护的一种字节顺序的约定。</p>
<p><code>DataView</code> 支持两种约定，大端字节序和小端字节序。</p>
<p>大端字节序指最高有效位保存在第一个字节，最低有效位保存在最后一个字节，也称网络字节序。</p>
<p>小端字节序则相反。</p>
<p><code>DataView</code> 不遵守 <code>JavaScript</code> 运行时所在系统的原生字节序。它默认为大端字节序，也可以接收参数修改为小端字节序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于 1</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于 1</span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1</span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001</span></span><br><span class="line"><span class="comment">// 按大端字节序读取 Uint16</span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint16(<span class="number">0</span>)); <span class="comment">// 32769</span></span><br><span class="line"><span class="comment">// 按小端字节序读取 Uint16</span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint16(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384</span></span><br><span class="line"><span class="comment">// 按大端字节序写入 Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4</span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint8(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 按小端字节序写入 Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0</span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint8(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getUint8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>边界情形</p>
<p><code>DataView</code> 的操作需要在缓冲区范围内，否则会抛出 <code>RangeError</code> 。</p>
<p>写缓冲的时候会将写入值转为适当类型，若是无法转换则会抛出错误。</p>
</li>
</ul>
</li>
<li><h5 id="定型数组-1"><a href="#定型数组-1" class="headerlink" title="定型数组"></a>定型数组</h5><p>定型数组是另一种形式的 <code>ArrayBuffer</code> 视图。它特定于一种 <code>ElementType</code> 且遵循系统原生的字节序。目的在于提高与 <code>WebGL</code> 等原生库交换二进制数据的效率。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过 <code>&lt;ElementType&gt;.from()</code> 和 <code>&lt;ElementType&gt;.of()</code> 也可以创建定型数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 12 字节的缓冲</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// 创建一个引用该缓冲的 Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buf);</span><br><span class="line"><span class="comment">// 这个定型数组知道自己的每个元素需要 4 字节</span></span><br><span class="line"><span class="comment">// 因此长度为 3</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 6 的 Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.length); <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 类似 DataView，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.buffer.byteLength); <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的 Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints3.length); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints3.buffer.byteLength); <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(ints3[<span class="number">2</span>]); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过复制 ints3 的值创建一个 Int16Array</span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(ints3);</span><br><span class="line"><span class="comment">// 这个新类型数组会分配自己的缓冲</span></span><br><span class="line"><span class="comment">// 对应索引的每个值会相应地转换为新格式</span></span><br><span class="line"><span class="built_in">console</span>.log(ints4.length); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints4.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints4[<span class="number">2</span>]); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于普通数组来创建一个 Int16Array</span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="built_in">Int16Array</span>.from([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints5.length); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints5.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints5[<span class="number">2</span>]); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于传入的参数创建一个 Float32Array</span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="built_in">Float32Array</span>.of(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>);</span><br><span class="line"><span class="built_in">console</span>.log(floats.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.buffer.byteLength); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">2</span>]); <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure>

<p>查看定型数组的构造函数原型对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Int16Array</span>.prototype);</span><br><span class="line"><span class="comment">// BYTES_PER_ELEMENT: 2 返回该类型数组中每个元素的大小</span></span><br><span class="line"><span class="comment">// buffer: (...)</span></span><br><span class="line"><span class="comment">// byteLength: (...)</span></span><br><span class="line"><span class="comment">// byteOffset: (...)</span></span><br><span class="line"><span class="comment">// constructor: ƒ Int16Array()</span></span><br><span class="line"><span class="comment">// length: (...)</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.toStringTag): (...)</span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Int32Array</span>.prototype);</span><br><span class="line"><span class="comment">// BYTES_PER_ELEMENT: 4</span></span><br><span class="line"><span class="comment">// buffer: (...)</span></span><br><span class="line"><span class="comment">// byteLength: (...)</span></span><br><span class="line"><span class="comment">// byteOffset: (...)</span></span><br><span class="line"><span class="comment">// constructor: ƒ Int32Array()</span></span><br><span class="line"><span class="comment">// length: (...)</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.toStringTag): (...)</span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br></pre></td></tr></table></figure>

<p>如果在初始化时没有提供值，那么关联的缓冲会以 <code>0</code> 填充。</p>
<ul>
<li><p>定型数组行为</p>
<p>定型数组的原型对象上绑定了非常多的数组方法，继承自一个叫 <code>TypedArray</code> 的类型。</p>
<p>定型数组缺少修改大小的几个数组方法：</p>
<ul>
<li><code>concat</code></li>
<li><code>pop</code></li>
<li><code>push</code></li>
<li><code>shift</code></li>
<li><code>splice</code></li>
<li><code>unshift</code></li>
</ul>
<p>但提供了两个新方法，可以用于复制数据：</p>
<ul>
<li><code>set</code></li>
<li><code>subarray</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line">container.set(<span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(container); <span class="comment">// Int16Array(8) [1, 2, 3, 4, 0, 0, 0, 0]</span></span><br><span class="line">container.set([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(container); <span class="comment">// Int16Array(8) [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>看一下 <code>set</code> 的函数定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(array: ArrayLike&lt;<span class="built_in">number</span>&gt;, offset?: <span class="built_in">number</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>偏移量溢出时会抛出错误。</p>
<p><code>subarray</code> 会从原定型数组中复制出一个新定型数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">Int16Array</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.subarray();</span><br><span class="line"><span class="built_in">console</span>.log(fullCopy); <span class="comment">// Int16Array(4) [2, 4, 6, 7]</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.subarray(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(halfCopy); <span class="comment">// Int16Array(2) [6, 7]</span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(partialCopy); <span class="comment">// Int16Array(2) [4, 6]</span></span><br></pre></td></tr></table></figure>

<p>看一下 <code>subarray</code> 的函数定义</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">subarray(begin?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="built_in">Int16Array</span></span><br></pre></td></tr></table></figure>

<p>手写定型数组拼接函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typedArrayConcat</span>(<span class="params">typedArrayConstructor, ...typedArrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numElements = typedArrays.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> (x.length || x) + y.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> typedArrayConstructor(numElements);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentOffset = <span class="number">0</span>;</span><br><span class="line">  typedArrays.map(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    resultArray.set(x, currentOffset);</span><br><span class="line">    currentOffset += x.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> concatArray = typedArrayConcat(</span><br><span class="line">  <span class="built_in">Int32Array</span>,</span><br><span class="line">  <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  <span class="built_in">Int16Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">  <span class="built_in">Float32Array</span>.of(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(concatArray); <span class="comment">// Int32Array(9) [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下溢和上溢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长度为 2 的有符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个二补数形式的有符号整数</span></span><br><span class="line"><span class="comment">// 范围是-128（-1 * 2^7）~127（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 长度为 2 的无符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个无符号整数</span></span><br><span class="line"><span class="comment">// 范围是 0~255（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引</span></span><br><span class="line"><span class="comment">// 索引只取最低有效位上的 8 位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>; <span class="comment">// 0x100</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts); <span class="comment">// [0, 0]</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>; <span class="comment">// 0x1FF</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts); <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line"><span class="comment">// 0xFF 是以二补数形式表示的-1（截取到 8 位）,</span></span><br><span class="line"><span class="comment">// 但 255 是一个无符号整数</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">// 0xFF (truncated to 8 bits)</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts); <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80 是无符号整数的 128，是二补数形式的-128</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>; <span class="comment">// 0x80</span></span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [0, -128]</span></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF 是无符号整数的 255，是二补数形式的-1</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>; <span class="comment">// 0xFF</span></span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure>

<p>还存在一种数组类型 <code>Unit8ClampedArray</code> ， 不允许任何方向溢出。超出的值会被向下舍入为 <code>255</code> ， 小于的值会被向上舍入为 <code>0</code> 。</p>
</li>
</ul>
</li>
</ol>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>ES6</code> 中新增的集合类型，真正意义上的键值存储机制。</p>
<ol>
<li><h5 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 <code>API</code></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>

<p>初始化时可以传入一个可迭代对象，需要包含键值对数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(m1); <span class="comment">// Map(3) &#123;"key1" =&gt; "val1", "key2" =&gt; "val2", "key3" =&gt; "val3"&#125;</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">"key1"</span>, <span class="string">"val1"</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">"key2"</span>, <span class="string">"val2"</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">"key3"</span>, <span class="string">"val3"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(m2.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]);</span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>set()</code></p>
<p>初始化后添加键值对的方法。</p>
</li>
<li><p><code>get()</code></p>
<p>获取值。</p>
</li>
<li><p><code>has()</code></p>
<p>查询是否存在值。</p>
</li>
<li><p><code>size</code></p>
<p>获取映射中的键值对数量。</p>
</li>
<li><p><code>delete</code></p>
<p>删除某个键值对。</p>
</li>
<li><p><code>clear</code></p>
<p>清空该映射的所有键值对。</p>
</li>
</ul>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li><h4 id="是否需要-else"><a href="#是否需要-else" class="headerlink" title="是否需要 else ?"></a>是否需要 else ?</h4><p>如果参数 <code>age</code> 大于 <code>18</code>，那么下面的函数将返回 <code>true</code>。</p>
<p>否则它将会要求进行确认，并返回确认结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> confirm(<span class="string">'Did parents allow you?'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>else</code> 被删除，函数的工作方式会不同吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> confirm(<span class="string">'Did parents allow you?'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作方式相同，因为 <code>return</code> 执行后函数就已经结束。此处的 <code>else</code> 并没有意义。</p>
</li>
<li><h4 id="使用-或-重写函数"><a href="#使用-或-重写函数" class="headerlink" title="使用 ? 或 || 重写函数"></a>使用 ? 或 || 重写函数</h4><p>如果参数 <code>age</code> 大于 <code>18</code>，那么下面的函数返回 <code>true</code>。</p>
<p>否则它将会要求进行确认，并返回确认结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> confirm(<span class="string">'Do you have your parents permission to access this page?'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写这个函数并保证效果相同，不使用 <code>if</code>，且只需一行代码。</p>
<p>编写 <code>checkAge</code> 的两个变体：</p>
<ol>
<li><h5 id="使用问号运算符"><a href="#使用问号运算符" class="headerlink" title="使用问号运算符 ?"></a>使用问号运算符 <code>?</code></h5></li>
<li><h5 id="使用或运算符"><a href="#使用或运算符" class="headerlink" title="使用或运算符 ||"></a>使用或运算符 <code>||</code></h5></li>
</ol>
<ul>
<li><pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>{
  <span class="keyword">return</span> age &gt; <span class="number">18</span> ? <span class="literal">true</span> : confirm(<span class="string">'Do you have your parents permission to access this page?'</span>);
}
&lt;!--￼<span class="number">19</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><h4 id="函数-min-a-b"><a href="#函数-min-a-b" class="headerlink" title="函数 min(a, b)"></a>函数 min(a, b)</h4><p>写一个返回数字 <code>a</code> 和 <code>b</code> 中较小的那个数字的函数 <code>min(a,b)</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">min(<span class="number">2</span>, <span class="number">5</span>) == <span class="number">2</span></span><br><span class="line">min(<span class="number">3</span>, <span class="number">-1</span>) == <span class="number">-1</span></span><br><span class="line">min(<span class="number">1</span>, <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="函数-pow-x-n"><a href="#函数-pow-x-n" class="headerlink" title="函数 pow(x, n)"></a>函数 pow(x, n)</h4><p>写一个函数 <code>pow(x,n)</code>，返回 <code>x</code> 的 <code>n</code> 次方。换句话说，将 <code>x</code> 与自身相乘 <code>n</code> 次，返回最终结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>) = <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span></span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>) = <span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span> = <span class="number">27</span></span><br><span class="line">pow(<span class="number">1</span>, <span class="number">100</span>) = <span class="number">1</span> * <span class="number">1</span> * ...*<span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * pow(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO-LIST"></a>TODO-LIST</h2><ul>
<li><input disabled type="checkbox"> 想尝试一下 <code>hugo</code> 作为博客。</li>
<li><input checked disabled type="checkbox"> 整理 18 年的笔记。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 2020 10 11</title>
    <url>/2020/10/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-11/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-11"><a href="#学习笔记-2020-10-11" class="headerlink" title="学习笔记 2020-10-11"></a>学习笔记 2020-10-11</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ol>
<li><h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code> 方法本质是返回数组中每个值的等效字符串加逗号分隔拼接成的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">  toLocaleString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Sirine'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Sirine'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">  toLocaleString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Severus'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'siruis'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> people = [person1, person2];</span><br><span class="line"><span class="built_in">console</span>.log(people); <span class="comment">// [&#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(people.toString()); <span class="comment">// Sirine,siruis</span></span><br><span class="line"><span class="built_in">console</span>.log(people.toLocaleString()); <span class="comment">// Sirine,Severus</span></span><br></pre></td></tr></table></figure>

<p>由上例可以看出，<code>toString</code> 方法调用自身的 <code>toString</code> 来转换，<code>toLocaleString</code> 调用自身的 <code>toLocaleString</code> 。</p>
</li>
<li><h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><p>后进先出的数据结构，数据的推入和删除只发生在栈顶。</p>
<ul>
<li><p><code>push</code></p>
<p>接收任意数量的参数，将它们添加到数组末尾，返回数组的最新长度。</p>
</li>
<li><p><code>pop</code></p>
<p>用于删除数组的最后一项，减少数组的长度，返回被删除的项。</p>
</li>
</ul>
</li>
<li><h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><p>先进先出的数据结构，末尾添加数据，开头获取数据。</p>
<ul>
<li><p><code>shift</code></p>
<p>返回被删除的项。</p>
</li>
<li><p><code>push</code></p>
</li>
<li><p><code>unshift</code></p>
<p>与 <code>shift</code> 相反，在数组开头添加任意数量的值，返回新的数组长度。</p>
</li>
</ul>
</li>
<li><h5 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h5><p>以下两个方法都返回调用的数组的引用。</p>
<ul>
<li><p><code>reverse</code></p>
<p>反向排列数组。</p>
</li>
<li><p><code>sort</code></p>
<p>排序数组。默认按照升序，每一项调用 <code>String</code> 转换，比较字符串决定顺序。也可以接受一个比较函数，函数的返回值决定每两个数比较的排序情况，返回负值代表第一个数排在第二个前面，返回 <code>0</code> 代表相等，返回正值代表第一个数排在第二个后面。</p>
</li>
</ul>
</li>
<li><h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><ul>
<li><p><code>concat</code></p>
<p>在原有数组基础上创建一个新数组，将参数添加到数组末尾。不改变原数组。返回新数组。</p>
<p><code>concat</code> 默认会打平数组参数，即传入的数组参数会被展开。设置数组的 <code>Symbol.isConcatSpreadable</code> 可以修改这个行为。如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123;</span><br><span class="line"> [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line"> length: <span class="number">2</span>,</span><br><span class="line"> <span class="number">0</span>: <span class="string">"pink"</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">"cyan"</span></span><br><span class="line">&#125;;</span><br><span class="line">newColors[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">"yellow"</span>, newColors);</span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.concat(moreNewColors);</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["red", "green", "blue", "yellow",["black", "brown"]]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// ["red", "green", "blue", "pink", "cyan"]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p><code>slice</code></p>
<p>接收一到二个参数，返回元素的开始索引和结束索引，若只提供了开始索引，会默认返回到数组末尾。返回的数组不包括结束索引(若存在)对应的元素。不影响原数组。这个函数的参数接受负值，代表从末尾开始。若结束位置小于开始位置，返回空数组。</p>
</li>
<li><p><code>splice</code></p>
<p>有三种不同的使用方式，返回值为被删除的元素或是空数组。</p>
<ul>
<li><p>删除</p>
<p>传递两个参数，删除的第一个元素位置以及删除的数量。</p>
</li>
<li><p>插入</p>
<p>传递三个参数，开始位置，<code>0</code> 和插入的元素，不仅限于三个参数，多于三个的参数都会被看作用于插入的元素。</p>
</li>
<li><p>替换</p>
<p>在删除的同时插入新元素，即插入的另一种模式，不再是删除 <code>0</code> 个元素。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// ["red"]</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'yellow'</span>, <span class="string">'orange'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["green", "yellow", "orange", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'red'</span>, <span class="string">'purple'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["green", "red", "purple", "orange", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// ["yellow"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ol start="6">
<li><h5 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h5><ul>
<li><code>indexOf</code></li>
<li><code>lastIndexOf</code></li>
<li><code>includes</code></li>
</ul>
<p>上述三个方法都接收两个参数，要查找的元素和一个可选的起始位置。并且三个方法都是严格相等比较。</p>
<p><code>indexOf</code> 和 <code>includes</code> 从数组前头开始搜索， <code>lastIndexOf</code> 从末尾开始搜索。<br><code>indexOf</code> 和 <code>lastIndeOf</code> 返回查找的位置或是 <code>-1</code> ， <code>includes</code> 返回 <code>true</code> 或 <code>false</code> 表示是否找到至少一个匹配的元素。</p>
<ul>
<li><p><code>find</code></p>
</li>
<li><p><code>findIndex</code></p>
<p>上述两个方法接收断言函数和一个可选的断言函数内部 <code>this</code> 的值，断言函数接收三个参数，元素、索引和数组本身。断言函数返回真值，代表是否匹配。</p>
<p><code>find</code> 返回第一个匹配的元素，<code>findIndex</code> 返回第一个匹配元素的索引。找到匹配项后，都不再继续搜索。</p>
</li>
</ul>
</li>
<li><h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p>以下方法都对数组每一项运行传入的函数。不改变原数组。</p>
<ul>
<li><p><code>every</code></p>
<p>若每一项使得函数返回值都为 <code>true</code> , 那么这个方法返回 <code>true</code> 。</p>
</li>
<li><p><code>filter</code></p>
<p>函数返回值为 <code>true</code> 的项组成一个数组返回。</p>
</li>
<li><p><code>forEach</code></p>
<p>没有返回值，仅对每一项运行函数。</p>
</li>
<li><p><code>map</code></p>
<p>返回每一项函数调用的结果构成的函数。</p>
</li>
<li><p><code>some</code></p>
<p>有一项使得函数返回值为 <code>true</code> , 方法返回 <code>true</code> 。</p>
</li>
</ul>
</li>
</ol>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><ol>
<li><p><code>switch</code> 语句可以替代 <code>if</code> 判断，执行严格相等比较。</p>
</li>
<li><p><code>switch</code> 和 <code>case</code> 允许任意表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (+a) &#123;</span><br><span class="line">  <span class="keyword">case</span> b + <span class="number">1</span>:</span><br><span class="line">    alert(<span class="string">"this runs, because +a is 1, exactly equals b+1"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">"this doesn't run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><code>case</code> 分组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert(<span class="string">'Right!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// (*) 下面这两个 case 被分在一组</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert(<span class="string">'Wrong!'</span>);</span><br><span class="line">    alert(<span class="string">"Why don't you take a math class?"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">'The result is strange. Really.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h3><ol>
<li><p>将 <code>switch</code> 结构重写为 <code>if</code> 结构</p>
<p>将下面 <code>switch</code> 结构的代码写成 <code>if..else</code> 结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (browser) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'Edge'</span>:</span><br><span class="line">    alert( <span class="string">"You've got the Edge!"</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'Chrome'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'Firefox'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'Safari'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'Opera'</span>:</span><br><span class="line">    alert( <span class="string">'Okay we support these browsers too'</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert( <span class="string">'We hope that this page looks ok!'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (browser === <span class="string">'Edge'</span>) &#123;</span><br><span class="line">  alert(<span class="string">"You've got the Edge!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (browser === <span class="string">'Chrome'</span></span><br><span class="line">  || browser === <span class="string">'Firefox'</span></span><br><span class="line">  || browser === <span class="string">'Safari'</span></span><br><span class="line">  || browser === <span class="string">'Opera'</span>) &#123;</span><br><span class="line">  alert( <span class="string">'Okay we support these browsers too'</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert( <span class="string">'We hope that this page looks ok!'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将 <code>if</code> 结构重写为 <code>switch</code> 结构</p>
<p>用 <code>switch</code> 重写以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = +prompt(<span class="string">'a?'</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">  alert( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">  alert( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span> || a == <span class="number">3</span>) &#123;</span><br><span class="line">  alert( <span class="string">'2,3'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = +prompt(<span class="string">'a?'</span>, <span class="string">''</span>);</span><br><span class="line"><span class="keyword">switch</span>(a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    alert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    alert(<span class="string">'2,3'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="JavaScript-深入学习"><a href="#JavaScript-深入学习" class="headerlink" title="JavaScript 深入学习"></a>JavaScript 深入学习</h2><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ol>
<li><h5 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h5><p>语法错误，例如变量名不规范不合法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="number">1</span> = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> = <span class="number">2</span>; <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h5><p>变量或函数未声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a(); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h5><p>范围出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length = <span class="number">-1</span>; <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">66.66</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">-1</span>)); <span class="comment">// Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h5><p>类型错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>(); <span class="comment">// Uncaught TypeError: 123 is not a function</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h5><p>URI: uniform resource identifier 统一资源标识符</p>
<p>URL: uniform resource locator 统一资源定位符</p>
<p>URN: uniform resource name 统一资源名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">decodeURI</span>(<span class="string">'%abcde'</span>); <span class="comment">// Uncaught URIError: URI malformed at decodeURI (&lt;anonymous&gt;)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(jsonStr);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 出现错误时捕获错误。</span></span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 无论出错与否都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>手动抛出错误。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式下 <code>with</code> <code>callee</code> <code>caller</code> 无法使用。</p>
<p>函数内部的 <code>this</code> 默认值为 <code>undefined</code> 。需要显式指定。</p>
<p>使用 <code>call</code> 这类方法改变 <code>this</code> 指向时，如果传入的是原始值，会被包装为包装类。</p>
<p>函数的参数不允许重复。</p>
<p>对象的键不允许重复，但不报错，只会默认覆盖。</p>
<p><code>eval</code> 内存在一个作用域，外部无法访问内部变量。</p>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO-LIST"></a>TODO-LIST</h2><ul>
<li><input disabled type="checkbox"> 想尝试一下 <code>hugo</code> 作为博客。</li>
<li><input checked disabled type="checkbox"> 整理 18 年的笔记。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>写给两年前的自己</title>
    <url>/2020/10/11/%E5%86%99%E7%BB%99%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<h1 id="写给两年前的自己"><a href="#写给两年前的自己" class="headerlink" title="写给两年前的自己"></a>写给两年前的自己</h1><p>今天是 2020 年 10 月 11日，一个平平无奇的周日。6点没到就难受地醒了过来，拔洗衣机水管时又记错了方向，喷了自己一身的水。17号就要体测，我还有点小焦虑。</p>
<a id="more"></a>

<p>昨晚随手整理了一下磁盘，发现了18年写下的一些学习笔记。翻了一下，只觉得好笑。</p>
<p>两年前我还不知道怎么记电子笔记，只能笨拙地将代码和思考写进了 <code>word</code> 文档，再试图转成  <code>pdf</code> 。还记得后来发现了 <code>onenote</code> ，也用它记过一小段时间，为了更好地记录代码，下载了 <code>highlight</code> 插件来高亮提示。</p>
<p>记在 <code>onenote</code> 里的笔记我都转成 <code>markdown</code> 了，那些 <code>word</code> 文档里的东西还没整理，抽时间整理一下。(<code>todo</code> <code>get</code> ✔)</p>
<p>仔细看看当时记的笔记，都是些学习时候的困扰。原来 <code>18</code> 年底我就已经在看 <code>ES6</code> 的内容了，而两年后的我依然不敢说学得有多精妙。那时候的我完全捋不清楚 <code>JSON</code> 和 <code>JS</code> 对象的关系，不知道是谁 <code>parse</code> 成了谁，又是谁 <code>stringify</code> 成了谁。也是那个时候看着英文书，误打误撞下载了 <code>Nodejs</code> ，也不会用，只能一字一句看着陌生的单词慢慢琢磨。(<del>两年后英文依然烂的可以</del>) 还记得两年前我完全不懂 <code>github</code> 如何使用，<code>git</code> 操作又是什么，那些 <code>github</code> 的开源项目为什么目录那么复杂，那么多我不认识的文件。前端开发不是只有 <code>html</code> <code>css</code> <code>js</code> 吗？现在想起也只能为那时候的无知掩面。</p>
<p>回首一下两年的经历，很惊讶我居然还在 <code>web</code> 开发这条路上摸爬滚打，很难过我大概没法追得上那些学安全的同学们。在我对开发还一无所知的时候，他们已经拥有了许多的开发经验。在我对安全一知半解的时候，他们已经可以左一个漏洞右一个漏洞的挣钱了。我想我对钱总是更敏感的，所以我总是对被远远甩下的那几年时光耿耿于怀。但又很庆幸我没有太过自暴自弃(或者说没有太长时间的自暴自弃)，我总是在不停地赶，就像800米一样，我追不上别人，我很难过，身体也很累，但我在努力地不停步了。也为此刻的自己没有被滚滚而来的洪流拍开而庆幸，我至少也还是有点长处的吧。</p>
<p>一转眼就8点了，大概写了20分钟。其中无数次停下思考、琢磨，希望写得更好一些。好让将来的我，(也许就是两年后)看得更加舒心。</p>
<p>其实说得是写给两年前的自己，但我更加给两年后的自己。在2022年，不知道我又是哪个模样。</p>
<p>感谢两年前的自己很果断地选择了方向，也没有太过荒废这些时光。让今天的我也有东西可写，摸得出一点优点沾沾自喜。</p>
<p>但愿两年后的自己更加幸运与成功，愿我这段时日的努力都有回报，希望自己未来可以的过得很好。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>学习笔记 2020 10 10</title>
    <url>/2020/10/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2020-10-10/</url>
    <content><![CDATA[<h1 id="学习笔记-2020-10-10"><a href="#学习笔记-2020-10-10" class="headerlink" title="学习笔记 2020-10-10"></a>学习笔记 2020-10-10</h1><blockquote>
<p>决定从今天开始每天记录当日学习所得。</p>
</blockquote>
<a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h3><h4 id="1-Object"><a href="#1-Object" class="headerlink" title="1. Object"></a>1. Object</h4><p><code>Object</code> 是 <code>ECMAScript</code> 中最常用的类型之一。</p>
<p>创建 <code>Object</code> 实例的方法：</p>
<ul>
<li><p>使用 <code>new</code> 操作符和 <code>Object</code> 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Sirine'</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用对象字面量方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐使用 ✔</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sirine'</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对象中获取属性的方法：</p>
<ul>
<li><p>点语法</p>
</li>
<li><p>中括号语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">// 以上两种语法等价</span></span><br></pre></td></tr></table></figure>

<p>但在使用中括号语法获取属性时可以传入变量或是包含空格等字符的键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'name'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]);</span><br><span class="line"><span class="comment">// === console.log(person['name']);</span></span><br><span class="line"><span class="comment">// 键名包含空格时必须使用中括号语法。</span></span><br><span class="line">person[<span class="string">'first name'</span>] = <span class="string">'Zhao'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. Array</h4><p><code>ECMAScript</code> 中的数组十分自由，数组内元素的类型不受限制，大小也是动态的。</p>
<p>创建数组的方法也是两种。</p>
<ul>
<li><p><code>Array</code> 构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 创建一个长度为 0 的空数组。</span></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 创建一个长度为 20 的空数组。</span></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="comment">// 创建一个长度为 3 ，包含 red blue green 三个字符串的数组。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数组字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line">  <span class="comment">// 创建一个长度为3，包含 red blue green 三个字符串的数组。</span></span><br><span class="line"><span class="keyword">let</span> names = [];</span><br><span class="line">  <span class="comment">// 创建一个长度为 0 的空数组。</span></span><br><span class="line">  <span class="keyword">let</span> options = [,,,,,];</span><br><span class="line">  <span class="comment">// 创建一个长度为 5 的数组。空位元素为 `undefined`;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option === <span class="literal">undefined</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// true * 5</span></span><br><span class="line">  <span class="comment">// 空位元素在 map join 等方法中会被跳过。</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><code>ES6</code> 当中新增了两个创建数组的静态方法。</p>
<ul>
<li><p><code>Array.from</code></p>
<p>这个方法可以将任何可迭代的结构例如类数组，转换为数组。</p>
<p>可迭代结构举例：字符串、<code>Map</code> 实例， <code>Set</code> 实例，拥有 <code>[Symbol.iterator]</code> 方法的对象，函数的 <code>arguments</code> 对象， 携带有索引键值和 <code>length</code> 属性的对象。</p>
<p>该方法的第一个参数为被转换的对象，第二个参数为映射函数，第三个参数为映射函数的 <code>this</code> 指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, x =&gt; x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="keyword">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>Array.of</code></p>
<p>用于替代 <code>Array.prototype.slice.call(arguments)</code> ，将传入的参数转换为数组。</p>
</li>
</ul>
<p>数组的索引值可以动态修改，并且会直接影响到数组的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">options.length = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(options);</span><br><span class="line"><span class="comment">// [10, 9, 8, 7, 6, 5, 4, empty × 3]</span></span><br><span class="line">options.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(options);</span><br><span class="line"><span class="comment">// [10, 9, 8]</span></span><br><span class="line">options[<span class="number">50</span>] = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(options);</span><br><span class="line"><span class="comment">// [10, 9, 8, empty × 47, 50]</span></span><br></pre></td></tr></table></figure>

<p>在数组中访问不存在的元素(例如下标越界)的时候会返回 <code>undefined</code> 。前面也提到了被设置为 <code>empty</code> 的数组元素被访问时也是被当作 <code>undefined</code> 。</p>
<p>数组最多可以包含的元素值为 <code>4 294 967 295</code> 。</p>
<p>判断是否为数组的方法有：</p>
<ul>
<li><code>instanceof</code></li>
<li><code>Array.isArray</code> </li>
</ul>
<p>两者的区别是 <code>instanceof</code> 的返回结果取决于 <code>Array</code> 构造函数(即是否为某个构造函数的实例)，而 <code>isArray</code> 只会判断是否为一个数组。</p>
<p><code>Array</code> 新增的三个迭代器方法：</p>
<ul>
<li><p><code>keys()</code></p>
<p>返回数组索引的迭代器。</p>
</li>
<li><p><code>values()</code></p>
<p>返回数组元素的迭代器。</p>
</li>
<li><p><code>entries()</code></p>
<p>返回索引值对的迭代器。</p>
</li>
</ul>
<p>三个迭代器都可以通过 <code>Array.from</code> 转换为数组。也可以用于 <code>for of</code> 循环迭代。</p>
<p><code>Array</code> 新增的复制和填充方法：</p>
<ul>
<li><p><code>copyWithin(insertIndex, copyIndex, lastIndex)</code></p>
</li>
<li><p><code>fill(arg, startIndex, lastIndex)</code></p>
<p>两个方法的索引值都支持负值。</p>
<p><code>copyWithin</code> 从 <code>copyIndex</code> 开始复制到 <code>lastIndex</code> 结束(可忽略)，复制到 <code>insertIndex</code> 位置。若忽略复制索引则全部复制。</p>
<p><code>fill</code> 方法将第一个参数填充到 <code>startIndex</code> 开始到 <code>lastIndex</code> 前一个位置，若忽略索引值则整个数组进行填充。</p>
<p>两个方法的操作都是对原有元素的覆盖。</p>
</li>
</ul>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="break-continue"><a href="#break-continue" class="headerlink" title="break/continue"></a>break/continue</h3><p>非表达式的语法结构不能与三元运算符一起使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  alert(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有问题</span></span><br><span class="line"></span><br><span class="line">(i &gt; <span class="number">5</span>) ? alert(i) : <span class="keyword">continue</span>; <span class="comment">// 语法错误</span></span><br></pre></td></tr></table></figure>

<h4 id="标签用法："><a href="#标签用法：" class="headerlink" title="标签用法："></a>标签用法：</h4><p>适用于多层循环嵌套跳出的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">break</span> outer; <span class="comment">// 若满足条件，则跳出至最外层。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(<span class="string">'Done!'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h4><h5 id="1-最后一次循环的值"><a href="#1-最后一次循环的值" class="headerlink" title="1. 最后一次循环的值"></a>1. 最后一次循环的值</h5><p>此代码最后一次 <code>alert</code> 值是多少？为什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (i) &#123;</span><br><span class="line">  alert( i-- );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案为 <code>1</code>  ，循环体内使用了后置自减，那么在弹出后才会对 <code>i</code> 自减，当 <code>i</code> 为 <code>1</code> 时，弹出显示，然后自减为 <code>0</code> , 再次判断循环条件，不符合，不再进入循环。</p>
<h5 id="2-while-循环显示哪些值？"><a href="#2-while-循环显示哪些值？" class="headerlink" title="2. while 循环显示哪些值？"></a>2. while 循环显示哪些值？</h5><p>以下两个循环的 <code>alert</code> 值是否相同？</p>
<ol>
<li><p>前缀形式 <code>++i</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (++i &lt; <span class="number">5</span>) alert( i );</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>后缀形式 <code>i++</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i++ <span class="xml"><span class="tag">&lt; <span class="attr">5</span>) <span class="attr">alert</span>( <span class="attr">i</span> );</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>两个循环的 <code>alert</code> 值前四次相等，因为不管是前置还是后置，<code>i</code> 的自增都在条件判断处完成，对于 <code>alert</code> 不影响。</p>
<p>但是自增的时间影响了循环执行的次数。</p>
<p>因为第一个循环是自增后再判断，每次循环的 <code>i</code> 为 <code>1, 2, 3, 4, 5</code> , 第五次已经无法满足条件判断，不再进入循环，所以只打印了四次。</p>
<p>第二个循环是自增前判断，判断时的 <code>i</code> 值依次为 <code>0, 1, 2, 3, 4, 5</code> ，因此该循环多了一次进入循环的机会，因为进入循环时 <code>i</code> 已经完成自增，所以打印的值依次为 <code>1, 2, 3, 4, 5</code> 。</p>
<h5 id="3-for-循环显示哪些值？"><a href="#3-for-循环显示哪些值？" class="headerlink" title="3. for 循环显示哪些值？"></a>3. for 循环显示哪些值？</h5><p>两次循环 <code>alert</code> 值是否相同？</p>
<ol>
<li><p>后缀形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) alert( i );</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>前缀形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) alert( i );</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>两次循环显示的值完全相同，因为 <code>for</code> 循环的自增条件是单独执行，不与条件判断放置在一起。写成 <code>while</code> 循环就是类似于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">  alert(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，这样的自增无论是前置还是后置都没有影响。</p>
<h5 id="4-使用-for-循环输出偶数"><a href="#4-使用-for-循环输出偶数" class="headerlink" title="4. 使用 for 循环输出偶数"></a>4. 使用 for 循环输出偶数</h5><p>使用 <code>for</code> 循环输出从 <code>2</code> 到 <code>10</code> 的偶数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>

<h5 id="5-使用-while-替换-for"><a href="#5-使用-while-替换-for" class="headerlink" title="5. 使用 while 替换 for"></a>5. 使用 while 替换 for</h5><p>重写代码，在保证不改变其行为的情况下，将 <code>for</code> 循环更改为 <code>while</code>（输出应保持不变）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  alert( <span class="string">`number <span class="subst">$&#123;i&#125;</span>!`</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  alert( <span class="string">`number <span class="subst">$&#123;i&#125;</span>!`</span> );</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-重复输入，直到正确为止"><a href="#6-重复输入，直到正确为止" class="headerlink" title="6. 重复输入，直到正确为止"></a>6. 重复输入，直到正确为止</h5><p>编写一个提示用户输入大于 <code>100</code> 的数字的循环。如果用户输入其他数值 —— 请他重新输入。</p>
<p>循环一直在请求一个数字，直到用户输入了一个大于 <code>100</code> 的数字、取消输入或输入了一个空行为止。</p>
<p>在这我们假设用户只会输入数字。在本题目中，不需要对非数值输入进行特殊处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = prompt(<span class="string">'please input a number greater than 100!'</span>);</span><br><span class="line"><span class="keyword">while</span>(input &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input === <span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">'input canceled.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (input === <span class="string">''</span>) &#123;</span><br><span class="line">    alert(<span class="string">'you enter a nothing.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  input = prompt(<span class="string">'please input a number greater than 100!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  num = prompt(<span class="string">"Enter a number greater than 100?"</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt;= <span class="number">100</span> &amp;&amp; num);</span><br></pre></td></tr></table></figure>

<p>代码简洁，利用了 <code>do while</code> 循环的特性。</p>
<h5 id="7-输出素数"><a href="#7-输出素数" class="headerlink" title="7. 输出素数"></a>7. 输出素数</h5><p>大于 <code>1</code> 且不能被除了 <code>1</code> 和它本身以外的任何数整除的整数叫做<a href="https://en.wikipedia.org/wiki/Prime_number" target="_blank" rel="noopener">素数</a>。</p>
<p>换句话说，<code>n &gt; 1</code> 且不能被 <code>1</code> 和 <code>n</code> 以外的任何数整除的整数，被称为素数。</p>
<p>例如，<code>5</code> 是素数，因为它不能被 <code>2</code>、<code>3</code> 和 <code>4</code> 整除，会产生余数。</p>
<p><strong>写一个可以输出 <code>2</code> 到 <code>n</code> 之间的所有素数的代码。</strong></p>
<p>当 <code>n = 10</code>，结果输出 <code>2、3、5、7</code>。</p>
<p>P.S. 代码应适用于任何 <code>n</code>，而不是对任何固定值进行硬性调整。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = prompt(<span class="string">''</span>, <span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'the n invalid'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === num) &#123;</span><br><span class="line">      num--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % num === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isPrime(i)) arr.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>



<h2 id="JavaScript-深入学习"><a href="#JavaScript-深入学习" class="headerlink" title="JavaScript 深入学习"></a>JavaScript 深入学习</h2><h3 id="手写数组原型方法"><a href="#手写数组原型方法" class="headerlink" title="手写数组原型方法"></a>手写数组原型方法</h3><h4 id="unshift-方法"><a href="#unshift-方法" class="headerlink" title="unshift 方法"></a>unshift 方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myUnShift = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.splice(i, <span class="number">0</span>, <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组元素按照字节长度排序"><a href="#数组元素按照字节长度排序" class="headerlink" title="数组元素按照字节长度排序"></a>数组元素按照字节长度排序</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBytes</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = str.length;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'today'</span>, <span class="string">'今天'</span>, <span class="string">'ok'</span>, <span class="string">'haha'</span>, <span class="string">'you say 什么'</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getBytes(a) - getBytes(b);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//  ["ok", "今天", "haha", "today", "you say 什么"]</span></span><br></pre></td></tr></table></figure>

<h3 id="手写可以判断所有类型的-typeof-函数"><a href="#手写可以判断所有类型的-typeof-函数" class="headerlink" title="手写可以判断所有类型的 typeof 函数"></a>手写可以判断所有类型的 typeof 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTypeof</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> arg;</span><br><span class="line">  <span class="keyword">var</span> toStr = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">  <span class="keyword">if</span> (arg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'null'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> toStr.call(arg).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myTypeof([]); <span class="comment">// "Array"</span></span><br><span class="line">myTypeof(&#123;&#125;); <span class="comment">// "Object"</span></span><br><span class="line">myTypeof(<span class="number">123</span>); <span class="comment">// "number"</span></span><br><span class="line">myTypeof(<span class="string">'123'</span>); <span class="comment">// "string"</span></span><br><span class="line">myTypeof(<span class="literal">false</span>); <span class="comment">// "boolean"</span></span><br><span class="line">myTypeof(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)); <span class="comment">// "Number"</span></span><br><span class="line">myTypeof(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)); <span class="comment">// "String"</span></span><br><span class="line">myTypeof(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)); <span class="comment">// "Boolean"</span></span><br><span class="line">myTypeof(<span class="literal">null</span>); <span class="comment">// "null"</span></span><br><span class="line">myTypeof(<span class="literal">undefined</span>); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="keyword">this</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(item) === <span class="number">-1</span>) &#123;</span><br><span class="line">      newArr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="string">'a'</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(test.unique());</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, "a"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="keyword">this</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (!obj.hasOwnProperty(item)) &#123;</span><br><span class="line">      obj[item] = <span class="literal">true</span>;</span><br><span class="line">      newArr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="string">'a'</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(test.unique());</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, "a"]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newStr = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(<span class="keyword">this</span>[i])) <span class="keyword">continue</span>;</span><br><span class="line">    obj[<span class="keyword">this</span>[i]] = <span class="literal">true</span>;</span><br><span class="line">    newStr += <span class="keyword">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'122132312341nfskdjfhhhrbbfjsdhfuke'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.unique());</span><br><span class="line"><span class="comment">// 1234nfskdjhrbue</span></span><br></pre></td></tr></table></figure>

<h3 id="重复字符串中找出第一个不重复字符"><a href="#重复字符串中找出第一个不重复字符" class="headerlink" title="重复字符串中找出第一个不重复字符"></a>重复字符串中找出第一个不重复字符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = str.length;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> j;</span><br><span class="line">  <span class="keyword">var</span> flag;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> tmp1 = str[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp2 = str[j];</span><br><span class="line">      <span class="keyword">if</span> (tmp1 === tmp2) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag === <span class="literal">true</span>) <span class="keyword">return</span> str[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'12213a231234qqqqeuerhkrjbrkfmigrhiofjcrjef'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(find(str));</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p><code>arguments</code> 类型为 <code>object</code></p>
</li>
<li><pre><code class="js"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(a);
  <span class="built_in">console</span>.log(test);
  <span class="built_in">console</span>.log(test.name);
  <span class="built_in">console</span>.log(test === a);
}
a(); <span class="comment">// a is not defined</span>
test();
<span class="comment">// ƒ a() {</span>
<span class="comment">//   console.log(a);</span>
<span class="comment">//   console.log(test);</span>
<span class="comment">//   console.log(test.name);</span>
<span class="comment">//   console.log(test === a);</span>
<span class="comment">// }</span>
<span class="comment">// ƒ a() {</span>
<span class="comment">//   console.log(a);</span>
<span class="comment">//   console.log(test);</span>
<span class="comment">//   console.log(test.name);</span>
<span class="comment">//   console.log(test === a);</span>
<span class="comment">// }</span>
<span class="comment">// a</span>
<span class="comment">// true</span></code></pre>
</li>
</ul>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO-LIST"></a>TODO-LIST</h2><ul>
<li><input disabled type="checkbox"> 想尝试一下 <code>hugo</code> 作为博客。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>VueNote-4</title>
    <url>/2020/06/07/VueNote-4/</url>
    <content><![CDATA[<h1 id="Vue笔记-④"><a href="#Vue笔记-④" class="headerlink" title="Vue笔记 ④"></a>Vue笔记 ④</h1><h2 id="📃-正文"><a href="#📃-正文" class="headerlink" title="📃 正文"></a>📃 正文</h2><h3 id="①-Vue-单文件组件"><a href="#①-Vue-单文件组件" class="headerlink" title="① Vue 单文件组件"></a>① Vue 单文件组件</h3><h4 id="1-1-style-中的-scoped"><a href="#1-1-style-中的-scoped" class="headerlink" title="1.1 style 中的 scoped"></a>1.1 style 中的 scoped</h4><p>在 <code>Vue</code> 的单文件组件中，有 <code>template</code> , <code>script</code>, <code>style</code> 三种标签。其中的 <code>style</code> 有一个 <code>scoped</code> 属性。在文档中的解释为</p>
<blockquote>
<p>当 <code>style</code>  标签有 <code>scoped</code> 属性时，它的 <code>CSS</code> 只作用于当前组件中的元素。这类似于 <code>Shadow DOM</code> 中的样式封装。</p>
</blockquote>
<p>实际产生的效果为，当前页面的某些元素都会生成一个独特属性，而我们写的样式都会匹配这个独特的属性来保持不被其余组件影响。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span><span class="selector-attr">[data-v-f3f3eg9]</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span> <span class="attr">data-v-f3f3eg9</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但实际上，这个独特属性只会出现在当前页面的直接使用的标签上，也就是我们使用的组件的最外层父元素。那么想要根据转换规则，是无法匹配到这个组件的内部元素的。想要冲破这个规则而不取消 <code>scoped</code> 属性，就需要深度作用选择器。</p>
<p>原生中可以编写以下代码来使样式作用变深。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.a</span> &gt;&gt;&gt; <span class="selector-class">.b</span> &#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span><span class="selector-attr">[data-v-f3f3eg9]</span> <span class="selector-class">.b</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>那么就可以达到我们想要的效果，<code>css</code> 预处理器也许无法解析这种语法，可以用 <code>/deep/</code> 和 <code>::v-deep</code> 来代替。</p>
<h4 id="1-2-Node-API-服务器配置"><a href="#1-2-Node-API-服务器配置" class="headerlink" title="1.2  Node API 服务器配置"></a>1.2  Node API 服务器配置</h4><h5 id="1-2-1-想要偷懒的开始"><a href="#1-2-1-想要偷懒的开始" class="headerlink" title="1.2.1 想要偷懒的开始"></a>1.2.1 想要偷懒的开始</h5><p>写项目的时候，因为在本地跑的话，要开 <code>MySQL</code> 服务还要开后端一个服务，我觉得烦且占用资源。所以准备配置到我的小霸王机器上。</p>
<h5 id="1-2-2-面向搜索引擎的经过"><a href="#1-2-2-面向搜索引擎的经过" class="headerlink" title="1.2.2 面向搜索引擎的经过"></a>1.2.2 面向搜索引擎的经过</h5><p>因为原先在小霸王里装好了宝塔 <code>Linux</code> 面板，所以直接去搜索 <code>pm2</code> 管理器，但是我随手点击安装的其他软件都装好了， <code>pm2</code> 管理器还是跟没装似的。于是搜索了一番，打印出安装时的日志信息一看，发现无法连接到 <code>github</code> ，于是照着这个方法去搜索，又是更改 <code>github</code> 的 <code>ip</code> 地址，又是配置 <code>git</code> 的账号信息，又是设置代理。</p>
<p><strong>通通没有用</strong></p>
<p>于是又仔细查看了一下报错信息，发现显示 <code>443</code> 错误。我自己想了一下，可能是没有放行端口的原因，于是去控制台把出入的 <code>443</code> 端口都放了一下。验证出来是出行的端口的问题。</p>
<h5 id="1-2-3-安装好的结果"><a href="#1-2-3-安装好的结果" class="headerlink" title="1.2.3 安装好的结果"></a>1.2.3 安装好的结果</h5><p>安装好以后还是没有正常运行，因为新建的项目无法进行映射，也查不到什么有用的信息……</p>
<p>于是在可以连通 <code>github</code> 的情况下，我只好自己用 <code>npm</code> 下载了 <code>forever</code> 来运行，懒得下 <code>pm2</code> 再弄了。</p>
<h4 id="1-3-token-的使用"><a href="#1-3-token-的使用" class="headerlink" title="1.3  token 的使用"></a>1.3  token 的使用</h4><p><code>token</code> 这个东西，我也是经历了从完全弄不懂到目前大概知道作用的情况了，这一次学着写后台管理系统，也用到了 <code>token</code> 。大概写一下新了解到的东西。</p>
<h5 id="1-3-1-持久性-会话期间存储机制"><a href="#1-3-1-持久性-会话期间存储机制" class="headerlink" title="1.3.1 持久性/会话期间存储机制"></a>1.3.1 持久性/会话期间存储机制</h5><p>在获取 <code>token</code> 之后是需要临时保存住这个字符串来使用的，而我一开始想到的是存储在 <code>localstorage</code> 中，然后又想着，一直存在里头，每次打开不都直接登上了吗？</p>
<p>虽然之前写了点项目使用过 <code>token</code> ，但当时那个项目的登陆机制是乞丐版的，于是我也就没在意。</p>
<p>这次了解到 <code>token</code> 可以存储在 <code>sessionStorage</code> 中来进行会话期间的账户验证。可以保证这个 <code>token</code> 只在当前网站打开期间生效。</p>
<h4 id="1-4-非登陆状态的访问限制"><a href="#1-4-非登陆状态的访问限制" class="headerlink" title="1.4 非登陆状态的访问限制"></a>1.4 非登陆状态的访问限制</h4><p>一个非常常见的需求，即在非登陆状态下对非登陆页面的访问限制。可以使用路由导航守卫来控制访问权限。</p>
<p>在未登录的状态下，是没有 <code>token</code> 的，那么可以使用 <code>router.beforeEach</code> 来控制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to 代表将要访问的路径</span></span><br><span class="line">  <span class="comment">// from 代表从哪个路径而来</span></span><br><span class="line">  <span class="comment">// next 为一个函数为接下来跳转</span></span><br><span class="line">  <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) <span class="keyword">return</span> next();</span><br><span class="line">  <span class="keyword">const</span> token = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!token) <span class="keyword">return</span> next(<span class="string">'/login'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="1-5-vscode-语法格式化与-eslint-冲突问题"><a href="#1-5-vscode-语法格式化与-eslint-冲突问题" class="headerlink" title="1.5 vscode 语法格式化与 eslint 冲突问题"></a>1.5 vscode 语法格式化与 eslint 冲突问题</h4><p>在写代码的时候，<code>eslint</code> 有一些规则比较苛刻，例如字符串只能用单引号表示，不能有行尾空格，每个文件最后需要起一个新行。</p>
<p>那么在 <code>vscode</code> 的自动格式化与 <code>eslint</code> 产生冲突的时候需要对其中一方进行配置， <code>eslint</code> 的配置文件一般都会在项目创建时自动生成。这里提一下 <code>vscode</code> 的配置文件。</p>
<p>可以在项目根目录新建一个文件 <code>.prettierrc</code> 来进行配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//格式化时不会自动添加分号</span></span><br><span class="line">    <span class="string">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//格式化时生成单引号</span></span><br><span class="line">    <span class="string">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//单行所允许的字符长度 若超过则会自动换行</span></span><br><span class="line">    <span class="string">"printWidth"</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-路由跳转的参数注入"><a href="#1-6-路由跳转的参数注入" class="headerlink" title="1.6 路由跳转的参数注入"></a>1.6 路由跳转的参数注入</h4><p>在使用路由跳转到某个页面的时候，有时候需要在路径中放入一个 <code>id</code> 来获取指定的数据，此时可以在路由配置时，指定 <code>props</code> 为 <code>true</code> 来表明参数的注入，然后就可以在组件中使用 <code>props</code> 来接收这个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/categories/edit/:id'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/CategoryEdit.vue'</span>),</span><br><span class="line">  props: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'CategoryEdit'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>id</code> 就可以作为一个变量直接使用</p>
<h3 id="②-项目优化"><a href="#②-项目优化" class="headerlink" title="② 项目优化"></a>② 项目优化</h3><h4 id="2-1-项目优化策略"><a href="#2-1-项目优化策略" class="headerlink" title="2.1 项目优化策略"></a>2.1 项目优化策略</h4><h5 id="2-1-1-生成打包报告"><a href="#2-1-1-生成打包报告" class="headerlink" title="2.1.1 生成打包报告"></a>2.1.1 生成打包报告</h5><p>打包时，为了直观地发现项目中存在的问题，可以在打包时生成报告。生成报告的方式有两种：</p>
<h6 id="①-通过命令行参数的形式生成报告"><a href="#①-通过命令行参数的形式生成报告" class="headerlink" title="① 通过命令行参数的形式生成报告"></a>① 通过命令行参数的形式生成报告</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 vue-cli 的命令选项可以生成打包报告</span></span><br><span class="line"><span class="comment">// --report 选项可以生成 report.html 以帮助分析包内容</span></span><br><span class="line">vue-cli-service build --report</span><br></pre></td></tr></table></figure>

<h6 id="②-通过可视化的UI面板直接查看报告"><a href="#②-通过可视化的UI面板直接查看报告" class="headerlink" title="② 通过可视化的UI面板直接查看报告"></a>② 通过可视化的UI面板直接查看报告</h6><p>在可视化的UI面板中，通过<strong>控制台</strong>和<strong>分析</strong>面板，可以方便地看到项目中存在的问题。</p>
<h5 id="2-1-2-为开发模式与发布模式指定不同的打包入口"><a href="#2-1-2-为开发模式与发布模式指定不同的打包入口" class="headerlink" title="2.1.2 为开发模式与发布模式指定不同的打包入口"></a>2.1.2 为开发模式与发布模式指定不同的打包入口</h5><p>默认情况下，Vue 项目的开发模式与发布模式，公用同一个打包的入口文件 (src/main.js)。为了将项目的开发过程与发布过程分离，我们可以为两种模式各自指定打包的入口文件，即：</p>
<p>① 开发模式的入口文件为 src/main-dev.js</p>
<p>② 发布模式的入口文件为 src/main-prod.js</p>
<p>在 <code>vue.config.js</code> 导出的配置对象中，新增 <code>configureWebpack</code> 或 <code>chainWebpack</code> 节点， 来自定义 <code>webpack</code> 的打包配置。</p>
<p>在这里， <code>configureWebpack</code> 和 <code>chainWebpack</code> 的作用相同，唯一的区别就是它们修改 <code>webpack</code> 配置的方式不同：</p>
<p>① <code>chainWebpack</code> 通过链式编程的形式，来修改默认的 <code>webpack</code> 配置。</p>
<p>② <code>configureWebpack</code> 通过操作对象的形式，来修改默认的 <code>webpack</code> 配置。</p>
<h5 id="2-1-2-第三方库启用CDN"><a href="#2-1-2-第三方库启用CDN" class="headerlink" title="2.1.2 第三方库启用CDN"></a>2.1.2 第三方库启用CDN</h5><p>默认情况下，通过 import 语法导入的第三方依赖包，最终会被打包到同一个文件中，从而导致打包成功后，单文件体积过大的问题。</p>
<p>为了解决上述问题，可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。凡是声明在 externals 中的第三方依赖包，都不会被打包。</p>
<h5 id="2-1-3-Element-UI-组件按需加载"><a href="#2-1-3-Element-UI-组件按需加载" class="headerlink" title="2.1.3 Element-UI 组件按需加载"></a>2.1.3 Element-UI 组件按需加载</h5><p>注释掉 <code>element-UI</code> 的按需引入插件的导入，引入 <code>cdn</code> 链接导入 <code>js</code> 和 <code>css</code> 即可。</p>
<h5 id="2-1-4-路由懒加载"><a href="#2-1-4-路由懒加载" class="headerlink" title="2.1.4 路由懒加载"></a>2.1.4 路由懒加载</h5><p>路由懒加载即为在路由指定组件的时候用函数的形式来引入组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/login'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/Login.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是想要将部分组件打包在一起可以这样指定:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/login'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span><span class="string">'@/components/Login.vue'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/test'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span><span class="string">'@/components/test.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-1-5-首页内容定制"><a href="#2-1-5-首页内容定制" class="headerlink" title="2.1.5 首页内容定制"></a>2.1.5 首页内容定制</h5><p>在 <code>vue.config.js</code> 中给 <code>html</code> 插件写入一个属性来控制 <code>index.html</code> 的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产模式</span></span><br><span class="line">config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  args[<span class="number">0</span>].isProd = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.isProd</span> ? '' <span class="attr">:</span> '<span class="attr">dev</span> <span class="attr">-</span> ' %&gt;</span>电商后台管理系统 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">htmlWebpackPlugin.options.isProd</span>) &#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>vue-cli</code> 中配置 <code>webpack</code> 配置项<a href="https://cli.vuejs.org/zh/config/#vue-config-js" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VueNote-3</title>
    <url>/2019/12/14/VueNote-3/</url>
    <content><![CDATA[<h1 id="Vue笔记-③"><a href="#Vue笔记-③" class="headerlink" title="Vue笔记 ③"></a>Vue笔记 ③</h1><h2 id="📃-正文"><a href="#📃-正文" class="headerlink" title="📃 正文"></a>📃 正文</h2><h3 id="①-Vuex-对象"><a href="#①-Vuex-对象" class="headerlink" title="① Vuex 对象"></a>① <code>Vuex</code> 对象</h3><h4 id="1-1-vuex-中的-state"><a href="#1-1-vuex-中的-state" class="headerlink" title="1.1 vuex 中的 state"></a>1.1 vuex 中的 state</h4><p>创建 <code>vuex</code> 实例对象时，传入一个包含 <code>state</code> 属性的对象，表示该 <code>store</code> 对象包含的全局状态，可以理解为全局属性，即其余组件都可以访问的共享数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  data: something</span><br><span class="line">&#125;</span><br><span class="line">&#123;&#123;$store.state.data&#125;&#125;</span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h4 id="1-2-vuex-中的-mutations"><a href="#1-2-vuex-中的-mutations" class="headerlink" title="1.2  vuex 中的 mutations"></a>1.2  vuex 中的 mutations</h4><p>该属性的值为一个包含许多函数的对象，可以近似看作 <code>methods</code> ，但是这里更严谨一些，官方希望我们将对 <code>state</code> 中的值的修改都通过 <code>mutations</code> 来实现，这样可以通过官方的浏览器插件 <code>devtools</code> 来进行追踪。</p>
<p>所有 <code>mutations</code> 的方法都有一个固定的形参，即 <code>state</code> ，可以通过它来直接调用 <code>state</code> 中的数据。</p>
<p>在组件中对于 <code>mutations</code> 的调用需要通过 <code>this.$store.commit</code> 来实现，该方法的参数为字符串和可选的传入参数。</p>
<p>传参时存在两种提交风格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种提交风格</span></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  anotherExample(n)&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'example'</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mutations 定义</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  example(state, extra)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(extra) <span class="comment">// n</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种提交风格</span></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  anotherExample(n)&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">      type: <span class="string">'example'</span>,</span><br><span class="line">      extra: n</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mutations 定义</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  example(state, payload)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(payload) <span class="comment">// &#123;type: "increment", extra: n&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-vuex-中的-actions"><a href="#1-3-vuex-中的-actions" class="headerlink" title="1.3 vuex 中的 actions"></a>1.3 vuex 中的 actions</h4><p><code>actions</code> 可以看作一个中转，当我们需要执行一些异步方法时，直接在 <code>mutations</code> 中实现的话，会导致 <code>devtools</code> 追踪出错，数据无法实时更新。而往往页面的更改已经完成，会导致混乱。那么，我们对异步方法的执行就可以写在 <code>actions</code> 中，异步完成时再调用 <code>mutations</code> 来完成对数据的更改。</p>
<p><code>actions</code> 中的方法的形参为 <code>context</code> ， 代表该 <code>store</code> 实例。</p>
<p>在组件中对于 <code>actions</code> 的调用使用 <code>this.$store.dispatch</code> 来实现，参数与 <code>commit</code> 类似。</p>
<h4 id="1-4-一个异步方法实例"><a href="#1-4-一个异步方法实例" class="headerlink" title="1.4 一个异步方法实例"></a>1.4 一个异步方法实例</h4><p>首先在组件中的 <code>methods</code> 定义一个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$store</span><br><span class="line">  .dispatch(<span class="string">'UpdatedInfo'</span>,<span class="string">'i am payload'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>store</code> 实例的 <code>actions</code> 中定义一个 <code>UpdatedInfo</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">UpdatedInfo(context, payload)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'changeName'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(payload);</span><br><span class="line">      resovle(<span class="string">'updated'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>setTimeout</code> 模拟异步操作。该方法返回一个 <code>promise</code> ，当异步操作执行时，实现 <code>resolve</code> 并将需要的值传递出去。</p>
<p>那么在组件中就可以使用 <code>.then</code> 来实现异步操作完成的反馈。</p>
<p><img src="/2019/12/14/VueNote-3/1-1.png" alt="1-1"></p>
<p>从此图中可以看到，异步操作和完成的反馈确实是在两个不同文件中实现的。</p>
<h4 id="1-5-vuex-中的-getters"><a href="#1-5-vuex-中的-getters" class="headerlink" title="1.5 vuex 中的 getters"></a>1.5 vuex 中的 getters</h4><p><code>getters</code> 类似于 <code>computed</code> ，不多描述。参数固定为 <code>state</code> ，第二个参数可以是 <code>getters</code> 来获取全部 <code>getters</code> 以此调用其余的 <code>getter</code> 。</p>
<p>想要实现在 <code>getters</code> 中传入额外参数的话可以如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  example(state)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> something;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如下调用</span></span><br><span class="line">&#123;&#123;$store.getters.example(arg)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-vuex-中的-modules"><a href="#1-6-vuex-中的-modules" class="headerlink" title="1.6 vuex 中的 modules"></a>1.6 vuex 中的 modules</h4><p><code>vuex</code> 实例对象可以分模块管理， <code>modules</code> 的值为一个对象，每个键对应的值为一个类 <code>store</code> 对象，包含 <code>state</code> <code>mutations</code> <code>getters</code> <code>actions</code> 等属性，组件中获取模块内部的 <code>state</code> 直接在根 <code>state</code> 中根据模块名来获取值，内部原理是将模块直接挂到根 <code>state</code> 上，并且内部的 <code>mutations</code> <code>getters</code> 一类都是直接挂载 <code>store</code> 对象上，调用方法没有变化， <code>getters</code> 可以使用第三个参数即根 <code>state</code> 。</p>
<p><code>actions</code> 中的 <code>context</code> 值的作用域为自己，即在 <code>actions</code> 中调用 <code>context</code> 中的 <code>mutations</code> 只会调用自身内部的 <code>mutations</code> 。</p>
<p><img src="/2019/12/14/VueNote-3/1-2.png" alt="1-2"></p>
<p>该图为打印出的 <code>context</code> 值。</p>
<h4 id="1-7-官方推荐的-mutations-常量写法"><a href="#1-7-官方推荐的-mutations-常量写法" class="headerlink" title="1.7 官方推荐的 mutations 常量写法"></a>1.7 官方推荐的 mutations 常量写法</h4><p>由于在 <code>commit</code> <code>mutations</code> 时，传入的参数为字符串，没有提示，有可能出现错误。于是官方推荐了使用常量表示 <code>mutations</code> 函数名的方法。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="comment">// 或写于外部 js 文件中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line">mutations: &#123;</span><br><span class="line">  [INCREMENT](state)&#123;</span><br><span class="line">    <span class="comment">// some code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-8-vuex-的-actions-等映射"><a href="#1-8-vuex-的-actions-等映射" class="headerlink" title="1.8 vuex 的 actions 等映射"></a>1.8 vuex 的 actions 等映射</h4><p>在 <code>vuex</code> 中， 若是因为频繁调用 <code>this.$store.getters.xxxx</code> 或是 <code>dispatch</code> 等方法，可以通过 <code>MapGetters</code> 和 <code>MapActions</code> 等将 <code>store</code> 对象上的方法映射到当前组件内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([<span class="string">'addCart'</span>]),</span><br><span class="line">  aMethod()&#123;</span><br><span class="line">    <span class="keyword">this</span>.addCart(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">'cartList'</span>]),</span><br><span class="line">  aComputed()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cartList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="②-axios"><a href="#②-axios" class="headerlink" title="② axios"></a>② axios</h3><h4 id="2-1-封装第三方框架的必要性"><a href="#2-1-封装第三方框架的必要性" class="headerlink" title="2.1 封装第三方框架的必要性"></a>2.1 封装第三方框架的必要性</h4><p>在一个项目中，不应该对一个第三方框架过分依赖。例如 <code>axios</code> ，不应该在每个组件中单独引入并在 <code>methods</code> 中写入调用方法。如果框架出了问题，就会引发很多麻烦。<del>话说 <code>vue</code> 出了问题会咋样 😂</del></p>
<p>因此，可以考虑自己封装一下第三方框架的使用，然后在组件中使用自己封装的文件。</p>
<h4 id="2-2-axios-封装"><a href="#2-2-axios-封装" class="headerlink" title="2.2 axios 封装"></a>2.2 axios 封装</h4><p>在 <code>src</code> 中新建一个 <code>network</code> 文件夹作为封装模块的目录。</p>
<p><img src="/2019/12/14/VueNote-3/2-1.png" alt="2-1"></p>
<p>在 <code>request.js</code> 中引入 <code>axios</code> 然后导出自己写的包装函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'...'</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instance(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    failure(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个 <code>axios</code> 实例，除了规定请求的基本 <code>config</code> ，还要求了请求成功和失败的回调函数，来实现在组件内的相应回调操作。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'@/network/request'</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'category'</span>,</span><br><span class="line">&#125;,(res)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或是直接在 <code>config</code> 中写入回调函数。</p>
<p>理解后，改用 <code>Promise</code> 来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="string">'http://106.54.54.237:8000/api/v1'</span>,</span><br><span class="line">      timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    instance(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件内部代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'@/network/request'</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'category'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然而实际上，<code>instance</code> 的返回值就是一个 <code>Promise</code> ，直接返回 <code>instance</code> 的返回值就可以。</p>
<h4 id="2-3-axios-拦截器"><a href="#2-3-axios-拦截器" class="headerlink" title="2.3 axios 拦截器"></a>2.3 axios 拦截器</h4><p>拦截器分为请求拦截和响应拦截。</p>
<ul>
<li><p>请求拦截</p>
<p>请求拦截中分为配置拦截和错误拦截，分别对应该方法的第一个参数和第二个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(config);</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>instance</code> 对应于前文。<br>第一个参数函数中的参数为 <code>config</code> ，并且在拦截操作完成后必须将 <code>config</code> 返回，否则无法完成请求。</p>
<p><img src="/2019/12/14/VueNote-3/2-2.png" alt="2-2"></p>
<p>常用于修改不符合服务器要求的信息，加入请求过渡动画，检查用户是否符合要求。</p>
</li>
<li><p>响应拦截</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res.data;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>类似于请求拦截，一个响应成功拦截，一个响应失败拦截。</p>
<p>响应成功拦截也需要将结果再次返回。</p>
</li>
</ul>
<h3 id="③-webpack-别名配置"><a href="#③-webpack-别名配置" class="headerlink" title="③ webpack 别名配置"></a>③ webpack 别名配置</h3><h4 id="3-1-alias-配置无法生效问题"><a href="#3-1-alias-配置无法生效问题" class="headerlink" title="3.1 alias 配置无法生效问题"></a>3.1 alias 配置无法生效问题</h4><p>在试图给项目路径配置别名时，发现无论怎样改都会报错提示找不到组件。</p>
<p>上网查了一下后发现，应该是在执行 <code>npm run dev</code> 时，<code>webpack.base.conf.js</code> 文件中的配置只会在指令执行时生效，后续修改的话需要再次执行命令来生效。</p>
<h4 id="3-2-alias-使用注意点"><a href="#3-2-alias-使用注意点" class="headerlink" title="3.2 alias 使用注意点"></a>3.2 alias 使用注意点</h4><p>在 <code>script</code> 标签中使用 <code>import</code> 导入时可以直接使用别名，在 <code>template</code> 标签中对 <code>img</code> 之类的 <code>src</code> 路径需要在开始处添加 <code>~</code> 符号指示 <code>html</code> 标签中的别名使用。</p>
<h3 id="④-Error-in-render-问题记录"><a href="#④-Error-in-render-问题记录" class="headerlink" title="④ Error in render 问题记录"></a>④ Error in render 问题记录</h3><h4 id="4-1-问题描述"><a href="#4-1-问题描述" class="headerlink" title="4.1 问题描述"></a>4.1 问题描述</h4><p>在写 <code>Python</code> 比赛题目试图混学分时，写数据可视化收尾环节出现了非常多问题。浏览器控制台不停地报错，显示为</p>
<p><img src="/2019/12/14/VueNote-3/20190209195753429.png" alt="img"></p>
<p>找不到问题出处，查了一番发现有人提到 <code>error in render</code> 表示在渲染部分出了问题，应该去找模板的问题。排查一番确实是模块处的循环部分出了问题。</p>
<h3 id="⑤-Vue-项目部署问题记录"><a href="#⑤-Vue-项目部署问题记录" class="headerlink" title="⑤ Vue 项目部署问题记录"></a>⑤ Vue 项目部署问题记录</h3><h4 id="5-1-打包后路径问题"><a href="#5-1-打包后路径问题" class="headerlink" title="5.1 打包后路径问题"></a>5.1 打包后路径问题</h4><p>同样是那个 <code>Python</code> 比赛，写完前端部分后打包想做一个预览，把资源都放到服务器网站根目录发现并没有问题。</p>
<p><img src="/2019/12/14/VueNote-3/image-20200508094542121.png" alt="image-20200508094542121"></p>
<p><img src="/2019/12/14/VueNote-3/image-20200508094605218.png" alt="image-20200508094605218"></p>
<p><img src="/2019/12/14/VueNote-3/image-20200508094618992.png" alt="image-20200508094618992"></p>
<p>而在 <code>github pages</code> 部署以及本地打开打包后文件都会出现静态资源访问不到的情况。</p>
<p>本地静态资源正确路径👇</p>
<p><img src="/2019/12/14/VueNote-3/image-20200508094721461.png" alt="image-20200508094721461"></p>
<p>本地静态资源错误路径👇</p>
<p><img src="/2019/12/14/VueNote-3/image-20200508094753038.png" alt="image-20200508094753038"></p>
<p><code>github pages</code> 访问问题也差不多。</p>
<p>一开始的问题是 <code>js</code> 和 <code>css</code> 文件也无法访问，因为使用的都是绝对路径。在项目访问时存在子目录就会出现问题。</p>
<p>在 <code>Vue</code> 项目内配置 <code>vue.config.js</code> 文件时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'./'</span>:<span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当环境为生产环境时，使用相对路径。但这样操作后依然只有 <code>js</code> <code>css</code> 文件生效，我放在 <code>public</code> 文件下的 <code>data</code> 文件依然无法访问到。</p>
<p>仔细观察两处文件引用的方法，发现在引用 <code>css</code> 时使用的是相对路径，引用 <code>json</code> 文件时用的是绝对路径且是根目录起。</p>
<p>因为了解到 <code>vue</code> 项目最后打包的文件是在 <code>public</code> 目录运行的，即使是本地运行时也是，那么就尝试把绝对路径修改为相对路径。</p>
<p>修改完后观察请求路径，已经没有问题，但是依然无法请求成功。看了一下控制台报错消息，可以发现是因为跨域问题。</p>
<p>本地文件访问没有办法解决，尝试放到 <code>github pages</code> 来试验以及在服务器进行子目录的试验。</p>
<h4 id="5-2-减少打包后-chunk-js-文件的大小"><a href="#5-2-减少打包后-chunk-js-文件的大小" class="headerlink" title="5.2 减少打包后 chunk.js 文件的大小"></a>5.2 减少打包后 chunk.js 文件的大小</h4><p>当我尝试打开 <code>github pages</code> 上的项目时，发现速度慢的离谱。</p>
<p>除去访问 <code>github</code> 本身带来的慢速以外，我检查了一下 <code>network</code> 发现有一个 <code>js</code> 文件请求了一分钟还没有请求完，在资源管理器里查看了一下这个文件的大小，足足有 1000 多 <code>k</code> ，于是我开始尝试减少这部分的大小。</p>
<p>大概原因是打包的模块太多太大，但我的这个项目依赖的模块并不多，应当是某个模块太大。我随便翻了一下 <code>chunk</code> 这个文件，就会发现许多与 <code>echarts</code> 相关的内容。于是准备减轻这个模块引起的负担。</p>
<p>首先，在 <code>index.html</code> 中引用需要的模块 <code>cdn</code> 链接。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/echarts/4.7.0/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 <code>vue.config.js</code> 中进行配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  configureWebpack: &#123;    </span><br><span class="line">    externals: &#123;</span><br><span class="line">      <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">      <span class="string">'echarts'</span>: <span class="string">'echarts'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上这个部分应该怎么写我都不是很清楚，但这样子就可以成功了。</p>
<p>然后再 <code>push</code> 到 <code>github</code> 上，打开 <code>github pages</code> 就会发现可以大大提速。</p>
<p>且前面的路径问题也已经解决。</p>
<p>观察了一下请求列表，发现可优化的点。</p>
<ul>
<li>多次请求 <code>data.json</code> 文件，可以把请求一次化，将数据放在 <code>vuex</code> 中。</li>
<li>其余模块也可能带来影响。</li>
<li>背景图片的请求时间较长，可以考虑压缩图片。</li>
</ul>
<h4 id="5-3-单页面应用在子目录路由跳转的问题"><a href="#5-3-单页面应用在子目录路由跳转的问题" class="headerlink" title="5.3 单页面应用在子目录路由跳转的问题"></a>5.3 单页面应用在子目录路由跳转的问题</h4><p>写另一个单页面应用的时候发现了问题，通过上面的经验，已经在项目配置文件中写好了基本路径为相对路径。</p>
<p>但在我把项目放进服务器根网站的子目录 <code>/ask</code> 时出现了路由跳转的问题。</p>
<p><code>Vue</code> 提供的只是前端路由，无法直接用来获取资源，我们的项目根路径还是 <code>&#39;/&#39;</code> ，但访问 <code>ip/ask</code> 时无法正确的跳转路由。</p>
<p>原先的设定是访问 <code>&#39;/&#39;</code> 时重定向到 <code>/question</code> ，但此时我们访问的其实是 <code>/ask</code> ，查询了一下发现 <code>vue-router</code> 可以设置一个 <code>base</code> 路径，将路由跳转加上一个基础 <code>/ask</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes,</span><br><span class="line">  base: <span class="string">'/ask'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么再次打包部署到服务器，就可以正常访问了。</p>
<p>访问 <code>ip/ask</code> 时可以正确的重定向到 <code>ip/ask/question</code> ，并且其他部分的跳转也没有问题。</p>
<h4 id="5-4-多页面应用问题"><a href="#5-4-多页面应用问题" class="headerlink" title="5.4 多页面应用问题"></a>5.4 多页面应用问题</h4><p>接触到一个多页面应用项目，很懵逼。把配置文件捋了一遍后，发现使用了 <code>glob</code> 模块，实际上，这个项目的运行路径下就是存在多个页面，想要去哪个页面，直接打开这个 <code>html</code> 页面即可。</p>
<h4 id="5-5-父子组件传值问题"><a href="#5-5-父子组件传值问题" class="headerlink" title="5.5 父子组件传值问题"></a>5.5 父子组件传值问题</h4><p>在写项目的过程中，有两个组件内的内容高度重复，于是准备抽出来写一个组件。</p>
<p>父组件传值给子组件，而在我写的子组件中，传值是需要被修改的。而这个行为官方是不推荐的，那么就在 <code>data</code> 域中新建两个变量，但是总是出现无法正确赋值的情况。</p>
<p>后得知是因为 <code>data</code> 域只会初始化一次，那么我们需要使用 <code>watch</code> 来监听 <code>props</code> 内需要的参数，然后去赋值给 <code>data</code> 域。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VueNote-2</title>
    <url>/2019/12/12/VueNote-2/</url>
    <content><![CDATA[<h1 id="Vue-笔记-②"><a href="#Vue-笔记-②" class="headerlink" title="Vue 笔记 ②"></a>Vue 笔记 ②</h1><h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="①父子组件传值"><a href="#①父子组件传值" class="headerlink" title="①父子组件传值"></a>①父子组件传值</h3><h4 id="1-1-子组件访问问题"><a href="#1-1-子组件访问问题" class="headerlink" title="1.1 子组件访问问题"></a>1.1 子组件访问问题</h4><p>在 <code>vue</code> 中，子组件访问父组件的值是需要经过特定的操作的。<br>我很好奇，为什么不能够直接访问，按理说，嵌套关系是应该可以访问到父作用域的值的。</p>
<a id="more"></a>

<p>我做了一点尝试。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cmp</span>&gt;</span><span class="tag">&lt;/<span class="name">cmp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cmp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>efg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">Vue.component(<span class="string">'cmp'</span>,&#123;</span></span><br><span class="line"><span class="actionscript">  template: <span class="string">'#cmp'</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#app'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="actionscript">    msg: <span class="string">'abc'</span>,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/12/VueNote-2/1-1.png" alt="1-1"><br>此时直接报错。错误信息显示，无法寻找到 <code>msg</code> 属性或方法，也就是说，在一个组件中使用一个 <code>data</code> 中的数据时，会默认寻找自身内部的 <code>data</code>。<br>可以理解成，使用数据时，会默认寻找 <code>this.msg</code> 。如果想要访问父组件中的数据时，需要能够找到父组件实例的引用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handle"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cmp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> @<span class="attr">click</span>=<span class="string">"handle"</span>&gt;</span>abcd<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>efg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      msg: <span class="string">'abc'</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handle()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(vm.msg);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以直接指定对应的 <code>vue</code> 实例来调用 <code>msg</code>数据。但这样的话，太过于死板且没有特别大意义。</li>
<li>可以通过实例对象的 <code>$children</code> <code>$parent</code> 属性来获取父子组件。</li>
</ul>
<h4 id="1-2-props-中的-default-问题"><a href="#1-2-props-中的-default-问题" class="headerlink" title="1.2 props 中的 default 问题"></a>1.2 <code>props</code> 中的 <code>default</code> 问题</h4><p>在使用 <code>props</code> 传递数据的时候，可以设置数据的 <code>default</code> 属性，在某些版本上， <code>default</code> 为空数组或空对象时会报错，需要使用工厂函数返回空数组和对象。<br>搜了一下，找不到原理解释，其实不太理解为什么。</p>
<h4 id="1-3-父子组件相互传值案例"><a href="#1-3-父子组件相互传值案例" class="headerlink" title="1.3 父子组件相互传值案例"></a>1.3 父子组件相互传值案例</h4><p>这里有一个比较复杂的案例，看的时候觉得挺简单挺容易捋清楚的，自己手动写一下又懵了好久。</p>
<ul>
<li>实现子组件获取父组件的值，使用属性绑定加 <code>props</code> 获取。</li>
<li>实现子组件内部 <code>input</code> 元素和数据双向绑定</li>
<li>实现子组件内部数据更改影响父组件数据，使用 <code>this.$emit</code> 实现。</li>
<li>实现数据一的更改影响到数据二</li>
<li>实现数据二的更改影响到数据一<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cmp</span> <span class="attr">:cnum1</span>=<span class="string">"num1"</span> <span class="attr">:cnum2</span>=<span class="string">"num2"</span> @<span class="attr">num1change</span>=<span class="string">"num1change"</span> @<span class="attr">num2change</span>=<span class="string">"num2change"</span>&gt;</span><span class="tag">&lt;/<span class="name">cmp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cmp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      props: &#123;&#123; cnum1 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      data: &#123;&#123; dnum1 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"dnum1"</span> @<span class="attr">input</span>=<span class="string">"num1input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      props: &#123;&#123; cnum2 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      data: &#123;&#123; dnum2 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"dnum2"</span> @<span class="attr">input</span>=<span class="string">"num2input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = &#123;<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#app'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    num1: 1,</span><br><span class="line">    num2: 100,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    num1change(value)&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.num1 = value;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    num2change(value)&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.num2 = value;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cmp: &#123;</span><br><span class="line"><span class="actionscript">      template: <span class="string">'#cmp'</span>,</span></span><br><span class="line"><span class="actionscript">      props: [<span class="string">'cnum1'</span>, <span class="string">'cnum2'</span>],</span></span><br><span class="line">      data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">          dnum1: <span class="keyword">this</span>.cnum1,</span></span><br><span class="line"><span class="actionscript">          dnum2: <span class="keyword">this</span>.cnum2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        num1input(event)&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.dnum1 = event.target.value;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.dnum2 = <span class="keyword">this</span>.dnum1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'num1change'</span>,<span class="keyword">this</span>.dnum1);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'num2change'</span>,<span class="keyword">this</span>.dnum2);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        num2input(event)&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.dnum2 = event.target.value;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.dnum1 = <span class="keyword">this</span>.dnum2 / <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'num2change'</span>,<span class="keyword">this</span>.dnum2);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$emit(<span class="string">'num1change'</span>,<span class="keyword">this</span>.dnum1);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="②-vue-router-学习"><a href="#②-vue-router-学习" class="headerlink" title="② vue-router 学习"></a>② <code>vue-router</code> 学习</h3><h4 id="2-1-路由跳转问题"><a href="#2-1-路由跳转问题" class="headerlink" title="2.1 路由跳转问题"></a>2.1 路由跳转问题</h4><ul>
<li><p>配置 <code>vue-router</code> 的 <code>index.js</code> 文件中的 <code>vue-router</code> 实例对象时，除去 <code>routes</code> 数组外，还可以设置属性 <code>mode=history</code> 即可将浏览时 <code>url</code> 中的 <code>#</code> 去除。</p>
</li>
<li><p>在页面的组件跳转中， <code>router-link</code> 元素可以使用某些属性来配置，比如 <code>tag</code> 属性来设置最终渲染为什么元素， <code>replace</code> 属性设置该路由跳转方式为 <code>history.replaceState</code> ，代表不可通过浏览器的后退和前进来修改。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以使用代码替换 <code>router-link</code> 跳转，使用 <code>this.$router.push</code> 或是 <code>this.$router.replace</code> 来实现路由跳转。</p>
<blockquote>
<p>注意，不要跳过 <code>vue-router</code> 自己使用 <code>history</code> 一类的方法来实现路由跳转。</p>
</blockquote>
</li>
<li><p>可以在 <code>router-link</code> 标签上设置 <code>active-class</code> 属性替换 <code>active</code> 路由的类名，也可以在 <code>vue-router</code> 实例对象中设置 <code>linkActiveClass</code> 实现全局替换。</p>
</li>
</ul>
<h4 id="2-2-路由懒加载"><a href="#2-2-路由懒加载" class="headerlink" title="2.2 路由懒加载"></a>2.2 路由懒加载</h4><ul>
<li>想要使用路由懒加载，在 <code>vue-router</code> 实例对象中配置 <code>routes</code> 时，设置 <code>component</code> 时使用函数作为值，函数内部导入组件。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/Home'</span>)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/About'</span>)</span><br><span class="line"><span class="keyword">const</span> User = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/User'</span>)</span><br></pre></td></tr></table></figure>

<p>​    然后使用对应的变量名为 <code>component</code> 的值。那么，打包后的 <code>js</code> 文件就会分成多份。</p>
<h4 id="2-3-router-push-等方法报错问题"><a href="#2-3-router-push-等方法报错问题" class="headerlink" title="2.3 $router.push 等方法报错问题"></a>2.3 <code>$router.push</code> 等方法报错问题</h4><p>学习的时候，尝试了路由跳转使用代码实现，结果在重复点击同一个路由指向元素的时候，控制台疯狂报错。</p>
<p><img src="/2019/12/12/VueNote-2/1-3.png" alt="1-3"></p>
<p>搜了很久很久解决方法，大致是低版本 <code>vue-router</code> 的一个 <code>bug</code> ，但我看了一下配置文件，说是我的这个版本已经修复了 <code>bug</code> 呀？我倒是没看出来哪里修复了… 删除重装 <code>node_modules</code> 也不顶用，还有个在 <code>router</code> 的 <code>index.js</code> 写一段代码的方法，我试了一把没用。(其实是有用的，只是我漏写了个方法)</p>
<p>翻了一下官方文档，写的 <code>emmmmmm</code> </p>
<p>然后又去翻 <code>github</code> 上的 <code>issues</code> ，确实有类似的问题，但是阅读能力实在捉急，只是看了个大概，有个补写捕获错误代码的我没看懂补写在哪儿，还有个在 <code>$router.push</code> 方法多写一个空的箭头函数作为参数的方法，确实解决了，但是不太懂为什么。估计我得去看看这几个函数的源码才能知道了。</p>
<p>最后又是一顿疯狂搜索，还是之前看到的旧方法，就在这个时候我突然顿悟。我的路由跳转选择的是 <code>replace</code> 方法而不是 <code>push</code>  。前文提到的那个在 <code>index.js</code> 加代码的操作对我的组件根本不生效，因为我压根没配置 <code>replace</code> 方法 😂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">const</span> routerPush = Router.prototype.push;</span><br><span class="line"><span class="keyword">const</span> routerReplace = Router.prototype.replace;</span><br><span class="line">Router.prototype.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> routerPush.call(<span class="keyword">this</span>, location).catch(<span class="function"><span class="params">error</span> =&gt;</span> error)</span><br><span class="line">&#125;</span><br><span class="line">Router.prototype.replace = <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> routerReplace.call(<span class="keyword">this</span>, location).catch(<span class="function"><span class="params">error</span> =&gt;</span> error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概就是改写了原型链上的 <code>push</code> 方法和 <code>replace</code> 方法，一个是绑定了 <code>this</code> ，还有一个是捕获了错误。</p>
<p>问题解决。</p>
<blockquote>
<p>日后再来细致研究这个办法。</p>
</blockquote>
<h4 id="2-4-keep-alive-与一次创建"><a href="#2-4-keep-alive-与一次创建" class="headerlink" title="2.4 keep-alive 与一次创建"></a>2.4 <code>keep-alive</code> 与一次创建</h4><p>在一般情况下，一个子组件在被路由跳转进入和离开的时候，会被重复创建和销毁，可以通过 <code>created</code> 和 <code>destroyed</code> 钩子函数进行验证。</p>
<p>如果想要使一个组件被保持，可以使用 <code>keep-alive</code> 标签包裹 <code>router-view</code> 来实现仅一次创建。</p>
<p>同时，使用了 <code>keep-alive</code> 标签后，被包裹的子组件就可以调用 <code>activated</code> 和 <code>deactivated</code> 钩子函数来表示当前路由是否活跃。</p>
<p>若是想要排除某个子组件，想要其重复创建和销毁，可以设置 <code>keep-alive</code> 标签的属性 <code>exclude</code> 为该子组件的 <code>name</code> 属性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VueNote-1</title>
    <url>/2019/12/09/VueNote-1/</url>
    <content><![CDATA[<h1 id="Vue-笔记-①"><a href="#Vue-笔记-①" class="headerlink" title="Vue 笔记 ①"></a>Vue 笔记 ①</h1><h3 id="🤪碎碎念"><a href="#🤪碎碎念" class="headerlink" title="🤪碎碎念"></a>🤪碎碎念</h3><blockquote>
<p>说好假期再看 <code>vue</code> 的，结果还是没忍住哈…</p>
</blockquote>
<a id="more"></a>

<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="①-实现点击元素变色效果"><a href="#①-实现点击元素变色效果" class="headerlink" title="① 实现点击元素变色效果"></a>① 实现点击元素变色效果</h3><p><img src="/2019/12/09/VueNote-1/20191209_220854.gif" alt="点击变色演示"></p>
<p>一开始的要求就是使用 <code>data</code> 的数组来做数据然后渲染列表并实现点击某个元素时，某个元素变色。</p>
<p>仔细思考一下，将过程拆分开。</p>
<ol>
<li>首先是使用 <code>v-for</code> 指令循环生成元素。</li>
<li>然后考虑给每个元素绑定 <code>click</code> 事件。</li>
<li>点击时给当前点击元素添加指定类名同时移除其他所有元素的类名。</li>
</ol>
<p>然后就开始蒙圈了，应该怎么给数组数据和类名动态对应呢？<br>纠结了半天，用了对象的方法。<br><img src="/2019/12/09/VueNote-1/pic2.png" alt="对象数据解决"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.red</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(value,key, index) in list"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"value?'red':''"</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"handle(key)"</span>&gt;</span>&#123;&#123; key &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list:&#123;</span><br><span class="line"><span class="actionscript">        <span class="string">'aaaaaaaaaa'</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'bbbbbbbbbbbb'</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'cccccccccccccc'</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'dddddddddddddddd'</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'eeeeeeeeeeeeeeeeee'</span>:<span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handle(index)&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> list = <span class="keyword">this</span>.list;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> list)&#123;</span></span><br><span class="line"><span class="actionscript">          list[i]=<span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        list[index]=<span class="literal">true</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后兜兜转转半天看到别人的解决方法，瞬间感觉自己是个 <code>**</code> 。<br><img src="/2019/12/09/VueNote-1/pic1.png" alt="数组解决方法"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.red</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"&#123;'red':currentIndex==index&#125;"</span> </span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"handle(index)"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list:[</span><br><span class="line"><span class="actionscript">        <span class="string">'aaaaaaaaaa'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'bbbbbbbbbbbb'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'cccccccccccccc'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'dddddddddddddddd'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'eeeeeeeeeeeeeeeeee'</span>,</span></span><br><span class="line">      ],</span><br><span class="line">      currentIndex: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handle(index)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.currentIndex=index;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需要一个记录当前应该高亮的索引值，渲染元素时作为类名是否添加的判断条件，然后点击事件中动态修改这个索引值就可以。</p>
<h3 id="②-动态切换渲染的底层原理"><a href="#②-动态切换渲染的底层原理" class="headerlink" title="② 动态切换渲染的底层原理"></a>② 动态切换渲染的底层原理</h3><blockquote>
<p>先给出一个小例子</p>
</blockquote>
<p><img src="/2019/12/09/VueNote-1/20191210_174526.gif" alt="动态切换演示"><br>例子很简单，就是根据 <code>data</code> 的一个 <code>flag</code> 值动态切换元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"use-phone"</span>&gt;</span>用户手机号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"use-phone"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"use-email"</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"use-email"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"flag=!flag;"</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      flag: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是在切换的时候会注意到，输入的 <code>value</code> 值在元素切换的时候被保留了。<br>原因是 <code>vue</code> 底层的虚拟 <code>dom</code> 在更新时会比对新旧元素的改变，尽可能的减少修改的范围。<br>新旧元素除了 <code>id</code> 值以外都是相同的。因此， <code>input</code> 组件的 <code>value</code> 值被保留。<br>专业术语应该是 <code>input</code> 和 <code>label</code> 被复用。</p>
<h3 id="③-购物车实例"><a href="#③-购物车实例" class="headerlink" title="③ 购物车实例"></a>③ 购物车实例</h3><blockquote>
<p>先给出演示</p>
</blockquote>
<p><img src="/2019/12/09/VueNote-1/20191210_192637.gif" alt="购物车实例演示"></p>
<p>一个很简单的购物车例子，综合运用了 <code>v-for</code> <code>v-if</code> <code>v-else</code> <code>v-bind</code> <code>v-on</code> <code>computed</code> <code>methods</code> 等指令。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f7f7f7</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#5c6b77</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">v-if</span>=<span class="string">"books.length"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>书籍名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>出版日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>数量<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in books"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.date &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.price | showPrice &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrement(index)"</span> <span class="attr">:disabled</span>=<span class="string">"item.count&lt;=1"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          &#123;&#123; item.count &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment(index)"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"remove(index)"</span>&gt;</span>移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>购物车为空<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格 &#123;&#123; totalPrice &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;  </span><br><span class="line">    books: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'《算法导论》'</span>,</span><br><span class="line">        date: <span class="string">'2006-9'</span>,</span><br><span class="line">        price: <span class="number">85.00</span>,</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'《UNIX编程艺术》'</span>,</span><br><span class="line">        date: <span class="string">'2006-2'</span>,</span><br><span class="line">        price: <span class="number">59.00</span>,</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        name: <span class="string">'《编程珠玑》'</span>,</span><br><span class="line">        date: <span class="string">'2008-10'</span>,</span><br><span class="line">        price: <span class="number">39.00</span>,</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">4</span>,</span><br><span class="line">        name: <span class="string">'《代码大全》'</span>,</span><br><span class="line">        date: <span class="string">'2006-3'</span>,</span><br><span class="line">        price: <span class="number">125.00</span>,</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;        </span><br><span class="line">    increment(index)&#123;</span><br><span class="line">      <span class="keyword">this</span>.books[index].count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(index)&#123;</span><br><span class="line">      <span class="keyword">this</span>.books[index].count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove(index)&#123;</span><br><span class="line">      <span class="keyword">this</span>.books.splice(index,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    showPrice(price)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'￥'</span>+ price.toFixed(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    totalPrice()&#123;</span><br><span class="line">      <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.books.length; i++)&#123;</span><br><span class="line">        sum+=<span class="keyword">this</span>.books[i].price * <span class="keyword">this</span>.books[i].count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过指令来实现各种操作，最终都将改变体现到 <code>data</code> 中的 <code>books</code> 数组，页面内容也会相应改变。<br>在对价格渲染时，因为数据的原始性，我们需要对数据进行一定的修改，因为这种修改在页面中存在多处，所以写了一个 <code>filter</code> 过滤器来实现。</p>
<p>在对于总价格的累加处，有很多实现方式，列举一下。</p>
<ol>
<li>原始的 <code>for</code> 循环，遍历数组，计算每一项对应的总价格并累加。</li>
<li>使用 <code>for-in</code> 循环<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> totalPrice = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.books)&#123;</span><br><span class="line">  <span class="keyword">const</span> book = <span class="keyword">this</span>.books[i];</span><br><span class="line">  totalPrice += book.price * books.count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> totalPrice;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>for-of</code> 循环<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> totalPrice = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.books)&#123;</span><br><span class="line">  totalPrice += item.price * item.count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> totalPrice;</span><br></pre></td></tr></table></figure></li>
<li>使用高阶函数 <code>reduce</code></li>
</ol>
<h3 id="④-Vue-双向绑定原理"><a href="#④-Vue-双向绑定原理" class="headerlink" title="④ Vue 双向绑定原理"></a>④ Vue 双向绑定原理</h3><p><code>vue</code> 中的 <code>v-model</code> 指令实现了数据的双向绑定。我们可以通过另外两个指令来实现双向绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      message: <span class="string">'a'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/09/VueNote-1/20200304_173734.gif" alt="数据双向绑定演示"></p>
<p><code>v-on</code> + <code>v-bind</code> 配合产生数据双向绑定效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"valueChange"</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      message: <span class="string">'a'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      valueChange(e)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.message = e.target.value;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="⑤-Vue-响应式注意点"><a href="#⑤-Vue-响应式注意点" class="headerlink" title="⑤ Vue 响应式注意点"></a>⑤ Vue 响应式注意点</h3><p><code>vue</code> 实例中 <code>data</code> 中的数组响应式存在于七个方法中， <code>push</code> <code>pop</code> <code>splice</code> <code>shift</code> <code>unshift</code> <code>sort</code> <code>reverse</code> ，除此之外可以使用 <code>vue</code> 官方提供的 <code>set</code> <code>delete</code> 方法来响应式更新数组或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.set(state.info, <span class="string">'keyOrIndex'</span>, <span class="string">'value'</span>)</span><br><span class="line">Vue.delete(state.info, <span class="string">'keyOrIndex'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>简易计算器</title>
    <url>/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简易计算器制作-优化过程"><a href="#简易计算器制作-优化过程" class="headerlink" title="简易计算器制作+优化过程"></a>简易计算器制作+优化过程</h1><h2 id="🤪碎碎念"><a href="#🤪碎碎念" class="headerlink" title="🤪碎碎念"></a>🤪碎碎念</h2><blockquote>
<p>其实学了蛮久 <code>js</code> 的，但是一直没有尝试过用 <code>js</code> 去动手写一些小东西。<br>碰巧在某个学习平台看到了计算器的制作，顺手记录一下。</p>
</blockquote>
<a id="more"></a>

<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><p>简单到令人发指的初始简陋版本👇</p>
<blockquote>
<p>忘记粘源码了，第一部分全是图片真的很搞笑。</p>
</blockquote>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A81.png" alt></p>
<p><code>js</code> 代码也是一样的粗糙随意。</p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A82.png" alt></p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A83.png" alt></p>
<p>效果演示：</p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A84.png" alt><br><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A85.png" alt><br><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A86.png" alt><br><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A87.png" alt></p>
<p>然后就是对 <code>js</code> 代码的优化。</p>
<ol>
<li><p>将重复代码抽出来包装成为独立的函数。</p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A88.png" alt></p>
</li>
<li><p>将四个事件绑定集合到一个循环内完成。</p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A810.png" alt></p>
<blockquote>
<p>顺便，我可真是个手误小能手。</p>
</blockquote>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A89.png" alt></p>
</li>
</ol>
<h2 id="💻美化版计算器-以下才是正文系列"><a href="#💻美化版计算器-以下才是正文系列" class="headerlink" title="💻美化版计算器(以下才是正文系列)"></a>💻美化版计算器<del>(以下才是正文系列)</del></h2><p>首先是 <code>html</code> 和 <code>css</code> 部分，差不多是照搬。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>./简易计算器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML, CSS, JavaScript 计算器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"clear"</span> <span class="attr">class</span>=<span class="string">"btn other"</span> <span class="attr">value</span>=<span class="string">"C"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"btn other"</span> <span class="attr">value</span>=<span class="string">"D"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"display"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"8"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"9"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn operator toget"</span> <span class="attr">value</span>=<span class="string">"+"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn operator toget"</span> <span class="attr">value</span>=<span class="string">"*"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn operator toget"</span> <span class="attr">value</span>=<span class="string">"-"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn number toget"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn operator toget"</span> <span class="attr">value</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn operator toget"</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"btn other"</span> <span class="attr">value</span>=<span class="string">"="</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/./简易计算器.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'Open Sans'</span>, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#495678</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">form</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#495678</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">4px</span> <span class="number">4px</span> <span class="number">#3d4a65</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">40px</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">40px</span> <span class="number">0</span> <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">280px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">45px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">45px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span>, <span class="selector-id">#display</span>, <span class="selector-tag">form</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#display</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#98d1dc</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">6px</span> <span class="number">6px</span> <span class="number">0px</span> <span class="number">#3facc0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#dededc</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">47px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">115px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.number</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#72778b</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">#5f6680</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#dededc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.number</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">#5f6680</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.operator</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#dededc</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">#bebebe</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#72778b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.operator</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">#bebebe</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.other</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e3844c</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">#e76a3d</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#dededc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.other</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">#e76a3d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式图：</p>
<p><img src="/2019/11/07/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A811.png" alt></p>
<p>然后先是简单粗暴的 <code>js</code> 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//display框显示更改。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shownums = <span class="built_in">document</span>.getElementById(<span class="string">"display"</span>);</span><br><span class="line">  shownums.value+=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shownums = <span class="built_in">document</span>.getElementById(<span class="string">"display"</span>);</span><br><span class="line">  shownums.value=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除一个输入函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backspace</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shownums = <span class="built_in">document</span>.getElementById(<span class="string">"display"</span>);</span><br><span class="line">  shownums.value=shownums.value.substring(<span class="number">0</span>,shownums.value.length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为所有 num 和 operator 的 button 添加点击监听事件</span></span><br><span class="line"><span class="keyword">var</span> Btns = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"toget"</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;Btns.length;i++)&#123;</span><br><span class="line">  Btns[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">get</span>(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是前面几个显示部分的函数，都很简单。不过我发现我老是忘记字符串是无法更改的，而且记不清数组和字符串各自的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到清除按钮绑定点击监听事件</span></span><br><span class="line"><span class="keyword">var</span> clearBtn = <span class="built_in">document</span>.getElementById(<span class="string">"clear"</span>);</span><br><span class="line">clearBtn.onclick=clear;</span><br><span class="line"><span class="comment">//删除一个输入的绑定监听</span></span><br><span class="line"><span class="keyword">var</span> deleteBtn = <span class="built_in">document</span>.getElementById(<span class="string">"delete"</span>);</span><br><span class="line">deleteBtn.onclick=backspace;</span><br><span class="line"><span class="comment">//计算结果的点击绑定监听</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="built_in">document</span>.getElementById(<span class="string">"cal"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculates</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="number">0</span>;</span><br><span class="line">  result = <span class="built_in">document</span>.getElementById(<span class="string">"display"</span>).value;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"display"</span>).value=<span class="built_in">eval</span>(result);</span><br><span class="line">&#125;</span><br><span class="line">re.onclick=calculates;</span><br></pre></td></tr></table></figure>

<p>然后到了这里，写着写着懵了一下。本来以为要摩拳擦掌自己写计算的函数，怎么怎么取符号，结果直接一个 <code>eval</code> 函数砸了上来。 emmmmm， 我一定是沉浸在写 <code>C</code> 的时候，很多东西都是自己动手去写。现在写别的语言，有了很多内置的函数很方便，但是我总不记得。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间展示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> y = today.getFullYear();</span><br><span class="line">  <span class="keyword">var</span> M = today.getMonth()+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> d = today.getDate();</span><br><span class="line">  <span class="keyword">var</span> h = today.getHours();</span><br><span class="line">  <span class="keyword">var</span> m = today.getMinutes();</span><br><span class="line">  <span class="keyword">var</span> s = today.getSeconds();</span><br><span class="line">  m=checkTime(m);</span><br><span class="line">  s=checkTime(s);</span><br><span class="line">  <span class="keyword">var</span> week=today.getDay();</span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"星期天"</span>,<span class="string">"星期一"</span>,<span class="string">"星期二"</span>,<span class="string">"星期三"</span>,<span class="string">"星期四"</span>,<span class="string">"星期五"</span>,<span class="string">"星期六"</span>);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"time"</span>).innerHTML=y+<span class="string">"年"</span>+M+<span class="string">"月"</span>+d+<span class="string">"日"</span>+<span class="string">"&lt;/br&gt;"</span>+h+<span class="string">":"</span>+m+<span class="string">":"</span>+s+<span class="string">" "</span>+w[week];</span><br><span class="line">  setTimeout(<span class="string">"showTime()"</span>,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">    i=<span class="string">"0"</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  showTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一个时间展示，这不禁让我想起了上周遇到的坑。<br><code>input</code> 中 <code>type</code> 为 <code>date</code> 的那个元素 <code>value</code> 值的接收是有格式要求的，比如日的数字就要求是两位数。</p>
<p>我写了一个自动获取当天日期的函数，在我自己测试的时候，是在二十几号，都没有出现过问题。别人在四五号的时候一测，就遇到 <code>bug</code> 了。😂</p>
<h2 id="💡总结"><a href="#💡总结" class="headerlink" title="💡总结"></a>💡总结</h2><p>一个简单的计算器就差不多是这样了。写完一看好像也没有什么特别的东西……唯一记得的大概是这个计算器的样式很好看， <code>eval</code> 让我眼前一亮(?)</p>
<blockquote>
<p>顺便记一下，要去了解一下 <code>setTimeout</code> 和 <code>setInterval</code> 的异同。</p>
</blockquote>
<h2 id="2020-年回顾"><a href="#2020-年回顾" class="headerlink" title="2020 年回顾"></a>2020 年回顾</h2><p>仔细又看了一下这个例子，其实重点在于获取 <code>dom</code> 元素以及值。对于我来说，也许还有页面的样式和布局。</p>
<p>那个时候还是很难接受一个语言内置一大堆的函数和方法，因为我那时候觉得记下来很难，现在却好像已经习惯了许多。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>CSStip</title>
    <url>/2019/10/27/css%E5%B0%8Ftip/</url>
    <content><![CDATA[<h1 id="一些关于CSS的tip"><a href="#一些关于CSS的tip" class="headerlink" title="一些关于CSS的tip"></a>一些关于CSS的tip</h1><ul>
<li><code>margin</code> 值的百分比是相对于父元素的 <code>width</code> 。</li>
<li>三角形的制作利用 <code>width</code> <code>height</code> 为0 然后设置 <code>border</code> 。</li>
<li>气泡的制作<br><img src="/2019/10/27/css%E5%B0%8Ftip/bubble.png" alt="bubble"></li>
</ul>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bubble"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"triangle common"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cover common"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!-- 用来覆盖的倒三角 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bubble</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#FFB5BF</span>; </span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.common</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">position</span>: absolute;      <span class="comment">/* 使用绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, 0);  <span class="comment">/* 水平居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">20px</span> solid <span class="number">#FFB5BF</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cover</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">13px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">20px</span> solid <span class="number">#94E8FF</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>loading</code> 效果制作利用 <code>CSS3</code> 的动画<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.loading</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-left-color</span>: <span class="number">#FFB5BF</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.loading</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: loading-animation <span class="number">1.2s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> loading-animation &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>行级元素的高度取决于文体字体大小。</li>
<li>文字隐藏的方法:<ul>
<li><code>height: 0</code>+<code>padding</code>撑出背景图片，然后设置<code>overflow: hidden</code></li>
<li><code>text-indent: -10000</code></li>
<li>将文字包入<code>span</code>元素中，然后<code>display: none</code></li>
</ul>
</li>
<li><code>a</code> 标签的样式需要遵守 <code>link</code> <code>visited</code> <code>hover</code> <code>active</code> 顺序，在 <code>href</code> 不填入值的时候， <code>a:link</code> 不起作用。</li>
<li>浏览器将标签间的换行空白渲染为一个空格导致部分元素间出现间隙解决方法：<ul>
<li>编写页面时不换行。</li>
<li>容器的 <code>font-size</code> 设置为 <code>0</code>.</li>
<li>我们需要将li内的字符间隔设为默认。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">ul</span>&#123;<span class="attribute">letter-spacing</span>: -<span class="number">4px</span>;&#125;</span><br></pre></td></tr></table></figure>
之后记得设置li内字符间隔<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;<span class="attribute">letter-spacing</span>: normal;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>div里嵌套了 <code>img</code> 底部会出现白边<ul>
<li>因为 <code>img</code> 默认是按基线 <code>(baseline)</code> 对齐的。</li>
<li>要去掉空格可以使用 <code>vertical-align: bottom</code> 或将 <code>img</code> 标签变为块级元素。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>line-height</code> 仅在值为纯数字时，才会使后代继承该比值，否则继承计算后的结果。</p>
</li>
<li><p><code>p</code> 元素不能包含 <code>div</code> 元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>字体颜色闪现问题</title>
    <url>/2019/10/22/%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E9%97%AA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="transition属性页面加载a元素字体颜色闪现问题"><a href="#transition属性页面加载a元素字体颜色闪现问题" class="headerlink" title="transition属性页面加载a元素字体颜色闪现问题"></a>transition属性页面加载a元素字体颜色闪现问题</h3><blockquote>
<p>在写需求的时候，对 <code>index.html</code> 页面的按钮做了 <code>transition</code> 效果来使样式展示更平滑。</p>
</blockquote>
<a id="more"></a>

<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main-area</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">54px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color .<span class="number">5s</span> ease,</span><br><span class="line">  color .<span class="number">5s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-area</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3399FF</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发现想要的效果确实可以做到，<strong>但是</strong>每次打开页面的时候都可以看到a元素的字体颜色从 <strong><em>各种奇怪的颜色</em></strong> 闪现为设定的颜色。</p>
<p>研究了一会儿，看到 <code>transition</code> 的一个属性：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transition-property : none | all | [&lt;IDENT&gt;][','&lt;IDENT&gt;]* ;</span><br></pre></td></tr></table></figure>

<p><code>transition-property</code> 是用来指定当元素其中一个属性改变时执行 <code>transition</code> 效果，其中 <code>none</code> 没有属性改变；<code>all</code> 所有属性都改变，它也是默认值；<code>indent</code> 可以填写元素属性名。</p>
<blockquote>
<p>👆以上来自某教程网站</p>
</blockquote>
<p>然后打开 F12 看了一下 对应位置的 <code>a</code> 元素的所有 <code>color</code> 属性。</p>
<p><img src="/2019/10/22/%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E9%97%AA%E7%8E%B0%E9%97%AE%E9%A2%98/transition.png" alt="transition"></p>
<p>就可以看到在重置样式表 <code>reset.css</code> 中的 <code>color</code> 设置为继承值。<br>取消这个样式，就可以看到 <code>a</code> 的 <code>color</code> 变为我们看到的闪现前的颜色。</p>
<p><img src="/2019/10/22/%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E9%97%AA%E7%8E%B0%E9%97%AE%E9%A2%98/transition1.png" alt="transition1"></p>
<p><img src="/2019/10/22/%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E9%97%AA%E7%8E%B0%E9%97%AE%E9%A2%98/transition2.png" alt="transition2"></p>
<p>按我的理解也就是，浏览器记住了这个覆盖过程，然后把它展示为动画效果，那我们应该要想办法把这个覆盖 <code>a</code> 默认颜色的过程提前到 <code>transition</code> 没有记住的时候。</p>
<p>我的做法是在 <code>head</code> 标签中写入 <code>style</code> 直接覆盖 <code>a</code> 的 <code>color</code> 属性。</p>
<p>其余解决方法待后续研究。<del>大概不会有后续</del></p>
<h3 id="来自两年后的后续"><a href="#来自两年后的后续" class="headerlink" title="来自两年后的后续"></a>来自两年后的后续</h3><p>其实到今天我也没看出来那个奇怪的蓝紫色到底是哪里来的，我又打开当时的文件重看了一遍。将当时在 <code>style</code> 标签里的样式注释掉，却没有再看见当时的蓝紫色。很奇怪，但是我仔细看了看当时写的样式，我发现我似乎并没有对 <code>a</code>  元素设置默认颜色，只设置了 <code>hover</code> 时的颜色。</p>
<p>当然了，我又翻看了开发者工具的计算样式，其实那个颜色只是 <code>a</code> 元素的默认蓝色而已……</p>
<p>当时居然一惊一乍的，感觉遇到了什么难题。😂</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS继承</title>
    <url>/2019/10/22/CSS%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="🤪碎碎念"><a href="#🤪碎碎念" class="headerlink" title="🤪碎碎念"></a>🤪碎碎念</h3><blockquote>
<p>一开始记录在 <code>Onenote</code> 中的笔记复制都是直接图片形式。所以我先复制到记事本再转到 <code>markdown</code>。</p>
</blockquote>
<a id="more"></a>
<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><p>在阅读《CSS权威指南》过程中，在继承这一模块发现了选择器权重的一些内容。</p>
<ul>
<li>继承得到的值没有特殊性，权重弱于 <code>0</code> 特殊性（通配符）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      * &#123;<span class="attribute">color</span>:gray;&#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">h1</span><span class="selector-id">#page-title</span> &#123;<span class="attribute">color</span>:black;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"page-title"</span>&gt;</span>Meerkat <span class="tag">&lt;<span class="name">em</span>&gt;</span>Central<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Welcome to the best place on the web for meerkat information!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/22/CSS%E7%BB%A7%E6%89%BF/pic.png" alt="演示"></p>
<h2 id="👇图片形式"><a href="#👇图片形式" class="headerlink" title="👇图片形式"></a>👇图片形式</h2><p><del>糊的妈都不认识</del></p>
<p><img src="/2019/10/22/CSS%E7%BB%A7%E6%89%BF/1.jpg" alt><br><img src="/2019/10/22/CSS%E7%BB%A7%E6%89%BF/2.jpg" alt><br><img src="/2019/10/22/CSS%E7%BB%A7%E6%89%BF/3.jpg" alt></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环添加事件监听</title>
    <url>/2019/10/19/for%E5%BE%AA%E7%8E%AF%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h1 id="for循环添加事件监听"><a href="#for循环添加事件监听" class="headerlink" title="for循环添加事件监听"></a>for循环添加事件监听</h1><blockquote>
<p>在写某个需求时，想要做点击按钮动态添加样式表示选中的效果，在写 <code>js</code> 代码的时候遇到了疑问点。</p>
</blockquote>
<a id="more"></a>

<p><img src="/2019/10/19/for%E5%BE%AA%E7%8E%AF%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/for%E5%BE%AA%E7%8E%AF.png" alt="页面"></p>
<p>页面如上所示，头部的三个按钮在点击后永远只会对最后一个按钮进行样式添加或移除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chooseArea = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"choose-area"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;chooseArea.children.length;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chooseArea.children);</span><br><span class="line">  <span class="keyword">var</span> child = chooseArea.children[i];</span><br><span class="line">  child.onclick=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(child);</span><br><span class="line">  <span class="keyword">if</span>(child.className==<span class="string">""</span>)</span><br><span class="line">    child.className=<span class="string">"active"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处先拿出主要的代码(此时的已经是不完整+乱改版本)，部分打印代码为调试时编写。<br>查了一下百度，大概了解到是 <code>onclick</code> 或是添加事件监听一类都不是即时运行。而内部会调用外部的变量，在 <code>click</code> 事件的函数运行时，<code>i</code> 早已自增至最大值，所以永远指向最后一个元素。此处的解决方法是闭包。(我终于知道闭包的作用了…)</p>
<p>修改后的代码(依然有待改进，时间未定)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chooseArea = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"choose-area"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;chooseArea.children.length;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chooseArea.children);</span><br><span class="line">  <span class="keyword">var</span> child = chooseArea.children[i];</span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">child,i</span>)</span>&#123;</span><br><span class="line">	  child.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child.className == <span class="string">""</span>)</span><br><span class="line">          child.className = <span class="string">"active"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          child.className=<span class="string">""</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;chooseArea.children.length;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            chooseArea.children[j].className=<span class="string">""</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;;</span><br><span class="line">	  &#125;)(child,i);</span><br></pre></td></tr></table></figure>

<p>闭包都解决不了的我可真是个菜鸡…(lll￢ω￢)</p>
<h2 id="2020-年的回顾"><a href="#2020-年的回顾" class="headerlink" title="2020 年的回顾"></a>2020 年的回顾</h2><p>这篇大概是最让我无奈的，现在我已经完全清楚笔记中记录的问题了。</p>
<p>一个很普遍简单的需求，多个按钮，监听按钮的点击事件来切换选中状态。</p>
<p>我们选择遍历按钮的 <code>dom</code> 类数组，如果仅仅采用 <code>ES5</code> 来完成，确实会遇到问题。</p>
<p>原因在于 <code>var</code> 声明的局限性， <code>var</code> 不存在块级作用域，在 <code>for</code> 循环内部声明的所有变量的作用域都是高于块级的，所有块级内部共享同样的变量，所以最后我们能找到的 <code>i</code> 是循环结束的值，所有按钮的点击事件都是触发最后一个按钮的样式变化。</p>
<p>此处的解决方法有：</p>
<ul>
<li>使用 <code>let</code> 声明块级作用域的变量。</li>
<li>调用立即执行函数形成闭包，也就是形成函数作用域来保存每一个 <code>i</code>  。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise中的setTimeOut参数问题</title>
    <url>/2019/10/18/Promise%E4%B8%AD%E7%9A%84setTimeOut%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="Promise中的setTimeOut参数问题"><a href="#Promise中的setTimeOut参数问题" class="headerlink" title="Promise中的setTimeOut参数问题"></a>Promise中的setTimeOut参数问题</h3><blockquote>
<p>在看 <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544" target="_blank" rel="noopener">廖雪峰的 <code>javascript</code> 教程的 Promise </a> 一节看到一个疑问点。</p>
</blockquote>
<p>关于Promise的异步执行，其中一个示例代码中看到了setTimeOut的第三个参数。</p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logging = <span class="built_in">document</span>.getElementById(<span class="string">'test-promise2-log'</span>);</span><br><span class="line"><span class="keyword">while</span> (logging.children.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  logging.removeChild(logging.children[logging.children.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">  p.innerHTML = s;</span><br><span class="line">  logging.appendChild(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0.5秒后返回input*input的计算结果:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'calculating '</span> + input + <span class="string">' x '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, input * input);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.5秒后返回input+input的计算结果:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'calculating '</span> + input + <span class="string">' + '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, input + input);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'start new Promise...'</span>);</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'Got value: '</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在讲 <code>input*input</code> 和 <code>input+input</code> 作为第三个参数传入为第一个参数函数的参数时，输出结果可以做到延时。</p>
<p>但如果我将代码修改为直接作为第一个 <code>resove</code> 的参数传入，就无法做到延时的效果。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logging = <span class="built_in">document</span>.getElementById(<span class="string">'test-promise2-log'</span>);</span><br><span class="line"><span class="keyword">while</span> (logging.children.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  logging.removeChild(logging.children[logging.children.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">  p.innerHTML = s;</span><br><span class="line">  logging.appendChild(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0.5秒后返回input*input的计算结果:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'calculating '</span> + input + <span class="string">' x '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">    setTimeout(resolve(input*input), <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.5秒后返回input+input的计算结果:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'calculating '</span> + input + <span class="string">' + '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">    setTimeout(resolve(input+input), <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'start new Promise...'</span>);</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(multiply)</span><br><span class="line"> .then(add)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'Got value: '</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>应该是因为异步一类的原因，待整理。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>一年后我来更新了，现在回看真是个白痴问题。</p>
<p>先提 <code>setTimeout</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">var timeoutID = scope.setTimeout(function[, delay, arg1, arg2, ...]);</span><br><span class="line">var timeoutID = scope.setTimeout(function[, delay]); </span><br><span class="line"><span class="keyword">var</span> timeoutID = scope.setTimeout(code[, delay]);</span><br></pre></td></tr></table></figure>

<p>这是该函数的调用实例。</p>
<ul>
<li><p>第一个参数可以是字符串代码也可以是函数。</p>
</li>
<li><p>第二个参数是该函数的调用时延，是可选参数，省略的话默认为 <code>0</code> 。</p>
</li>
<li><p>第三个及后面的参数为参数列表，代表第一个参数调用时传入的参数。</p>
</li>
</ul>
<p>那么在前面的例子中，第三个参数 <code>input * input</code> or <code>input + input</code> 都是传入第一个参数 <code>resolve</code> 回调的参数。</p>
<p>而我当时想到的是第一个参数直接写为 <code>resolve(input * input)</code> ，这样其实是错误的，因为这样的书写方法代表了直接调用 <code>resolve</code> 回调。那么 <code>setTimeou</code> 的延迟作用就无效了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS伪类选择器</title>
    <url>/2019/06/05/CSS%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="选择第一个子元素"><a href="#选择第一个子元素" class="headerlink" title="选择第一个子元素"></a>选择第一个子元素</h3><p>在阅读《CSS权威指南》的过程中，读到关于伪类选择器时的“选择第一个子元素”部分，发现对于伪类 <code>:first-child</code> 存在误解。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123; <span class="attribute">text-transform</span>: uppercase; &#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are the necessary step:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Insert key<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Turn key <span class="tag">&lt;<span class="name">strong</span>&gt;</span>clockwise<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Push accelerator<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span> Do <span class="tag">&lt;<span class="name">em</span>&gt;</span>not<span class="tag">&lt;/<span class="name">em</span>&gt;</span> push the brake at the same time as the accelerator.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前是将 <code>p:first-child</code> 理解为第一个 <code>p</code> 元素，阅读后发现其真实含义为某元素第一个子元素的所有 <code>p</code> 元素。</p>
<p><img src="/2019/06/05/CSS%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/pic1.png" alt="演示"></p>
<p><strong>伪类的实质为符合:后的要求的元素。</strong></p>
<h3 id="2020年的回顾"><a href="#2020年的回顾" class="headerlink" title="2020年的回顾"></a>2020年的回顾</h3><p>看了当时的记录，感觉还是怪怪的。于是改了一下代码再次尝试。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;</span></span><br><span class="line">      font-weight: bold;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span></span><br><span class="line">      text-transform: uppercase;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"first-child"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"second-child"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are the necessary step:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Insert key<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Turn key <span class="tag">&lt;<span class="name">strong</span>&gt;</span>clockwise<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Push accelerator<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Do <span class="tag">&lt;<span class="name">em</span>&gt;</span>not<span class="tag">&lt;/<span class="name">em</span>&gt;</span> push the brake at the same time as the accelerator.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/06/05/CSS%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/image-20201013205859864.png" alt="image-20201013205859864"></p>
<p>查看展示的效果可以看出， <code>p:first-child</code> 的含义解释为，作为第一个子元素的所有 <code>p</code> 标签。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>font-face远程问题</title>
    <url>/2019/06/02/font-face%E8%BF%9C%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><p>在阅读 <code>Head First HTML与CSS</code> 第2版过程中，在增加字体和颜色样式部分学习到为页面增加Web字体。<br>其中运用了 <code>@font-face</code> 功能，照示例所写是失败的。</p>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"https://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.woff"</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>), </span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"https://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.ttf"</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>);</span><br><span class="line">&#125;</span><br><span class="line">//url后的format是后来加的，测试后并无效果。</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">220%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/02/font-face%E8%BF%9C%E7%A8%8B%E9%97%AE%E9%A2%98/pic1.png" alt="演示"></p>
<p>如图所示，会显示请求字体失败。<br>但是如果字体是存储在本地的，则成功。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"EmblemaOne-Regular.woff"</span>), </span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"EmblemaOne-Regular.ttf"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">220%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/02/font-face%E8%BF%9C%E7%A8%8B%E9%97%AE%E9%A2%98/pic2.png" alt="演示"></p>
<p>除此之外，有实验利用在线字体库“有字库”也可以成功</p>
<p><img src="/2019/06/02/font-face%E8%BF%9C%E7%A8%8B%E9%97%AE%E9%A2%98/pic3.png" alt="演示"></p>
<p>照它的要求进行设置可以成功</p>
<p><img src="/2019/06/02/font-face%E8%BF%9C%E7%A8%8B%E9%97%AE%E9%A2%98/pic4.png" alt="演示"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>邱奇编码的javascript实现</title>
    <url>/2019/05/29/%E9%82%B1%E5%A5%87%E7%BC%96%E7%A0%81%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="📃正文"><a href="#📃正文" class="headerlink" title="📃正文"></a>📃正文</h2><h3 id="加减乘"><a href="#加减乘" class="headerlink" title="加减乘"></a>加减乘</h3><p>在<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016" target="_blank" rel="noopener">廖雪峰老师的网站</a>看到了闭包内容，其中的脑洞大开部分就是关于邱奇编码的加法。</p>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数字0:</span></span><br><span class="line"><span class="keyword">var</span> zero = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数字1:</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加法:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m(f)(n(f)(x));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数字2 = 1 + 1:</span></span><br><span class="line"><span class="keyword">var</span> two = add(one, one);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数字3 = 1 + 2:</span></span><br><span class="line"><span class="keyword">var</span> three = add(one, two);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数字5 = 2 + 3:</span></span><br><span class="line"><span class="keyword">var</span> five = add(two, three);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你说它是3就是3，你说它是5就是5，你怎么证明？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 呵呵，看这里:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给3传一个函数,会打印3次:</span></span><br><span class="line">(three(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'print 3 times'</span>);</span><br><span class="line">&#125;))();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给5传一个函数,会打印5次:</span></span><br><span class="line">(five(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'print 5 times'</span>);</span><br><span class="line">&#125;))();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续接着玩一会...</span></span><br></pre></td></tr></table></figure>

<p>加法其实比较好理解，关于减法部分在网上搜索了很久。找到的代码比较难理解。</p>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ZERO = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ADD1 = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(n(f)(z));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pred = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fx = <span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> h(g(action));</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> n(fx)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> TWO = pred(THREE)=<span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h(g(action));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> u;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">TWO(action)(x)=<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(g(action));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;(x)=THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(g(action));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> SUB1 = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((n (<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> h(g(f));</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;))&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> z;</span><br><span class="line">        &#125;))(<span class="function"><span class="keyword">function</span> (<span class="params">u</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> u;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ONE = ADD1(ZERO);</span><br><span class="line"><span class="keyword">var</span> TWO = ADD1(ONE);</span><br><span class="line"><span class="keyword">var</span> THREE = ADD1(TWO);</span><br><span class="line">(TWO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;))();</span><br><span class="line">(THREE(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'2'</span>);</span><br><span class="line">&#125;))();</span><br><span class="line">THREE = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(f(ONE(f)(x)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">THREE(f) = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(f(ONE(f)(x)));</span><br><span class="line">&#125;;</span><br><span class="line">TWO = pred(THREE) = <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h(g(action));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> u;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">TWO(action) = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(g(action));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">TWO(action)(x) = THREE(<span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(g(action));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*function(g)&#123;</span></span><br><span class="line"><span class="comment">  return function(h)&#123;</span></span><br><span class="line"><span class="comment">    return h(g(action));</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">&#125;=f</span></span><br><span class="line"><span class="comment">f(x)=function(g)&#123;</span></span><br><span class="line"><span class="comment">  return function(h)&#123;</span></span><br><span class="line"><span class="comment">    return h(g(action));</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">&#125;(x)=function(h)&#123;</span></span><br><span class="line"><span class="comment">  return h(x(action));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">function(h)&#123;</span></span><br><span class="line"><span class="comment">  return h(x(action));</span></span><br><span class="line"><span class="comment">&#125;(x)=x(x(action))</span></span><br><span class="line"><span class="comment">f(f(ONE(f)(x)))(g)</span></span><br><span class="line"><span class="comment">f(f(f(x)))(g)</span></span><br><span class="line"><span class="comment">f(f(x))(g)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TWO(action)(x) = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(f(ONE(f)(x)));</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">= f(f(ONE(f)(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)))(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">= f(f(f(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)))(<span class="function"><span class="keyword">function</span> (<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">=f(f(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;(action));</span><br><span class="line">&#125;))(<span class="function"><span class="keyword">function</span> (<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">=f(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;(action));</span><br><span class="line">  &#125;(action));</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">= <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;(action));</span><br><span class="line">    &#125;(action));</span><br><span class="line">  &#125;(action));</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span> (<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;)</span><br><span class="line">= <span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;(action));</span><br><span class="line">    &#125;(action));</span><br><span class="line">  &#125;(action))</span><br><span class="line">= <span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;(action));</span><br><span class="line">    &#125;(action));</span><br><span class="line">  &#125;(action)</span><br><span class="line">= action(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;(action));</span><br><span class="line">    &#125;(action))</span><br><span class="line">= action(action(<span class="function"><span class="keyword">function</span>(<span class="params">u</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;(action)))</span><br><span class="line">= action(action(x));</span><br><span class="line">TWO = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(ONE(f)(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ONE(f)(x)=f(ZERO(f)(x))=f(x);</span><br><span class="line">ONE = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(ZERO(f)(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实到最后算出结果我也没绕出弯来🙃</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params">n, m</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m(n(f))(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test six</span></span><br><span class="line"><span class="keyword">var</span>  six = multi(three,two);</span><br><span class="line">(multi(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'print 6 times'</span>);</span><br><span class="line">&#125;))();</span><br></pre></td></tr></table></figure>

<p>大佬们果然都很喜欢挑战自己(lll￢ω￢)。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql运行现有sql文件</title>
    <url>/2018/12/31/mysql%E8%BF%90%E8%A1%8C%E7%8E%B0%E6%9C%89sql%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>2018.12.31 23:18 <strong>MySQL学习中</strong></p>
<p>PHP和MySQLWeb开发第四版</p>
<h1 id="关于命令行运行现有的sql文件问题"><a href="#关于命令行运行现有的sql文件问题" class="headerlink" title="关于命令行运行现有的sql文件问题"></a>关于命令行运行现有的sql文件问题</h1><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\wamp\bin\mysql\mysql5.7.23&gt;mysql -h localhost -u bookorama -D books -p &lt; bookorama.sql</span><br><span class="line">系统找不到指定的文件。</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23&gt;<span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23\bin&gt;mysql -h localhost -u bookorama -D books -p &lt; D:\zyWEB\SQLjb\bookorama.sql</span><br><span class="line">Enter password: ************</span><br><span class="line">ERROR 1050 (42S01) at line 1: Table <span class="string">'customers'</span> already exists</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23\bin&gt;mysql -h localhost -u bookorama -D books -p &lt; D:\zyWEB\SQLjb\bookorama.sql</span><br><span class="line">Enter password: ************</span><br><span class="line">ERROR 1064 (42000) at line 8: You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">'data not null</span></span><br><span class="line"><span class="string">)'</span> at line 6</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23\bin&gt;mysql -h localhost -u bookorama -D books -p &lt; D:\zyWEB\SQLjb\bookorama.sql</span><br><span class="line">Enter password: ************</span><br><span class="line">ERROR 1050 (42S01) at line 1: Table <span class="string">'customers'</span> already exists</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23\bin&gt;mysql -h localhost -u bookorama -D books -p &lt; D:\zyWEB\SQLjb\bookorama.sql</span><br><span class="line">Enter password: ************</span><br><span class="line"></span><br><span class="line">D:\wamp\bin\mysql\mysql5.7.23\bin&gt;</span><br></pre></td></tr></table></figure>

<p>经过无数次尝试与纠结，一开始提示权限不够，很无语，记得上次创建 <code>bookorama</code> 这个账户时应该给了他权限的，然后又开 <code>mysql</code> 控制台重新给权限然后再来命令行继续敲命令，又发现 <code>sql</code> 文件中写错了，然后又改，最终是成功了。QAQ</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectASocialNewsWebPageapp</title>
    <url>/2018/12/17/ProjectASocialNewsWebPageapp/</url>
    <content><![CDATA[<p>2018.12.17 11:07 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter26 <code>&lt;Project: a social news web app&gt;</code></p>
</blockquote>
<p>原题:</p>
<h1 id="Project-a-social-news-web-app"><a href="#Project-a-social-news-web-app" class="headerlink" title="Project: a social news web app"></a>Project: a social news web app</h1><p>This final project is the culmination of the book. You can check out the <a href="https://thejsway-publink.herokuapp.com" target="_blank" rel="noopener">expected result</a>. Good luck!</p>
<a id="more"></a>

<h2 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h2><p>This project builds upon the social news program and web pages you created previously. This time, the objective is to make a social news application based on a Node.js server.</p>
<h2 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h2><ul>
<li>A link is defined by its title, its URL and its author (submitter).</li>
<li>If a new link URL does not start with “http://“ or “https://“, “http://“ is automatically added at its beginning.</li>
<li>The web app displays a list of at least three already existing links, fetched from the server through an AJAX request.</li>
<li>A button exists for the user to submit a new link. When clicked, a form appears before the link list to input the new link properties (author, title and URL).</li>
<li>In this form, all link fields are mandatory.</li>
<li>When the new link is validated by the user, it is sent as form data to the server. If the operation is successful, the server returns the new link as JSON data. The new link is added at the top of the link list, replacing the form. A message indicates the success of the operation, then disappears after two seconds.</li>
</ul>
<h2 id="Technical-requirements"><a href="#Technical-requirements" class="headerlink" title="Technical requirements"></a>Technical requirements</h2><ul>
<li>The server must use a user-defined module exporting link-related code.</li>
<li>You should reuse any useful code from the previous projects.</li>
<li>All your code should be correctly indented.</li>
<li>Names should be wisely chosen and adhere to the camelCase convention.</li>
<li>Code duplication should be avoided.</li>
</ul>
<h2 id="Expected-result"><a href="#Expected-result" class="headerlink" title="Expected result"></a>Expected result</h2><p>Here are a few screenshots of the expected result.</p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013192921261.png" alt="image-20201013192921261"></p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013192927246.png" alt="image-20201013192927246"></p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013192932469.png" alt="image-20201013192932469"></p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013192937932.png" alt="image-20201013192937932"></p>
<p>=。=决定认真的写一下过程</p>
<h3 id="1-将页面更改为服务端。"><a href="#1-将页面更改为服务端。" class="headerlink" title="1.将页面更改为服务端。"></a>1.将页面更改为服务端。</h3><p>将 <code>fitst.html</code> <code>eample.js</code> <code>first.css</code> 以及部分需求的 <code>js</code> 或者 <code>css</code> 文件复制到 <code>myserver</code>  文件夹中。</p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013193413251.png" alt="image-20201013193413251"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/first'</span>, (request, response) =&gt; &#123;</span><br><span class="line">  response.sendFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/views/first.html`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>添加一个 <code>app.get</code> 来使 <code>localhost:3000/first</code> 展示为 <code>first.html</code> 。</p>
<p>百般尝试发现无法实现初始化三个链接，一番操作后发现自己打开了另一个路径的 <code>example.js</code>（???修改后发现传入函数 <code>createmenu(link)</code> 的 <code>link</code> 为 <code>undefined</code> 并且只出现了一个链接框(??? 控制台输出大法后发现传入的 <code>link</code> 为 <code>Array(3)</code> (??? 说好的 <code>JSON</code> 呢???)于是循环遍历后，便达成了效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://localhost:3000/api/first'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> one <span class="keyword">of</span> result) &#123;</span><br><span class="line">      createmenu(one);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/api/first'</span>, jsonParser, (request, response) =&gt; &#123;</span><br><span class="line">  response.json(links);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/first'</span>, (request, response) =&gt; &#123;</span><br><span class="line">  response.sendFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/views/first.html`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013193423479.png" alt="image-20201013193423479"></p>
<p>爱心为啥变成了问号，我也母鸡。</p>
<p>又在 <code>JSON</code> 的类型上纠结了很久。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">linkform.addEventListener(<span class="string">'submit'</span>, e =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(e.target);</span><br><span class="line">  fetch(<span class="string">'http://localhost:3000/api/first'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: formData</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      createsucceed(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/ai/first'</span>, upload.array(), (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(request.body.input.startsWith(<span class="string">'http://'</span>) || request.body.input.startsWith(<span class="string">'https://'</span>))) &#123;</span><br><span class="line">    request.body.input = <span class="string">'http://'</span> + request.body.input;</span><br><span class="line">  &#125;</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(request.body));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>题目要求为作为表单数据发送给服务器，而服务器以 <code>JSON</code> 数据的形式返回新链接。<br>经过数次尝试后发现在服务器以 <code>JSON.stringify</code> 方法的返回类型返回的话, 再转换为 <code>text</code> 即可达成效果。(但是成功时的提示消息的样式信息怎么给我搞丢了….)</p>
<p><img src="/2018/12/17/ProjectASocialNewsWebPageapp/image-20201013193431327.png" alt="image-20201013193431327"></p>
<p>新的数据怎么又成 <code>undefined</code> 的了。<br>路径的 <code>api</code> 少了一个 <code>p</code> 真好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createlink = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> linkform = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">  linkform.className = <span class="string">'linkForm'</span>;</span><br><span class="line">  <span class="keyword">const</span> input1 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input2 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input3 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input4 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  input1.style.width = <span class="string">'250px'</span>;</span><br><span class="line">  input2.style.width = <span class="string">'450px'</span>;</span><br><span class="line">  input3.style.width = <span class="string">'300px'</span>;</span><br><span class="line">  input4.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  input1.type = <span class="string">'text'</span>;</span><br><span class="line">  input1.name = <span class="string">'title'</span>;</span><br><span class="line">  input2.type = <span class="string">'text'</span>;</span><br><span class="line">  input2.name = <span class="string">'url'</span>;</span><br><span class="line">  input3.type = <span class="string">'text'</span>;</span><br><span class="line">  input3.name = <span class="string">'submitted'</span>;</span><br><span class="line">  input4.type = <span class="string">'submit'</span>;</span><br><span class="line">  input1.required = <span class="string">'required'</span>;</span><br><span class="line">  input2.required = <span class="string">'required'</span>;</span><br><span class="line">  input3.required = <span class="string">'required'</span>;</span><br><span class="line">  input4.id = <span class="string">'inputbutton'</span>;</span><br><span class="line">  input4.value = <span class="string">'Add link'</span>;</span><br><span class="line">  linkform.addEventListener(<span class="string">'submit'</span>, e =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(e.target);</span><br><span class="line">    fetch(<span class="string">'http://localhost:3000/api/first'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: formData</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        createsucceed(result);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.message);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  linkform.appendChild(input1);</span><br><span class="line">  linkform.appendChild(input2);</span><br><span class="line">  linkform.appendChild(input3);</span><br><span class="line">  linkform.appendChild(input4);</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(linkform, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">app.post(<span class="string">'/api/first'</span>, upload.array(), (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(request.body.url.startsWith(<span class="string">'http://'</span>) || request.body.url.startsWith(<span class="string">'https://'</span>))) &#123;</span><br><span class="line">    request.body.url = <span class="string">'http://'</span> + request.body.url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res1 = request.body.title;</span><br><span class="line">  <span class="keyword">const</span> res2 = request.body.url;</span><br><span class="line">  <span class="keyword">const</span> res3 = request.body.submitted;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;</span><br><span class="line">    title: res1,</span><br><span class="line">    url: res2,</span><br><span class="line">    author: res3</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  response.send(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>疯狂的控制台输出大法后发现, 传到客户端的应该是 <code>JSON</code> 对象而不是字符串 所以改为 <code>response.json()</code> 然后就基本达成效果。<br>大致完工。绿色的样式信息懒得写了=。=</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs 记一次被自己蠢哭的经历</title>
    <url>/2018/12/16/nodejs-%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A2%AB%E8%87%AA%E5%B7%B1%E8%A0%A2%E5%93%AD%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>2018.12.16 22:46 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter25</p>
</blockquote>
<p>被自己蠢哭了TT</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> jsonParser = bodyParser.json();</span><br><span class="line"><span class="keyword">const</span> upload = multer();</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> articles = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">'First article'</span>,</span><br><span class="line">    content: <span class="string">'Hello World!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    title: <span class="string">'Lorem ipsum'</span>,</span><br><span class="line">    content:</span><br><span class="line">      <span class="string">'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut hendrerit mauris ac porttitor accumsan. Nunc vitae pulvinar odio, auctor interdum dolor. Aenean sodales dui quis metus iaculis, hendrerit vulputate lorem vestibulum.'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    title: <span class="string">'Lorem ipsum in French'</span>,</span><br><span class="line">    content:</span><br><span class="line">      <span class="string">'J’en dis autant de ceux qui, par mollesse d’esprit, c’est-à-dire par la crainte de la peine et de la douleur, manquent aux devoirs de la vie. Et il est très facile de rendre raison de ce que j’avance.'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Origin, X-Requested-With, Content-Type, Accept'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/api/cars'</span>, jsonParser, (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cars = request.body;</span><br><span class="line">  response.send(<span class="string">`You sent me a list of cars: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cars)&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/animals'</span>, upload.array(), (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> name = request.body.name;</span><br><span class="line">  <span class="keyword">const</span> vote = request.body.strongest;</span><br><span class="line">  response.send(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, you voted: <span class="subst">$&#123;vote&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/tshirt'</span>);</span><br><span class="line">app.get(<span class="string">'/hello'</span>, (request, response) =&gt; &#123;</span><br><span class="line">  response.sendFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/views/hello.html`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/api/articles'</span>, (request, response) =&gt; &#123;</span><br><span class="line">  response.json(articles);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listener = app.listen(process.env.PORT || <span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Your app is listening on port <span class="subst">$&#123;listener.address().port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一直无法达成 <strong>自己发送请求给自建的服务器</strong> 的代码效果。然而，控制台一直在提示缺少东西…… 只要调换顺序就可以了…… 呵=。=<br>还不清楚 <code>use</code> 的意义是啥…… 被自己蠢到没心情记录了…… 就这样把……</p>
<p>又写了 <code>tshirt</code> 部分，然而，还是一头雾水了好久。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> travel = &#123;</span><br><span class="line">  name: <span class="string">'Sam'</span>,</span><br><span class="line">  countries: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'a'</span>, <span class="attr">year</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'b'</span>, <span class="attr">year</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'c'</span>, <span class="attr">year</span>: <span class="number">3</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Send data to the server</span></span><br><span class="line">fetch(<span class="string">'http://localhost:3000/api/countries'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(travel)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/api/countries'</span>, jsonParser, (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> travel = request.body;</span><br><span class="line">  <span class="built_in">console</span>.log(travel);</span><br><span class="line">  <span class="comment">// const travel = JSON.stringify(request.body);</span></span><br><span class="line">  <span class="comment">// const name = JSON.stringify(request.body).name;</span></span><br><span class="line">  <span class="comment">// let a = JSON.stringify(request.body);</span></span><br><span class="line">  <span class="comment">// let travel = JSON.parse(a);</span></span><br><span class="line">  <span class="comment">// console.log(travel);</span></span><br><span class="line">  <span class="comment">// const name = travel.name;</span></span><br><span class="line">  <span class="comment">// console.log(name);</span></span><br><span class="line">  <span class="comment">// const length = travel.countries.length;</span></span><br><span class="line">  response.send(</span><br><span class="line">    <span class="string">`Your name is <span class="subst">$&#123;travel.name&#125;</span> and you visited <span class="subst">$&#123;travel.countries.length&#125;</span> countries. Keep traveling!`</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一开始直接定义 <code>name</code> 与 <code>countries</code> 但是会未定义。不知道为啥，在 <code>JSON</code> 的类型上纠结了很久。原先的写法( <code>key</code> 不加双引号 并且 <code>travel</code> 被我写成了 <code>Array</code> )似乎是有问题的。疯狂的修改之后最终谜之通过…… =。=改日再说</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>New article</title>
    <url>/2018/12/16/New-article/</url>
    <content><![CDATA[<p>2018.12.16 16:04 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter23 Coding time <code>&lt;New article&gt;</code></p>
</blockquote>
<p>原题：</p>
<h1 id="New-article"><a href="#New-article" class="headerlink" title="New article"></a>New article</h1><p>Write the HTML code that shows input fields for creating a new blog article by entering its title and content.<br>Then, write the associated JavaScript code to send the article fields as form data to the URL <a href="https://thejsway-server.herokuapp.com/articles" target="_blank" rel="noopener">https://thejsway-server.herokuapp.com/articles</a>. You should receive a confirmation message from the server and display it on the page.</p>
<p><img src="/2018/12/16/New-article/image-20201013192424143.png" alt="image-20201013192424143"></p>
<p>W&gt; The server only accepts POST requests at this URL.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'form'</span>).addEventListener(<span class="string">'submit'</span>, e =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(e.target);</span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(e.target);</span><br><span class="line">  fetch(<span class="string">'https://thejsway-server.herokuapp.com/articles'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: formData</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).textContent = result;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>发现 <strong>1</strong> 个问题, <code>submit</code> 事件是绑定在 <code>form</code> 上而不是 <code>type</code> 为 <code>submit</code> 的按钮上。<br>=。=呵</p>
<h2 id="2018-12-17-0-50-更新"><a href="#2018-12-17-0-50-更新" class="headerlink" title="2018.12.17 0:50 更新"></a>2018.12.17 0:50 更新</h2><p>加上服务器部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'form'</span>).addEventListener(<span class="string">'submit'</span>, e =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(e.target);</span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(e.target);</span><br><span class="line">  fetch(<span class="string">'https://thejsway-server.herokuapp.com/articles'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: formData</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).textContent = result;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> articles = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">'First article'</span>,</span><br><span class="line">    content: <span class="string">'Hello World!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    title: <span class="string">'Lorem ipsum'</span>,</span><br><span class="line">    content:</span><br><span class="line">      <span class="string">'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut hendrerit mauris ac porttitor accumsan. Nunc vitae pulvinar odio, auctor interdum dolor. Aenean sodales dui quis metus iaculis, hendrerit vulputate lorem vestibulum.'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    title: <span class="string">'Lorem ipsum in French'</span>,</span><br><span class="line">    content:</span><br><span class="line">      <span class="string">'J’en dis autant de ceux qui, par mollesse d’esprit, c’est-à-dire par la crainte de la peine et de la douleur, manquent aux devoirs de la vie. Et il est très facile de rendre raison de ce que j’avance.'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/articles'</span>, upload.array(), (request, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newid = articles.length + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(request.body);</span><br><span class="line">  <span class="keyword">const</span> newtitle = request.body.title;</span><br><span class="line">  <span class="keyword">const</span> newcontent = request.body.content;</span><br><span class="line">  articles.push(&#123;</span><br><span class="line">    id: newid,</span><br><span class="line">    title: newtitle,</span><br><span class="line">    content: newcontent</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`New article added successfully with ID <span class="subst">$&#123;newid&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// response.send(`New article added successfully with ID $&#123;newid&#125;`);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>突然成功 d=====(￣▽￣*)b 开熏</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Github profile</title>
    <url>/2018/12/16/Github-profile/</url>
    <content><![CDATA[<p>2018.12.16 13:22 <strong>ES6学习中</strong><del>(似乎出现了爬虫(并不 )</del></p>
<blockquote>
<p>Thejsway/chapter22 Coding time <code>&lt;GitHub profile&gt;</code></p>
</blockquote>
<p>原题：</p>
<h1 id="GitHub-profile"><a href="#GitHub-profile" class="headerlink" title="GitHub profile"></a>GitHub profile</h1><p>The ubiquitous code sharing platform <a href="https://github.com" target="_blank" rel="noopener">GitHub</a> has a public API. The goal of this exercise is to display some information about a GitHub user, identified by his login. The API documentation is available <a href="https://developer.github.com/v3/users/" target="_blank" rel="noopener">here</a>.<br>Use this API to show the profile picture, name and website address of a GitHub user whose login is entered in a text box.</p>
<p><img src="/2018/12/16/Github-profile/image-20201013191407437.png" alt="image-20201013191407437"></p>
<p>You can test your code by using the GitHub logins of prominent JS community members like <code>brendaneich</code>  (JavaScript’s father),  <code>douglascrockford</code> or  <code>vjeux</code>  .<br>=。=好像有点难度。没有给什么提示，只给了官方教程(<del>然而并看不懂</del>)<br>于是百度<br>相关文章：<br><a href="https://www.jianshu.com/p/628a0747c492" target="_blank" rel="noopener">python爬取</a><br><a href="https://blog.csdn.net/qq_25537177/article/details/80528834" target="_blank" rel="noopener">貌似是js?</a><br>=。=费尽心思的我似乎写了出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> grabgithub = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">'https://api.github.com/users/'</span> + name)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// for(const auser of users)&#123;</span></span><br><span class="line">      <span class="comment">// name = name.replace(/\s+/g,"").toLowerCase();</span></span><br><span class="line">      <span class="comment">// const username = auser.login.replace(/\s+/g,"").toLowerCase();</span></span><br><span class="line">      <span class="comment">// console.log(username);</span></span><br><span class="line">      <span class="comment">// if(name === username)&#123;</span></span><br><span class="line">      <span class="comment">// createinfo(auser);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      createinfo(users);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createinfo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> incon = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  incon.src = user.avatar_url;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</span><br><span class="line">  name.textContent = user.name;</span><br><span class="line">  <span class="keyword">const</span> address = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  address.href = user.html_url;</span><br><span class="line">  address.textContent = user.html_url;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(incon);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(name);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(address);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'grabButton'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).childNodes;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> a <span class="keyword">of</span> div) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).removeChild(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>).value;</span><br><span class="line">  grabgithub(input);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注释部分为原代码，原先理解为在 <a href="https://api.github.com/users" target="_blank" rel="noopener">https://api.github.com/users</a> 查找信息，后来发现这个页面只有46个用户信息，仔细观察了一会儿 官方文档。发现应该是在 <a href="https://api.github.com/users/username" target="_blank" rel="noopener">https://api.github.com/users/username</a> 查找。于是修改代码。在特定页面读取信息。效果达成。获取地址部分应该是获取博客。未修改(=。=太懒)</p>
<p><img src="/2018/12/16/Github-profile/image-20201013191701861.png" alt="image-20201013191701861"></p>
<p><img src="/2018/12/16/Github-profile/image-20201013191709344.png" alt="image-20201013191709344"></p>
<p>想结束的我又发现了新问题=。=呵，为什么 <code>h1</code> 没有被删掉。。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'grabButton'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> divs = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).children);</span><br><span class="line">  <span class="keyword">if</span> (divs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).removeChild(divs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>).value;</span><br><span class="line">  grabgithub(input);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> grabgithub = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">'https://api.github.com/users/'</span> + name)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> &#123;</span><br><span class="line">      createinfo(users);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createinfo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> incon = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  incon.src = user.avatar_url;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</span><br><span class="line">  name.textContent = user.name;</span><br><span class="line">  <span class="keyword">const</span> address = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  address.href = user.blog;</span><br><span class="line">  address.textContent = user.blog;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(incon);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(name);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).appendChild(address);</span><br><span class="line">  divs = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.getElementById(<span class="string">'information'</span>).children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后死马当做活马医的我 将 <code>divs</code> 转化为 <code>Array</code> 然后就成功了=。=呵</p>
<h2 id="2020-年的回顾"><a href="#2020-年的回顾" class="headerlink" title="2020 年的回顾"></a>2020 年的回顾</h2><p>其实只是调取接口渲染函数的任务，没有我当时想的那么复杂，只是那个时候我还理解不了这些东西。</p>
<p>看了一下最后出现的那个移除子元素出错的地方，应该是因为获取了子元素类数组，然后迭代它，但是我又在删除它，起了冲突。</p>
<p>删除子元素比较简单的方法可以直接将父元素的 <code>innerHTML</code> 设置为空。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectASocialNewsWebPage</title>
    <url>/2018/12/15/ProjectASocialNewsWebPage/</url>
    <content><![CDATA[<p>2018.12.15 20:42 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter19 <code>&lt;Project: a social news web page&gt;</code></p>
</blockquote>
<p>原题：</p>
<h1 id="Project-a-social-news-web-page"><a href="#Project-a-social-news-web-page" class="headerlink" title="Project: a social news web page"></a>Project: a social news web page</h1><p>You know now enough JavaScript and DOM to go ahead and create interactive web pages for real!</p>
<h2 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h2><p>This project builds upon the social news program you created previously. This time, the objective is to make a social news web page.<br>The general idea and page layout for this project are inspired by the <a href="https://www.discovermeteor.com/" target="_blank" rel="noopener">Discover Meteor book</a>‘s example application.</p>
<h2 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h2><ul>
<li>A link is defined by its title, its URL and its author (submitter).</li>
<li>If a new link URL does not start with “http://“ or “https://“, “http://“ is automatically added at its beginning.</li>
<li>The web page displays a list of at least three already existing links.</li>
<li>A button exists for the user to submit a new link. When clicked, a form appears before the link list to input the new link properties (author, title and URL).</li>
<li>In this form, all link fields are mandatory.</li>
<li>When the new link is validated by the user, it is displayed at the top of the link list, replacing the form. A message indicates the success of the operation, then disappears after two seconds.</li>
</ul>
<h2 id="Technical-requirements"><a href="#Technical-requirements" class="headerlink" title="Technical requirements"></a>Technical requirements</h2><ul>
<li><p>You should reuse any useful code from the previous project.</p>
</li>
<li><p>All your code should be correctly indented.</p>
</li>
<li><p>Names should be wisely chosen and adhere to the camelCase convention.</p>
</li>
<li><p>Code duplication should be avoided.</p>
</li>
</ul>
<h2 id="Starter-code"><a href="#Starter-code" class="headerlink" title="Starter code"></a>Starter code</h2><p>Because this is first and foremost a JavaScript project, here is the complete HTML/CSS code of the web page. It is also online as a <a href="https://codepen.io/bpesquet/pen/pPyxLG/" target="_blank" rel="noopener">CodePen</a>.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My web page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 最新编译和缩小CSS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./css/first.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>A social news web page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle collapsed"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">data-target</span>=<span class="string">"#bs-example-navbar-collapse-1"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-link"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> PubLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"bs-example-navbar-collapse-1"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"submitButton"</span> <span class="attr">class</span>=<span class="string">"btn btn-default navbar-btn"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"navbar-text navbar-right"</span>&gt;</span>A social news web page built with ❤ and JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 存放动态内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery（Bootstrap的JavaScript插件所必需的）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包含所有已编译的插件(如下)，或者根据需要包含单个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.5px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#afaeae</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inputbutton</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(208, 62%, 40%);</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Main link element (&lt;div&gt; tag) */</span></span><br><span class="line"><span class="selector-class">.link</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Link title (&lt;a&gt; tag) */</span></span><br><span class="line"><span class="selector-class">.linkTitle</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#428bca</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.linkTitle</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Link URL (&lt;span&gt; tag) */</span></span><br><span class="line"><span class="selector-class">.linkUrl</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Link headline containing title &amp; URL (&lt;h4&gt; tag) */</span></span><br><span class="line"><span class="selector-class">.linkHeadline</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Link author (&lt;span&gt; tag) */</span></span><br><span class="line"><span class="selector-class">.linkAuthor</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.linkForm</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码做了适当更改。</p>
<h2 id="Expected-result"><a href="#Expected-result" class="headerlink" title="Expected result"></a>Expected result</h2><p><img src="/2018/12/15/ProjectASocialNewsWebPage/image-20201013190336868.png" alt="image-20201013190336868"></p>
<p><img src="/2018/12/15/ProjectASocialNewsWebPage/image-20201013190344372.png" alt="image-20201013190344372"></p>
<p><img src="/2018/12/15/ProjectASocialNewsWebPage/image-20201013190352014.png" alt="image-20201013190352014"></p>
<p><img src="/2018/12/15/ProjectASocialNewsWebPage/image-20201013190356227.png" alt="image-20201013190356227"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1-编写函数-createlink-用于创建链接"><a href="#1-编写函数-createlink-用于创建链接" class="headerlink" title="1.编写函数  createlink()  用于创建链接"></a>1.编写函数  <code>createlink()</code>  用于创建链接</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createlink = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> linkform = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">  linkform.className = <span class="string">'linkForm'</span>;</span><br><span class="line">  <span class="keyword">const</span> input1 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input2 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input3 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input4 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  input1.style.width = <span class="string">'250px'</span>;</span><br><span class="line">  input2.style.width = <span class="string">'450px'</span>;</span><br><span class="line">  input3.style.width = <span class="string">'300px'</span>;</span><br><span class="line">  input4.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  input1.type = <span class="string">'text'</span>;</span><br><span class="line">  input2.type = <span class="string">'text'</span>;</span><br><span class="line">  input3.type = <span class="string">'text'</span>;</span><br><span class="line">  input4.type = <span class="string">'submit'</span>;</span><br><span class="line">  input4.id = <span class="string">'inputbutton'</span>;</span><br><span class="line">  input4.value = <span class="string">'Add link'</span>;</span><br><span class="line">  linkform.appendChild(input1);</span><br><span class="line">  linkform.appendChild(input2);</span><br><span class="line">  linkform.appendChild(input3);</span><br><span class="line">  linkform.appendChild(input4);</span><br><span class="line">  <span class="comment">// const count = document.getElementsByClassName("link");</span></span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(linkform, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'submitButton'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>);</span><br><span class="line">  <span class="keyword">if</span> (form.length === <span class="number">0</span>) &#123;</span><br><span class="line">    createlink();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener()</code> 中的函数部分若加上括号，则直接调用该函数。体现在该网页上则是不用点击 <code>submit</code> 按钮就出现了创建链接的列表。部分初始化过程过于繁琐。有因未验证是否存在表单而导致多次点击按钮的情况下会出现多个表单。</p>
<h4 id="2-文档加载过程中创建三个现有链接"><a href="#2-文档加载过程中创建三个现有链接" class="headerlink" title="2.文档加载过程中创建三个现有链接"></a>2.文档加载过程中创建三个现有链接</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> links = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Hacker News'</span>,</span><br><span class="line">    url: <span class="string">'http://news.ycombinator.com'</span>,</span><br><span class="line">    author: <span class="string">'Baptiste'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Reddit'</span>,</span><br><span class="line">    url: <span class="string">'http://reddit.com'</span>,</span><br><span class="line">    author: <span class="string">'Thomas'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Boing Boing'</span>,</span><br><span class="line">    url: <span class="string">'http://bolingboling.net'</span>,</span><br><span class="line">    author: <span class="string">'Daniel'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    <span class="keyword">const</span> linkb = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    <span class="keyword">const</span> linkheadling = <span class="built_in">document</span>.createElement(<span class="string">'h4'</span>);</span><br><span class="line">    <span class="keyword">const</span> linktitle = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">const</span> linkurl = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">    <span class="keyword">const</span> linkauthor = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">    linkb.className = <span class="string">'link'</span>;</span><br><span class="line">    linkheadling.className = <span class="string">'linkHeadline'</span>;</span><br><span class="line">    linktitle.className = <span class="string">'linkTitle'</span>;</span><br><span class="line">    linkurl.className = <span class="string">'linkUrl'</span>;</span><br><span class="line">    linkauthor.className = <span class="string">'linkAuthor'</span>;</span><br><span class="line">    linktitle.textContent = link.title;</span><br><span class="line">    linktitle.href = link.url;</span><br><span class="line">    linkurl.textContent = link.url;</span><br><span class="line">    linkauthor.textContent = <span class="string">'Submitted by '</span> + link.author;</span><br><span class="line">    linkheadling.appendChild(linktitle);</span><br><span class="line">    linkheadling.appendChild(linkurl);</span><br><span class="line">    linkb.appendChild(linkheadling);</span><br><span class="line">    linkb.appendChild(linkauthor);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(linkb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有粗心忘了加外包的 <code>div</code> 盒子</p>
<h4 id="3-编写成功创建链接部分"><a href="#3-编写成功创建链接部分" class="headerlink" title="3.编写成功创建链接部分"></a>3.编写成功创建链接部分</h4><blockquote>
<p>对上面代码进行部分改写</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> links = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Hacker News'</span>,</span><br><span class="line">    url: <span class="string">'http://news.ycombinator.com'</span>,</span><br><span class="line">    author: <span class="string">'Baptiste'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Reddit'</span>,</span><br><span class="line">    url: <span class="string">'http://reddit.com'</span>,</span><br><span class="line">    author: <span class="string">'Thomas'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Boing Boing'</span>,</span><br><span class="line">    url: <span class="string">'http://bolingboling.net'</span>,</span><br><span class="line">    author: <span class="string">'Daniel'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createmenu</span>(<span class="params">link</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> linkb = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkheadling = <span class="built_in">document</span>.createElement(<span class="string">'h4'</span>);</span><br><span class="line">  <span class="keyword">const</span> linktitle = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkurl = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkauthor = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  linkb.className = <span class="string">'link'</span>;</span><br><span class="line">  linkheadling.className = <span class="string">'linkHeadline'</span>;</span><br><span class="line">  linktitle.className = <span class="string">'linkTitle'</span>;</span><br><span class="line">  linkurl.className = <span class="string">'linkUrl'</span>;</span><br><span class="line">  linkauthor.className = <span class="string">'linkAuthor'</span>;</span><br><span class="line">  linktitle.textContent = link.title;</span><br><span class="line">  linktitle.href = link.url;</span><br><span class="line">  linkurl.textContent = link.url;</span><br><span class="line">  linkauthor.textContent = <span class="string">'Submitted by '</span> + link.author;</span><br><span class="line">  linkheadling.appendChild(linktitle);</span><br><span class="line">  linkheadling.appendChild(linkurl);</span><br><span class="line">  linkb.appendChild(linkheadling);</span><br><span class="line">  linkb.appendChild(linkauthor);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).appendChild(linkb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    createmenu(link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createsucceed</span>(<span class="params">link</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> box = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  box.classname = <span class="string">'succeed'</span>;</span><br><span class="line">  box.textContent = <span class="string">`The link <span class="subst">$&#123;link.title&#125;</span> has been succesfully added!`</span>;</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(box, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">  createmenu(link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createlink = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> linkform = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">  linkform.className = <span class="string">'linkForm'</span>;</span><br><span class="line">  <span class="keyword">const</span> input1 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input2 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input3 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input4 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  input1.style.width = <span class="string">'250px'</span>;</span><br><span class="line">  input2.style.width = <span class="string">'450px'</span>;</span><br><span class="line">  input3.style.width = <span class="string">'300px'</span>;</span><br><span class="line">  input4.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  input1.type = <span class="string">'text'</span>;</span><br><span class="line">  input2.type = <span class="string">'text'</span>;</span><br><span class="line">  input3.type = <span class="string">'text'</span>;</span><br><span class="line">  input4.type = <span class="string">'submit'</span>;</span><br><span class="line">  input4.id = <span class="string">'inputbutton'</span>;</span><br><span class="line">  input4.value = <span class="string">'Add link'</span>;</span><br><span class="line">  input4.addEventListener(<span class="string">'submit'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> inputs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(inputs[<span class="number">1</span>].value.startsWith(<span class="string">'http://'</span>) || inputs[<span class="number">1</span>].value.startsWith(<span class="string">'https://'</span>))) &#123;</span><br><span class="line">      inputs[i].value = <span class="string">'http://'</span> + inputs[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> link = &#123;</span><br><span class="line">      title: input[<span class="number">0</span>].value,</span><br><span class="line">      url: inputs[<span class="number">1</span>].value,</span><br><span class="line">      author: inputs[<span class="number">2</span>].value</span><br><span class="line">    &#125;;</span><br><span class="line">    links.push(link);</span><br><span class="line">    createsucceed(link);</span><br><span class="line">  &#125;);</span><br><span class="line">  linkform.appendChild(input1);</span><br><span class="line">  linkform.appendChild(input2);</span><br><span class="line">  linkform.appendChild(input3);</span><br><span class="line">  linkform.appendChild(input4);</span><br><span class="line">  <span class="comment">// const count = document.getElementsByClassName("link");</span></span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(linkform, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'submitButton'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>);</span><br><span class="line">  <span class="keyword">if</span> (form.length === <span class="number">0</span>) &#123;</span><br><span class="line">    createlink();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>问题：无法出现成功提交的界面。并且新建的链接也不会显示。<br>将 <code>input4</code> 的 <code>addEventListener()</code> 事件更改为click 并阻止 <code>submit</code> 的默认行为 即可出现提示并创建新链接。新问题：提示的效果未达成，表单如何消失。</p>
<p>部分代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formdata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!(inputs[<span class="number">1</span>].value.startsWith(<span class="string">'http://'</span>) || inputs[<span class="number">1</span>].value.startsWith(<span class="string">'https://'</span>))) &#123;</span><br><span class="line">    inputs[<span class="number">1</span>].value = <span class="string">'http://'</span> + inputs[<span class="number">1</span>].value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> alink = &#123;</span><br><span class="line">    title: inputs[<span class="number">0</span>].value,</span><br><span class="line">    url: inputs[<span class="number">1</span>].value,</span><br><span class="line">    author: inputs[<span class="number">2</span>].value</span><br><span class="line">  &#125;;</span><br><span class="line">  links.push(alink);</span><br><span class="line">  createsucceed(alink);</span><br><span class="line">&#125;</span><br><span class="line">input4.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  formdata();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-编写两秒钟后提示的消失部分"><a href="#4-编写两秒钟后提示的消失部分" class="headerlink" title="4.编写两秒钟后提示的消失部分"></a>4.编写两秒钟后提示的消失部分</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> links = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Boing Boing'</span>,</span><br><span class="line">    url: <span class="string">'http://bolingboling.net'</span>,</span><br><span class="line">    author: <span class="string">'Daniel'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Reddit'</span>,</span><br><span class="line">    url: <span class="string">'http://reddit.com'</span>,</span><br><span class="line">    author: <span class="string">'Thomas'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Hacker News'</span>,</span><br><span class="line">    url: <span class="string">'http://news.ycombinator.com'</span>,</span><br><span class="line">    author: <span class="string">'Baptiste'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createmenu</span>(<span class="params">link</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> linkb = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkheadling = <span class="built_in">document</span>.createElement(<span class="string">'h4'</span>);</span><br><span class="line">  <span class="keyword">const</span> linktitle = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkurl = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  <span class="keyword">const</span> linkauthor = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  linkb.className = <span class="string">'link'</span>;</span><br><span class="line">  linkheadling.className = <span class="string">'linkHeadline'</span>;</span><br><span class="line">  linktitle.className = <span class="string">'linkTitle'</span>;</span><br><span class="line">  linkurl.className = <span class="string">'linkUrl'</span>;</span><br><span class="line">  linkauthor.className = <span class="string">'linkAuthor'</span>;</span><br><span class="line">  linktitle.textContent = link.title;</span><br><span class="line">  linktitle.href = link.url;</span><br><span class="line">  linkurl.textContent = link.url;</span><br><span class="line">  linkauthor.textContent = <span class="string">'Submitted by '</span> + link.author;</span><br><span class="line">  linkheadling.appendChild(linktitle);</span><br><span class="line">  linkheadling.appendChild(linkurl);</span><br><span class="line">  linkb.appendChild(linkheadling);</span><br><span class="line">  linkb.appendChild(linkauthor);</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(linkb, <span class="built_in">document</span>.getElementsByClassName(<span class="string">'link'</span>)[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    createmenu(link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createsucceed</span>(<span class="params">link</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> box = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">const</span> pa = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">  box.id = <span class="string">'succeed'</span>;</span><br><span class="line">  pa.textContent = <span class="string">`The link <span class="subst">$&#123;link.title&#125;</span> has been succesfully added!`</span>;</span><br><span class="line">  box.appendChild(pa);</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(box, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">  createmenu(link);</span><br><span class="line">  <span class="keyword">const</span> linkform = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'linkForm'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).removeChild(linkform);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> it = <span class="built_in">document</span>.getElementById(<span class="string">'succeed'</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).removeChild(it);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formdata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!(inputs[<span class="number">1</span>].value.startsWith(<span class="string">'http://'</span>) || inputs[<span class="number">1</span>].value.startsWith(<span class="string">'https://'</span>))) &#123;</span><br><span class="line">    inputs[<span class="number">1</span>].value = <span class="string">'http://'</span> + inputs[<span class="number">1</span>].value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> alink = &#123;</span><br><span class="line">    title: inputs[<span class="number">0</span>].value,</span><br><span class="line">    url: inputs[<span class="number">1</span>].value,</span><br><span class="line">    author: inputs[<span class="number">2</span>].value</span><br><span class="line">  &#125;;</span><br><span class="line">  links.push(alink);</span><br><span class="line">  createsucceed(alink);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createlink = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> linkform = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">  linkform.className = <span class="string">'linkForm'</span>;</span><br><span class="line">  <span class="keyword">const</span> input1 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input2 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input3 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  <span class="keyword">const</span> input4 = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">  input1.style.width = <span class="string">'250px'</span>;</span><br><span class="line">  input2.style.width = <span class="string">'450px'</span>;</span><br><span class="line">  input3.style.width = <span class="string">'300px'</span>;</span><br><span class="line">  input4.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  input1.type = <span class="string">'text'</span>;</span><br><span class="line">  input2.type = <span class="string">'text'</span>;</span><br><span class="line">  input3.type = <span class="string">'text'</span>;</span><br><span class="line">  input4.type = <span class="string">'submit'</span>;</span><br><span class="line">  input4.id = <span class="string">'inputbutton'</span>;</span><br><span class="line">  input4.value = <span class="string">'Add link'</span>;</span><br><span class="line">  input4.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    formdata();</span><br><span class="line">  &#125;);</span><br><span class="line">  linkform.appendChild(input1);</span><br><span class="line">  linkform.appendChild(input2);</span><br><span class="line">  linkform.appendChild(input3);</span><br><span class="line">  linkform.appendChild(input4);</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">    .getElementById(<span class="string">'content'</span>)</span><br><span class="line">    .insertBefore(linkform, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'submitButton'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>);</span><br><span class="line">  <span class="keyword">if</span> (form.length === <span class="number">0</span>) &#123;</span><br><span class="line">    createlink();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果基本实现。遗留问题：部分代码重复且繁琐，但不知如何抽象出来。初始化页面所需时间太久，不知如何优化 =。=<br>勉强算完成 =。= (主要是累了)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>start and stop</title>
    <url>/2018/12/15/start-and-stop/</url>
    <content><![CDATA[<p>2018.12.15 18:04 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter18 Coding time <code>&lt;Bouncing ball&gt;``(&lt;Chronometer&gt;)</code></p>
</blockquote>
<p>原题：</p>
<h1 id="Bouncing-ball"><a href="#Bouncing-ball" class="headerlink" title="Bouncing ball"></a>Bouncing ball</h1><p>The goal of this exercise is to make a basketball bounce across the screen. You can download the ball image <a href="https://raw.githubusercontent.com/bpesquet/thejsway/master/resources/basketball.jpg" target="_blank" rel="noopener">here</a>.<br>Start with the following HTML and CSS content.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"stop"</span> <span class="attr">disabled</span>&gt;</span>Stop<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Update the "src" attribute if you downloaded the image locally --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"ball"</span> <span class="attr">src</span>=<span class="string">"https://raw.githubusercontent.com/bpesquet/thejsway/master/resources/basketball.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ball</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">111px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Write the JavaScript code that makes the ball bounce horizontally.</p>
<p><img src="/2018/12/15/start-and-stop/image-20201013185155126.png" alt="image-20201013184742806"></p>
<p>With your solution, create a variable with values 1 or -1 that dictates the direction in which the ball should move.</p>
<p>与开始和停止计时类似。<br>出现问题：<br><strong>1.无法停止动画。</strong><br>(似乎是因为 <code>balljump()</code> 内部带有 <code>requestAnimationFrame()</code> 而重复启用。<br>改进代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balljump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weizhi = <span class="built_in">parseFloat</span>(getComputedStyle(ball).top);</span><br><span class="line">  <span class="keyword">if</span> (weizhi + ballheight &gt;= <span class="number">300</span> || weizhi &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    movement = -movement;</span><br><span class="line">  &#125;</span><br><span class="line">  ball.style.top = weizhi + movement + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">let</span> a = requestAnimationFrame(balljump);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尝试在 <code>balljump()</code> 调用时显示函数编号 结果为</p>
<p><img src="/2018/12/15/start-and-stop/image-20201013184956322.png" alt="image-20201013184742806"></p>
<p>故 <code>balljump()</code> 内部多次调用该函数 无法停止<br><strong>2.多次点击开始会多次累加  <code>requestAnimationFrame()</code>  而导致动画速度加快。</strong><br><strong>3.</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balljump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weizhi = <span class="built_in">parseFloat</span>(getComputedStyle(ball).top);</span><br><span class="line">  <span class="keyword">if</span> (weizhi + ballheight &gt;= <span class="number">300</span> || weizhi &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    movement = -movement;</span><br><span class="line">  &#125;</span><br><span class="line">  ball.style.top = weizhi + movement + <span class="string">'px'</span>;</span><br><span class="line">  requestAnimationFrame(balljump);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> animationId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> movement = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ball = <span class="built_in">document</span>.getElementById(<span class="string">'ball'</span>);</span><br><span class="line"><span class="keyword">const</span> ballheight = <span class="built_in">parseFloat</span>(getComputedStyle(ball).height);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (animationId === <span class="number">0</span>) &#123;</span><br><span class="line">    animationId = requestAnimationFrame(balljump);</span><br><span class="line">  &#125;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  cancelAnimationFrame(animationId);</span><br><span class="line">  animationId = <span class="number">0</span>;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>出现了打开即两个按钮都启用的状态。原因未知。<br>(似乎文件出了问题。注释掉所有的js代码依然两个按钮都启用，重开文件后解决)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balljump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weizhi = <span class="built_in">parseFloat</span>(getComputedStyle(ball).top);</span><br><span class="line">  <span class="keyword">if</span> (weizhi + ballheight &gt;= <span class="number">300</span> || weizhi &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    movement = -movement;</span><br><span class="line">  &#125;</span><br><span class="line">  ball.style.top = weizhi + movement + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (tostart != <span class="number">0</span> || tostop != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tostart === <span class="number">1</span>) &#123;</span><br><span class="line">      tostart = <span class="number">0</span>;</span><br><span class="line">      animationId = requestAnimationFrame(balljump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tostop === <span class="number">1</span>) &#123;</span><br><span class="line">      tostop = <span class="number">0</span>;</span><br><span class="line">      cancelAnimationFrame(balljump);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    requestAnimationFrame(balljump);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tostart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> tostop = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> animationId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> movement = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ball = <span class="built_in">document</span>.getElementById(<span class="string">'ball'</span>);</span><br><span class="line"><span class="keyword">const</span> ballheight = <span class="built_in">parseFloat</span>(getComputedStyle(ball).height);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  tostart = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (animationId === <span class="number">0</span>) &#123;</span><br><span class="line">    animationId = requestAnimationFrame(balljump);</span><br><span class="line">  &#125;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  tostop = <span class="number">1</span>;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>尝试改写，添加  <code>tostop</code>、<code>tostart</code>  变量来判断，将继续动画与停止动画判断放在了 <code>balljump()</code> 函数中。<br>结果：可以停止动画，但无法二次启动动画。原因未知。<br>在 <code>cancelAnimationFrame()</code> 函数之后重置 <code>animationId</code> 为 <code>0</code> 即可解决。</p>
<p>最终代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balljump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weizhi = <span class="built_in">parseFloat</span>(getComputedStyle(ball).top);</span><br><span class="line">  <span class="keyword">if</span> (weizhi + ballheight &gt;= <span class="number">300</span> || weizhi &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    movement = -movement;</span><br><span class="line">  &#125;</span><br><span class="line">  ball.style.top = weizhi + movement + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (tostart != <span class="number">0</span> || tostop != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tostart === <span class="number">1</span>) &#123;</span><br><span class="line">      tostart = <span class="number">0</span>;</span><br><span class="line">      animationId = requestAnimationFrame(balljump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tostop === <span class="number">1</span>) &#123;</span><br><span class="line">      tostop = <span class="number">0</span>;</span><br><span class="line">      cancelAnimationFrame(balljump);</span><br><span class="line">      animationId = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    requestAnimationFrame(balljump);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tostart = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> tostop = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> animationId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> movement = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ball = <span class="built_in">document</span>.getElementById(<span class="string">'ball'</span>);</span><br><span class="line"><span class="keyword">const</span> ballheight = <span class="built_in">parseFloat</span>(getComputedStyle(ball).height);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  tostart = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (animationId === <span class="number">0</span>) &#123;</span><br><span class="line">    animationId = requestAnimationFrame(balljump);</span><br><span class="line">  &#125;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'stop'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  tostop = <span class="number">1</span>;</span><br><span class="line">  e.target.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果基本实现。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>click blur 执行顺序问题</title>
    <url>/2018/12/15/click-blur-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>2018.12.15 15:27 <strong>ES6学习中</strong></p>
<blockquote>
<p>Thejsway/chapter17 Coding time <code>&lt;Autocomplete&gt;</code></p>
</blockquote>
<p>原题：</p>
<h1 id="Autocomplete"><a href="#Autocomplete" class="headerlink" title="Autocomplete"></a>Autocomplete</h1><p>In this exercise, you’ll have to assist the user in selecting a country. As he enters the country name in an input box, the page shows a list of corresponding countries. Clicking on a suggested country replaces the value in the input box.</p>
<blockquote>
<p>To keep things simple, only countries starting with a “A” letter are taken into account.</p>
</blockquote>
<p>Here is the HTML code that creates the input box.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"country"</span>&gt;</span>Enter a country name<span class="tag">&lt;/<span class="name">label</span>&gt;</span>:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"country"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"suggestions"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The following CSS code improves the page presentation.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add spacing between each country suggestion */</span></span><br><span class="line"><span class="selector-class">.suggestion</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Change suggestion color when hovering it with the mouse */</span></span><br><span class="line"><span class="selector-class">.suggestion</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#adf</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Position the suggestion list just below the input box */</span></span><br><span class="line"><span class="selector-id">#suggestions</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">180px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">145px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Complete this code to implement country autocompletion.</p>
<p><a href="https://github.com/bpesquet/thejsway/blob/master/manuscript/images/chapter17-12.png" target="_blank" rel="noopener"><img src="/2018/12/15/click-blur-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/wps2.jpg" alt="img"></a></p>
<p>我的js代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countryList = [</span><br><span class="line">  <span class="string">"Afghanistan"</span>,</span><br><span class="line">  <span class="string">"Albania"</span>,</span><br><span class="line">  <span class="string">"Algeria"</span>,</span><br><span class="line">  <span class="string">"Andorra"</span>,</span><br><span class="line">  <span class="string">"Angola"</span>,</span><br><span class="line">  <span class="string">"Anguilla"</span>,</span><br><span class="line">  <span class="string">"Antarctica"</span>,</span><br><span class="line">  <span class="string">"Antigua-and-Barbuda"</span>,</span><br><span class="line">  <span class="string">"Argentina"</span>,</span><br><span class="line">  <span class="string">"Armenia"</span>,</span><br><span class="line">  <span class="string">"Aruba"</span>,</span><br><span class="line">  <span class="string">"Australia"</span>,</span><br><span class="line">  <span class="string">"Autria"</span>,</span><br><span class="line">  <span class="string">"Azerbaïjan"</span></span><br><span class="line">];</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).style.display = <span class="string">"none"</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> some <span class="keyword">of</span> countryList)&#123;</span><br><span class="line">    <span class="keyword">const</span> newli = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    newli.textContent = some;</span><br><span class="line">    newli.style.listStyle = <span class="string">"none"</span>;</span><br><span class="line">    newli.style.display = <span class="string">"none"</span>;</span><br><span class="line">    newli.className = <span class="string">"suggestion"</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).appendChild(newli);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).addEventListener(<span class="string">"click"</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> neirong = e.target.textContent;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"country"</span>).value = neirong;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).style.display = <span class="string">"none"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"country"</span>).addEventListener(<span class="string">"input"</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).style.display = <span class="string">"block"</span>;</span><br><span class="line">  <span class="keyword">const</span> input = e.target.value;</span><br><span class="line">  <span class="keyword">const</span> lists = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> one <span class="keyword">of</span> lists)&#123;</span><br><span class="line">    <span class="keyword">if</span>(one.textContent.startsWith(input))&#123;</span><br><span class="line">      one.style.display = <span class="string">"block"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      one.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"country"</span>).addEventListener(<span class="string">"blur"</span>, e =&gt; &#123;</span><br><span class="line">  setTimeout(nonefun, <span class="string">"100"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonefun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"suggestions"</span>).style.display = <span class="string">"none"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果基本实现，发现click 与blur存在顺序问题，若不设置延时，则click效果无法实现。<br>Click后执行而无法实现效果的原因暂时不知。<br>看到一篇相关文章: <a href="https://www.jb51.net/article/112086.htm" target="_blank" rel="noopener">传送门</a></p>
<h2 id="2020年的回顾"><a href="#2020年的回顾" class="headerlink" title="2020年的回顾"></a>2020年的回顾</h2><p>代码好像已经找不到了，尝试直接复现一下。不知道是不是漏了什么，笔记中的代码无法实现需要的效果。</p>
<p>仔细看了看，是我输错了关键词……</p>
<p>看了一下当时遇到的问题，其实最近也遇到了一次。</p>
<p>当时的情况是 <code>A</code>  元素绑定了一个点击事件，需要对点击做出响应，而 <code>B</code> 元素(往往是与该元素相关联的元素)又会响应 <code>blur</code> 事件，在响应 <code>blur</code> 的时候会隐藏 <code>A</code> 元素。</p>
<p>而点击 <code>A</code>元素就是 <code>B</code> 元素的 <code>blur</code> 事件，于是在 <code>A</code> 元素响应点击之前，就已经被隐藏了。</p>
<p>因此我们需要在触发 <code>blur</code> 的地方延迟隐藏，让它可以先响应 <code>click</code> 事件。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>notes</tag>
      </tags>
  </entry>
</search>
