<!DOCTYPE html>
<html lang="en">
  <head>
    <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    name="viewport"
  />
  <title>Drowning me></title>
  <link rel="stylesheet" href="/css/style.css">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

  </head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Drowning me</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
      <li class="menu-item">
        <a href="/" class="menu-item-link"
          >home</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/categories" class="menu-item-link"
          >categories</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/tags" class="menu-item-link"
          >tags</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/archives" class="menu-item-link"
          >archives</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/about" class="menu-item-link"
          >about</a
        >
      </li>
      
    </ul>
  </nav>
</header>
 <article class="post">
    <div class="post-title">
        <h2 class="title">学习笔记 2020 11 20</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-11-20</span>
    </div>
    <div class="post-content">
        <h1 id="学习笔记-2020-11-20"><a href="#学习笔记-2020-11-20" class="headerlink" title="学习笔记 2020-11-20"></a>学习笔记 2020-11-20</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h4><h5 id="DOM-事件模拟"><a href="#DOM-事件模拟" class="headerlink" title="DOM 事件模拟"></a>DOM 事件模拟</h5><p>createEvent( eventType: string ) =&gt; event: object</p>
<ol>
<li><p>模拟键盘事件</p>
<ul>
<li>eventType: “MouseEvent”</li>
<li>event.initMouseEvent()</li>
</ul>
</li>
<li><p>模拟键盘事件</p>
<ul>
<li>eventType: “KeyboardEvent”</li>
<li>event.initKeyboardEvent()</li>
<li>event createEvent(“Events”)</li>
<li>event.initEvent()</li>
</ul>
</li>
<li><p>模拟其他事件</p>
<ul>
<li>eventType: “HTMLEvents”</li>
<li>event.initEvent()</li>
</ul>
</li>
<li><p>自定义 DOM 事件</p>
<ul>
<li><p>eventType: “CustomEvents”</p>
</li>
<li><p>event.initCustomEvent()</p>
</li>
</ul>
</li>
</ol>
<h5 id="IE-事件模拟"><a href="#IE-事件模拟" class="headerlink" title="IE 事件模拟"></a>IE 事件模拟</h5><ul>
<li>createEventObject() =&gt; event: object</li>
<li>fireEvent( name:string, event: object)</li>
</ul>
<h3 id="动画与-Canvas-图形"><a href="#动画与-Canvas-图形" class="headerlink" title="动画与 Canvas 图形"></a>动画与 Canvas 图形</h3><h4 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h4><p>该方法让浏览器通过最优方式确定重绘的时序。</p>
<h5 id="早期定时动画"><a href="#早期定时动画" class="headerlink" title="早期定时动画"></a>早期定时动画</h5><p>一般计算机显示器的屏幕刷新率都是 60Hz，意味着每秒需要重绘 60 次。实现平滑动画最佳的重绘间隔为 1000 毫秒 / 60，大约 17 毫秒。</p>
<h5 id="时间间隔的问题"><a href="#时间间隔的问题" class="headerlink" title="时间间隔的问题"></a>时间间隔的问题</h5><p>知道何时绘制下一帧是创造平滑动画的关键。浏览器自身计时器存在精度问题。</p>
<h5 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h5><p>接收一个参数，一个 DOMHighResTimeStamp 的实例。表示下次重绘的时间。</p>
<h5 id="cancelAnimationFrame"><a href="#cancelAnimationFrame" class="headerlink" title="cancelAnimationFrame"></a>cancelAnimationFrame</h5><h5 id="通过-requestAnimationFrame-节流"><a href="#通过-requestAnimationFrame-节流" class="headerlink" title="通过 requestAnimationFrame 节流"></a>通过 requestAnimationFrame 节流</h5><p>调用该方法会将回调函数推入一个重绘之前调用的钩子队列中，可用于节流。</p>
<h4 id="基本的画布功能"><a href="#基本的画布功能" class="headerlink" title="基本的画布功能"></a>基本的画布功能</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>drawing<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  A drawing of something
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'drawing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 确保浏览器支持&lt;canvas></span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 其他代码</span>
<span class="token punctuation">}</span></code></pre>
<p>可以通过 <code>toDataURL()</code> 方法导出 <code>&lt;canvas&gt;</code> 元素上的图像。接收参数，要生成图像的 MIME 类型。</p>
<h4 id="2D-绘图上下文"><a href="#2D-绘图上下文" class="headerlink" title="2D 绘图上下文"></a>2D 绘图上下文</h4><p>2D 上下文的坐标原点位于画布左上角。</p>
<h5 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h5><ul>
<li>fillStyle</li>
<li>strokeStyle</li>
</ul>
<p>这两个属性可以是字符串、渐变对象或图案对象。</p>
<h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><h3 id="装饰器模式和转发，call-apply"><a href="#装饰器模式和转发，call-apply" class="headerlink" title="装饰器模式和转发，call/apply"></a>装饰器模式和转发，call/apply</h3><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol>
<li><p>间谍装饰器</p>
<p>创建一个装饰器 <code>spy(func)</code>，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 <code>calls</code> 属性中。</p>
<p>每个调用都保存为一个参数数组。</p>
<p>例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">work</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// work 是一个任意的函数或方法</span>
<span class="token punctuation">}</span>

work <span class="token operator">=</span> <span class="token function">spy</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">work</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>
<span class="token function">work</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 9</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> args <span class="token keyword">of</span> work<span class="token punctuation">.</span>calls<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">'call:'</span> <span class="token operator">+</span> args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "call:1,2", "call:4,5"</span>
<span class="token punctuation">}</span></code></pre>
<p>P.S. 该装饰器有时对于单元测试很有用。它的高级形式是 <a href="http://sinonjs.org/" target="_blank" rel="noopener">Sinon.JS</a> 库中的 <code>sinon.spy</code>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">spy</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">it</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    it<span class="token punctuation">.</span>calls<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  it<span class="token punctuation">.</span>calls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> it<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>延时装饰器</p>
<p>创建一个装饰器 <code>delay(f, ms)</code>，该装饰器将 <code>f</code> 的每次调用延时 <code>ms</code> 毫秒。</p>
<p>例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// create wrappers</span>
<span class="token keyword">let</span> f1000 <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> f1500 <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f1000</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在 1000ms 后显示 "test"</span>
<span class="token function">f1500</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在 1500ms 后显示 "test"</span></code></pre>
<p>换句话说，<code>delay(f, ms)</code> 返回的是延迟 <code>ms</code> 后的 <code>f</code> 的变体。</p>
<p>在上面的代码中，<code>f</code> 是单个参数的函数，但是你的解决方案应该传递所有参数和上下文 <code>this</code>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
     func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>防抖装饰器</p>
<p><code>debounce(f, ms)</code> 装饰器的结果是一个包装器，该包装器将暂停对 <code>f</code> 的调用，直到经过 <code>ms</code> 毫秒的非活动状态（没有函数调用，“冷却期”），然后使用最新的参数调用 <code>f</code> 一次。</p>
<p>换句话说，<code>debounce</code> 就像一个“接听电话”的秘书，并一直等到 <code>ms</code> 毫秒的安静时间之后，才将最新的呼叫信息传达给“老板”（调用实际的 <code>f</code>）。</p>
<p>举个例子，我们有一个函数 <code>f</code>，并将其替换为 <code>f = debounce(f, 1000)</code>。</p>
<p>然后，如果包装函数非别在 0ms、200ms 和 500ms 时被调用了，之后没有其他调用，那么实际的 <code>f</code> 只会在 1500ms 时被调用一次。也就是说：从最后一次调用开始经过 1000ms 的冷却期之后。</p>
<p>……并且，它将获得最后一个调用的所有参数，其他调用的参数将被忽略。</p>
<p>以下是其实现代码（使用了 <a href="https://lodash.com/docs/4.17.15#debounce" target="_blank" rel="noopener">Lodash library</a> 中的防抖装饰器 ):</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> f <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>alert<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 防抖函数从最后一次函数调用以后等待 1000ms，然后执行：alert("c")</span></code></pre>
<p>现在我们举一个实际中的例子。假设用户输入了一些内容，我们想要在用户输入完成时向服务器发送一个请求。</p>
<p>我们没有必要为每一个字符的输入都发送请求。相反，我们想要等一段时间，然后处理整个结果。</p>
<p>在 Web 浏览器中，我们可以设置一个事件处理程序 —— 一个在每次输入内容发生改动时都会调用的函数。通常，监听所有按键输入的事件的处理程序会被调用的非常频繁。但如果我们为这个处理程序做一个 1000ms 的 <code>debounce</code> 处理，它仅会在最后一次输入后的 1000ms 后被调用一次。</p>
<p>在这个实时演示的示例中，处理程序将结果显示在了下面的方框中，试试看：</p>
<iframe class="code-result__iframe" data-trusted="1" src="https://zh.js.cx/task/debounce/debounce/" style="display: block; border: 0px; width: 701px; height: 200px;"></iframe>

<p>看到了吗？第二个输入框调用了防抖函数，所以它的内容是在最后一次输入的 1000ms 后被处理的。</p>
<p>因此，<code>debounce</code> 是一个处理一系列事件的好方法：无论是系列键盘输入，鼠标移动还是其他类似的事件。</p>
<p>它在最后一次调用之后等待给定的时间，然后运行其可以处理结果的函数。</p>
<p>任务是实现一个 <code>debounce</code> 装饰器。</p>
<p>提示：如果你好好想想，实现它只需要几行代码 :)</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeId<span class="token punctuation">)</span><span class="token punctuation">;</span>
      timeId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    timeId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>节流装饰器</p>
<p>创建一个“节流”装饰器 <code>throttle(f, ms)</code> —— 返回一个包装器。</p>
<p>当被多次调用时，它会在每 <code>ms</code> 毫秒最多将调用传递给 <code>f</code> 一次。</p>
<p>与去抖的不同是，它是个完全不同的装饰器：</p>
<ul>
<li><code>debounce</code> 会在“冷却（cooldown）”期后运行函数一次。适用于处理最终结果。</li>
<li><code>throttle</code> 运行函数的频率不会大于所给定的时间 <code>ms</code> 毫秒。适用于不应该经常进行的定期更新。</li>
</ul>
<p>换句话说，<code>throttle</code> 就像接电话的秘书，但是打扰老板（实际调用 <code>f</code>）的频率不能超过每 <code>ms</code> 毫秒一次。</p>
<p>让我们看看现实生活中的应用程序，以便更好地理解这个需求，并了解它的来源。</p>
<p><strong>例如，我们想要跟踪鼠标移动。</strong></p>
<p>在浏览器中，我们可以设置一个函数，使其在每次鼠标移动时运行，并获取鼠标移动时的指针位置。在使用鼠标的过程中，此函数通常会执行地非常频繁，大概每秒 100 次（每 10 毫秒）。</p>
<p><strong>我们想要在鼠标指针移动时，更新网页上的某些信息。</strong></p>
<p>……但是更新函数 <code>update()</code> 太重了，无法在每个微小移动上都执行。高于每 100ms 更新一次的更新频次也没有意义。</p>
<p>因此，我们将其包装到装饰器中：使用 <code>throttle(update, 100)</code> 作为在每次鼠标移动时运行的函数，而不是原始的 <code>update()</code>。装饰器会被频繁地调用，但是最多每 100ms 将调用转发给 <code>update()</code> 一次。</p>
<p>在视觉上，它看起来像这样：</p>
<ol>
<li>对于第一个鼠标移动，装饰的变体立即将调用传递给 <code>update</code>。这很重要，用户会立即看到我们对其动作的反应。</li>
<li>然后，随着鼠标移动，直到 <code>100ms</code> 没有任何反应。装饰的变体忽略了调用。</li>
<li>在 <code>100ms</code> 结束时 —— 最后一个坐标又发生了一次 <code>update</code>。</li>
<li>然后，最后，鼠标停在某处。装饰的变体会等到 <code>100ms</code> 到期，然后用最后一个坐标运行一次 <code>update</code>。因此，非常重要的是，处理最终的鼠标坐标。</li>
</ol>
<p>一个代码示例：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// f1000 最多每 1000ms 将调用传递给 f 一次</span>
<span class="token keyword">let</span> f1000 <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f1000</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显示 1</span>
<span class="token function">f1000</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (节流，尚未到 1000ms)</span>
<span class="token function">f1000</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (节流，尚未到 1000ms)</span>

<span class="token comment" spellcheck="true">// 当 1000ms 时间到...</span>
<span class="token comment" spellcheck="true">// ...输出 3，中间值 2 被忽略</span></code></pre>
<p>P.S. 参数（arguments）和传递给 <code>f1000</code> 的上下文 <code>this</code> 应该被传递给原始的 <code>f</code>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    savedArgs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      savedArgs <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>savedArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        wrapper<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> savedArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        savedArgs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> wrapper<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>

    </div>
</article>
 <footer>
  <p>
    Theme is <a href="/" target="_blank">Theme-example</a> by
    <a href="https://s1rine.github.io" target="_blank">Sirine</a>
  </p>
  <p>
    Powered by
    <a href="https://hexo.io/" target="_blank" rel="nofollow">hexo</a>
    &copy; 2021
  </p>
</footer>

    </div>
  </body>
</html>
