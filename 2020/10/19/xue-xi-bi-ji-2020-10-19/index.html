<!DOCTYPE html>
<html lang="en">
  <head>
    <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    name="viewport"
  />
  <title>Drowning me></title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

  </head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Drowning me</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
      <li class="menu-item">
        <a href="/" class="menu-item-link"
          >home</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/categories" class="menu-item-link"
          >categories</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/tags" class="menu-item-link"
          >tags</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/archives" class="menu-item-link"
          >archives</a
        >
      </li>
      
      <li class="menu-item">
        <a href="/about" class="menu-item-link"
          >about</a
        >
      </li>
      
    </ul>
  </nav>
</header>
 <article class="post">
    <div class="post-title">
        <h2 class="title">学习笔记 2020 10 19</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-10-19</span>
    </div>
    <div class="post-content">
        <h1 id="学习笔记-2020-10-19"><a href="#学习笔记-2020-10-19" class="headerlink" title="学习笔记 2020-10-19"></a>学习笔记 2020-10-19</h1><a id="more"></a>

<h2 id="JavaScript-高级程序设计-第4版-阅读记录"><a href="#JavaScript-高级程序设计-第4版-阅读记录" class="headerlink" title="JavaScript 高级程序设计(第4版) 阅读记录"></a>JavaScript 高级程序设计(第4版) 阅读记录</h2><h3 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h3><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>每个函数都有一个 <code>prototype</code> 属性。这个属性是一个包含应该由特定引用类型的实例共享的属性和方法的对象。这个对象就是通过调用构造函数创建的对象的原型。在原型对象上定义的属性和方法可以被对象实例共享。</p>
<ol>
<li><h5 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h5><p>创建一个函数，按照特定的规则为这个函数创建一个 <code>prototype</code> 的属性。默认情况下，所有原型对象自动获得一个 <code>constructor</code> 属性，指回与之关联的构造函数。如，<code>Person.prototype.constructor</code> 指向 <code>Person</code> 。</p>
<p>自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其他的所有方法都继承自 <code>Object</code> 。调用构造函数创建的新实例，这个实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象。<code>Firefox</code> 、<code>Safari</code> 和 <code>Chrome</code> 会在对象上暴露 <code>__proto__</code> 属性来访问原型对象。</p>
<p>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * 构造函数可以是函数表达式
 * 也可以是函数声明，因此以下两种形式都可以：
 * function Person() {}
 * let Person = function() {}
 */</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/**
 * 声明之后，构造函数就有了一个
 * 与之关联的原型对象：
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// {</span>
<span class="token comment" spellcheck="true">// constructor: f Person(),</span>
<span class="token comment" spellcheck="true">// __proto__: Object</span>
<span class="token comment" spellcheck="true">// }</span>
<span class="token comment" spellcheck="true">/**
 * 如前所述，构造函数有一个 prototype 属性
 * 引用其原型对象，而这个原型对象也有一个
 * constructor 属性，引用这个构造函数
 * 换句话说，两者循环引用：
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token comment" spellcheck="true">/**
 * 正常的原型链都会终止于 Object 的原型对象
 * Object 原型的原型是 null
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// {</span>
<span class="token comment" spellcheck="true">// constructor: f Object(),</span>
<span class="token comment" spellcheck="true">// toString: ...</span>
<span class="token comment" spellcheck="true">// hasOwnProperty: ...</span>
<span class="token comment" spellcheck="true">// isPrototypeOf: ...</span>
<span class="token comment" spellcheck="true">// ...</span>
<span class="token comment" spellcheck="true">// }</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * 构造函数、原型对象和实例
 * 是 3 个完全不同的对象：
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">!==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">!==</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype <span class="token operator">!==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token comment" spellcheck="true">/**
 * 实例通过__proto__链接到原型对象，
 * 它实际上指向隐藏特性[[Prototype]]
 *
 * 构造函数通过 prototype 属性链接到原型对象
 *
 * 实例与构造函数没有直接联系，与原型对象有直接联系
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token comment" spellcheck="true">/**
 * 同一个构造函数创建的两个实例
 * 共享同一个原型对象：
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> person2<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token comment" spellcheck="true">/**
 * instanceof 检查实例的原型链中
 * 是否包含指定构造函数的原型：
 */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre>
<p>可以使用 <code>isPrototypeOf()</code> 方法检查是否是该构造函数的实例对象。</p>
<p>可以使用 <code>Object.getPrototypeOf()</code> 方法返回参数的内部特性 <code>[[Prototype]]</code> 的值。</p>
<p>可以使用 <code>setPrototypeOf()</code> 方法来写入原型对象。但该方法可能会严重影响代码性能。可以选择使用 <code>Object.create()</code> 来创建一个新对象，为其指定原型。</p>
</li>
<li><h5 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h5><p>在通过对象访问属性时，会按照这个属性的名称开始搜索，首先开始于对象实例本身。如果没有找到，则沿着指针进入原型对象搜索。</p>
<p>通过实例无法重写原型的值。在实例上添加了同名的属性，会在实例自身上创建这个属性，掩盖住原型对象上对应的属性。</p>
<p>当实例上遮蔽了原型对象上的同名属性时，除非使用 <code>delete</code> 删除这个实例上的属性，否则无法再访问到原型对象上的同名属性。</p>
<p>可以使用 <code>hasOwnProperty</code> 来确定某个属性存在于实例还是原型对象。这个方法继承于 <code>Object</code> 。该方法只对实例属性有效，要取得原型属性的描述符，就必须直接在原型对象上调用 <code>Object.getOwnPropertyDescriptor()</code> 。</p>
</li>
<li><h5 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 <code>in</code> 操作符</h5><p><code>in</code> 操作符可以单独使用或是在 <code>for-in</code> 循环中使用。</p>
<p>单独使用时， <code>in</code> 操作符会在可以通过对象访问指定属性时返回 <code>true</code> ，无论该属性是在实例上还是在原型上。</p>
<p>在 <code>for-in</code> 循环中使用 <code>in</code> 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。</p>
<p>可以使用 <code>Object.keys()</code> 方法来获得对象上所有可枚举的实例属性。接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p>
<p>可以使用 <code>Object.getOwnPropertyNames()</code> 来获得所有实例属性，无论是否可以枚举。</p>
<p><code>ES6</code> 新增了一个 <code>Object.getOwnPropertySymbols()</code> 方法来获取符号为键的属性。</p>
</li>
<li><h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序是不确定的。</p>
<p><code>Object.getOwnpropertyNames()</code> 、 <code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，再以插入顺序枚举字符串和符号键。</p>
</li>
</ol>
<h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>ES8</code> 新增了两个静态方法，用于将对象内容转换为序列化的、可迭代的格式。分别是 <code>Object.values()</code> 和 <code>Object.entries()</code> ，都接收一个对象，返回相应内容的数组。</p>
<p><code>Object.values()</code> 返回对象值的数组， <code>Object.entries()</code> 返回键值对的数组。</p>
<p>非字符串属性会被转换为字符串输出。两个方法都执行对象的浅复制。符号属性会被忽略。</p>

    </div>
</article>
 <footer>
  <p>
    Theme is <a href="/" target="_blank">Theme-example</a> by
    <a href="https://s1rine.github.io" target="_blank">Sirine</a>
  </p>
  <p>
    Powered by
    <a href="https://hexo.io/" target="_blank" rel="nofollow">hexo</a>
    &copy; 2021
  </p>
</footer>

    </div>
  </body>
</html>
